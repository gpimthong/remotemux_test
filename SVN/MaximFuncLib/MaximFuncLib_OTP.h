
//DO NOT EDIT THIS FILE
/** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-
*                                                                            
*   @file 		MaximFuncLib_otp.h                                                                           		  
*	URL:				$URL: https://svn.maxim-ic.com/svn/ets/test_programs/AP89/AP89_FT/Trunk/MaximFuncLib/MaximFuncLib_OTP.h $
*   Last Modified by:	$LastChangedBy: govit.pimthong $                                       
*	Date:				$Date: 2017-03-09 12:55:55 +0700 (Thu, 09 Mar 2017) $                                                
*   Current Rev:		$Revision: 61735 $
*                                                                            
*	Description:  
*		Maxim Function library file for OTP trimming functions.  
*  @brief	
*		Contains generic Trim functions that can be called in test programs to trim parameters while communication with a user defined protocol (I2C, SPI, else).
*		Maxim library written and maintained by:								 
*  @author		Brad Sitton  (Brad.Sitton@maximintegrated.com)
*		in collaboration with:
*	@author		Daniele Ghezzi (Daniele.Ghezzi@maximintegrated.com)	                 
*	@author		Robinson Dagaraga (Robinson.Dagaraga@maximintegrated.com)                                                                            
*
*                                                                            
**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****/
//DO NOT EDIT THIS FILE


#ifndef MAXIMFUNCLIB_OTP_H
#define MAXIMFUNCLIB_OTP_H


#pragma once

#include <iostream>
#include <fstream>
#include <set>
#include <map>
#include <string>

// #ifdef ALPHA_OTP // Moving to Release

namespace Maxim
{

// Following is documentation to be used by Doxygen to create help files.
/************************************************************************************************************************************************************For*Doxygen**//**
@page quickStartOTP OTP Quick Start
@details The following represents the recommended way of using the OTP library to trim a device that uses a trim table.

Flexibility has been built into this library, in order to support other search methods, various communication methods, and even facilitate your characterization.
The library has been set up to perform datalogging in a typical format, but you have the option of defining your own datalogging routines.

Step 1 --- Declare trim related items in GlobalTrims.h and GlobalTrims.cpp.  Click DUT::Trim for an example.  

Step 2 --- Find DUT::Trim::InitializeTrims() in GlobalTrims.cpp and use it as a template to load information that is specific to your trim.

Step 3 --- Now that all of your initializations are done, go to whatever function you plan on performing trim in.  
				- Set your device into the correct state
				- See example below to find the best trim code, using the trim table, measurement routine, etc. that you specified during earlier steps.
@code
	// Put your device in the correct DC state to start searching for the best trim code.
	DUT::Trim::gtsIBias.FindBestTrimCode(iDSIndex);  // This line will use trim table and other information that you have set up to find the best trim code.
@endcode

@attention Make sure DUT::Trim::InitializeTrims() is called in Maxim_OnTestInit() which can be found in Globals.cpp.  This is especially important
				if you started your program with an older template and then updated to a version supporting OTP.

@section AdditionalFunctions Additional Functions

Maxim::OTP::CTrimStructure::CharacterizeBitWeights()
@code
	DUT::Trim::gtsIbias.CharacterizeBitWeights(); // See Maxim::OTP::CTrimStructure::CharacterizeBitWeights() for more information.
@endcode

Maxim::OTP::CTrimStructure::SetStartingTrimCode(int 	iStartingTrimCode, int 	iMaximumVariation = 1e16 )	
@code
	DUT::Trim::gtsIbias.SetStartingTrimCode(8, 0); //Will use 8 as a starting trim code and will not try to optimize based on the most popular trim code for the lot.
@endcode

Maxim::OTP::CTrimStructure::Measure()
@code
	DUT::Trim::gtsIbias.Measure();   // Use this function for performing the measurement in other places in code, like the post power down / power up verification.
@endcode

Performing OTP with shared instruments is addressed at @ref sharingInstruments 

Maxim::OTP::CTrimData::PostTrimCode()
@code
	DUT::Trim::gtsIbias.PostTrimCode();   // Use this function for performing the measurement in other places in code, like the post power down / power up verification.
@endcode

@section Debugging Debugging

Watch your trim variable, using the Public Attributes section of Maxim::OTP::CTrimData to interpret the values below:

@image html OTPWatchDebug.jpg



**************************************************************************************************************************************************************/

/*********************************************************************************************************************************************For*Doxygen**//**
@brief Contains classes, functions and variables that simplify the process of OTP trimming.  Refer to @ref quickStartOTP for more information
**************************************************************************************************************************************************************/
	namespace OTP 
	{


// Used for the case where no special action is required to re-enter register write mode after measuring a device, during trim search.  
//		This do nothing function takes the place of a NULL pointer which would cause a crash. 
inline void			EnterRegisterWriteModeDefault(){;};

/*********************************************************************************************************************************************For*Doxygen**//**
 Stores trim information that is global to the device
**************************************************************************************************************************************************************/
class CSharedTrimInformation{
	friend class CTrimStructure;
private:
	SiteBool				msbLockBit; // A location to store lock bit status
	bool					mbForceTrimSearch ; // Used to force trim search routine to run.  Mainly useful for debug or verification of trim algorithm when using trimmed devices.
	std::set<std::string>	msetsValidTrimSteps; /// Stores a list of trim steps that are valid.  By default FTROOM
	std::map<std::string, CTrimStructure*> mapTrims;
	int			miNewDeviceResetCount; // Provides a sanity check to detect if NewDevice is not being called for every new insertion.

public:
	void	AddTrimStepForAllTrims(std::string sTrimStep); // Adds a trim step that is valid for all trims.
	bool	IsOKToTrim(int iSite=MS_ALL);  // Should not attempt to trim if Lock Bit has been set or if site is not active.

	void	NewDevice();  // Will initialize trim structure variables so that confusion does not arrive from having data from the previously tested device.
							// This function is called inside the OnTestStartup(), so user does not need to worry about it.
	CSharedTrimInformation() { miNewDeviceResetCount = 0; }  
};

/*********************************************************************************************************************************************For*Doxygen**//**
 Stores trim information that is global to the device
**************************************************************************************************************************************************************/
extern CSharedTrimInformation	sharedTrimInformation;  // BRS 7/9/13  I believe it makes sense to declare this global variable here, since there should be only one instance 
														//				and this would standardize variable name.


/*********************************************************************************************************************************************For*Doxygen**//**
 Stores results from performing a trim device
**************************************************************************************************************************************************************/
class CTrimResult{
public:
	SiteInt		msiCode;			// Trim code that was used to obtain the results
	PinListData	mpldMeasurement;
	PinListData	mpldError;
	PinListData	mpldDomainError;

	CTrimResult()
	{
		// Since no valid data exists when object is created, default members to values which are obviously invalid
		msiCode = MAXIM_INVALID;
		mpldMeasurement = PinListData();	//call default constructor again to reset for the next insertion
		mpldError		= PinListData();
		mpldDomainError	= PinListData();
	}
};

/// Create a SiteDouble version of CTrimResult().  Will be used to create mBestTrim.  
/// PLD does not work well for mBestTrim because elements need to be modified in a site loop.
/// After a few conversations with Pat, this seems like the best approach.
class CTrimResultSD{
public:
	SiteInt		msiCode;			// Trim code that was used to obtain the results
	SiteDouble	msdMeasurement;
	SiteDouble	msdError;
	SiteDouble	msdDomainError;

	CTrimResultSD()
	{
		// Since no valid data exists when object is created, default members to values which are obviously invalid
		msiCode = MAXIM_INVALID;
		msdMeasurement = HUGE_VAL;
		msdError		= HUGE_VAL;
		msdDomainError	= HUGE_VAL;
	}
};

/*********************************************************************************************************************************************For*Doxygen**//**
 Stores settings that will be used when characterizing a device.  See Maxim::OTP::CTrimStructure.CharacterizeBitWeights
**************************************************************************************************************************************************************/
class CCharacterizationSettings
{
public:
	int		miColumnWidth;
	int		miScreenMaxColumnsPerRow;
	bool	mbOutputToFile;
	bool	mbOutputToScreen;
//	std::string msFileName;

	CCharacterizationSettings() 
	{
		miColumnWidth = 16;
		miScreenMaxColumnsPerRow = 8;
		mbOutputToFile = TRUE;
		mbOutputToScreen = TRUE;
	}
};

extern 	CCharacterizationSettings characterizationSettings;

/*********************************************************************************************************************************************For*Doxygen**//**
Stores data related to a trim parameter.  This includes targets, trim tables, various settings and several other pieces of information.
**************************************************************************************************************************************************************/
/// Store general information needed to perform a trim.	Typically you should not access these variables (Public Attributes) directly.
///		When possible, use the corresponding member functions to perform settings.
class CTrimData
{
	public:

	/*! \brief Stores the trim target.  Trim target is generally the same for all sites, but using a SiteDouble allows targets
	 		to be different for different sites.  This comes up for some matching trims, where target is based on another measurement */
	SiteDouble	msdTarget;
	/// Accuracy that is desired.  If this is met, then the routines will quit searching for a better trim code. 
	double	mdAccuracy;
	/// Units of measure that datalogs will be in
	double	mdDatalogUnits;
	/// Trim Table
	std::map<int, double>	mmapTrimTable;
	/// Stores the best trim results for this device
	CTrimResultSD		mBestTrim;
	/// Total number of attempts for the current device (used with trim tables)
	SiteInt				msiNumberOfAttempts;	
	/// Stores the trim results of every attempt for the current device
	std::vector<CTrimResult> mvResults;				
	/// Needed for site loops where we must backfill the trim results for currently tested sites
	std::vector<CTrimResult>::iterator mitCurrentResult; 
	// Counts of how often each trim code was used.  Used to optimize the pretrim code.  First parameter is trim code, 
	//      second parameter is the count of how many times that code was the best.
	std::map<int, SiteInt>	mmapBestTrimCodeCount;		

	/// String version of trim name is useful when outputting to screen or file 
	std::string msTrimName; 
	/*! \brief  Not used directly by the class.
			Pin number can be used to improve flexibility of measure functions by allowing each
			trim to use a different set of pins when measuring. */
	int		miPin;			
	/*! \brief  Not used directly by the class.  User can use this value to store a customized delay time
		 that they will retrieve in their measure function.  This can improve flexibility of
		 their measure function.	*/
	double	mdDelay;		
	/// Pointer to the datasheet index, which is needed for datalogging purposes
	int*	mptriDSIndex;
	/// Enables or disables datalogging
	bool	mbDataloggingEnabled;
	/// Stores the maximum number of iterations that will be attempted when trimming a device.  Default is 3.
	int		miMaximumAttempts;	
	/// Address of device being trimmed
	int		miDeviceAddress;		
	/// Device register where trim codes are stored.
	int		miTrimRegister;		
	/// Minimum step size between trim codes (generally 1)		 
	int		miCodeStep;			
	/// When set true, the routine will continue searching until it has found the best trim code instead of stopping when mdAccuracy has been met.
	bool	mbPrioritizeAccuracyOverSpeed;
	///  The original value for msiFirstTrimCode.  This becomes useful if the program is optimizing the starting trim code
	///		by performing pre-trim with the most popular trim code.
	int		miFirstTrimCodeOriginal;			
	/*! \brief  Sets the maximum variation from miFirstTrimCodeOriginal that is allowed for the first trim code.
			 - If the value is set to 0, then pre-trim code is never allowed to change. */
	int		miFirstTrimCodeMaximumVariation;
	/// Stores the operation (step) that all trims will be performed at. 
	std::set<std::string>	msValidTrimSteps;
	/// Characterization results
	std::map<int, SiteDouble>	mmapCharTable;
	

	CTrimData()
	{
		mbDataloggingEnabled = false;
	}

	//Functions make it easier for user to retrieve certain measurements.
	bool IsDataloggingEnabled();
	SiteInt PreTrimCode();
	PinListData PreTrimMeasurement();
	SiteInt PostTrimCode();
	PinListData PostTrimMeasurement();
	/// Set the maximum number of attempts to converge to best trim code.  Default is 3 if this function not called.
	void SetMaximumAttempts(int iMaximumAttempts) { miMaximumAttempts = iMaximumAttempts; }
	/// Disable or enable automatic datalogging. 
	/// @param bSetting TRUE or FALSE depending on whether you want datalogging enabled
	void	EnableDatalogging(bool bSetting) { mbDataloggingEnabled = bSetting; }
	SiteInt		NumberOfAttempts() {return msiNumberOfAttempts;}
	SiteDouble GetTrimTableValue(SiteInt siTrimCode);

};

// Define several domain functions that a user may want; 
PinListData	DomainTransformDefault(PinListData pldValue, CTrimStructure* tsTrim);
PinListData	DomainTransformReciprocal(PinListData pldValue, CTrimStructure* tsTrim); 
PinListData	DomainTransformOffsetPercentOfPretrim(PinListData pldValue, CTrimStructure* tsTrim);
PinListData	DomainTransformOffsetRatioOfPretrim(PinListData pldValue, CTrimStructure* tsTrim); 
PinListData	DomainTransformOffsetPercentOfTarget(PinListData pldValue, CTrimStructure* tsTrim); 
PinListData	DomainTransformOffsetOffsetRatioOfTarget(PinListData pldValue, CTrimStructure* tsTrim); 

void	PreTrimDatalogDefault(CTrimStructure* tsTrim); 
void	PostTrimDatalogDefault(CTrimStructure* tsTrim); 

// Define functions which will determine the next trim code to be attempted during a trim search
SiteInt	DetermineNextTrimCodeUsingTable(CTrimData* trimData);

// Define function types which are useful when storing function pointers in class objects
// These typedefs need to occur after CTrimData declaration and before CTrimStructure declaration.

typedef void		(*EnterRegisterWriteModeFunction)();
typedef SiteInt		(*SetTrimRegisterFunction)(int iDeviceAddress, int iRegister, SiteInt siRegisterSetting);
typedef	PinListData (*MeasureFunction)(CTrimStructure*); 
typedef PinListData	(*DomainTransformFunction)(PinListData, CTrimStructure*);
typedef SiteInt		(*DetermineNextTrimCodeFunction)(CTrimData*);
typedef void		(*PreTrimDatalogFunction)(CTrimStructure*);
typedef void		(*PostTrimDatalogFunction)(CTrimStructure*);

/*********************************************************************************************************************************************For*Doxygen**//**
Stores all information related to a trim parameter.  This includes communication function, measurement routines in addition to information from the parent class TrimData
- Having trim data stored in a parent class is useful when trying to access data with the DomainTransformation function.
- DomainTransformation function needs trim data to be passed in, however it is part of the trim structure class so one
can't pass in the full CTrimStructure.  
- Since CTrimData is a parent class, one should be able to access the necessary data.
**************************************************************************************************************************************************************/
class CTrimStructure: public CTrimData
{
private:

	// Store function pointers in a private area.  Wrapper functions will check for NULL conditions before calling these functions.
	EnterRegisterWriteModeFunction	mEnterRegisterWriteMode;
	SetTrimRegisterFunction			mSetTrimRegister;
	MeasureFunction					mMeasure; 
	DomainTransformFunction			mDomainTransform;
	DetermineNextTrimCodeFunction	mDetermineNextTrimCode;
	PreTrimDatalogFunction			mPreTrimDatalogFunction;
	PostTrimDatalogFunction			mPostTrimDatalogFunction;
	std::string						msCharacterizationFileName;						

public:	
	CTrimStructure(){miMaximumAttempts = 3; mEnterRegisterWriteMode = *EnterRegisterWriteModeDefault; mDetermineNextTrimCode = DetermineNextTrimCodeUsingTable;} ///default constructor.  Seems to be required if an extern statement is used.
	void LoadTrimInformation( std::string sTrimName, SiteDouble sdTarget, double dAccuracy, double dDatalogUnits, int iDeviceAddress, int iTrimRegister);
	void LoadTrimInformation( std::string sTrimName, SiteDouble sdTarget, double dAccuracy, double dDatalogUnits, int iDeviceAddress, int iTrimRegister, int &iDSIndex);
	void LoadTrimTable(int iSizeOfTable, double dTrimTable[], int iTrimCodeArray[]=NULL);
		//Allows user to provide a seperate array with trim codes that are associated with each trim table value.  This is useful if trim codes are not sequential.
	void LoadTrimTable(std::map<int, double> mapTrimTable);
		//Allows user to provide trim information via a map
	void LoadTrimFunctions(	void		(*EnterRegisterWriteMode)(),
							SiteInt		(*SetTrimRegister)(int iDeviceAddress, int iRegister, SiteInt siRegisterSetting),
							PinListData (*MeasureFunction)(CTrimStructure *), 
							PinListData	(*DomainFunction)(PinListData, CTrimStructure*)=NULL);
	void LoadTrimFunctions(	SiteInt		(*SetTrimRegister)(int iDeviceAddress, int iRegister, SiteInt siRegisterSetting),
							PinListData (*MeasureFunction)(CTrimStructure *), 
							PinListData	(*DomainFunction)(PinListData, CTrimStructure*)=NULL) ;
	void LoadDatalogFunctions( void (*PreTrimDatalogFunction)(CTrimStructure *), void (*PostTrimDatalogFunction)(CTrimStructure *));

	// Allows you to change trim target without passing any additional information
	void LoadTrimTarget(SiteDouble sdTarget);

	//Wrappers for various function pointers that are stored with the class.  Main reason is to check for NULL pointers before executing the function pointers
	void EnterRegisterWriteMode()
	{
		if(NULL == mEnterRegisterWriteMode) mEnterRegisterWriteMode = EnterRegisterWriteModeDefault;
		mEnterRegisterWriteMode();
	}

	SiteInt	SetTrimRegister(int iDeviceAddress, int iRegister, SiteInt siRegisterSetting)
	{
		if(NULL == mSetTrimRegister) 
		{
			Maxim::System::Message.Deliver("Maxim::OTP::SetTrimRegister function was used improperly/n SetTrimRegister() function is set to NULL/n ");
			return MAXIM_INVALID;
		}
		else return mSetTrimRegister(iDeviceAddress, iRegister, siRegisterSetting);
	}


/**********************************************************************************************************************************************For*Doxygen**//**
Will perform a measurement for the calling trim using the measurement routine that should have been loaded in GlobalTrims.cpp.

@code
	DUT::Trim::gtsIBias.Meaure()
@endcode
**************************************************************************************************************************************************************/
	PinListData	Measure()
	{
		if(NULL == mMeasure)
		{
			Maxim::System::Message.Deliver("Maxim::OTP::CTrimStructure function was used improperly/n Measure function is set to NULL/n FindBestTrimCode will abort so program does not crash");
			return HUGE_VAL;
		}
		else return mMeasure(this);
	}


	
	PinListData DomainTransform(PinListData pldValue, CTrimStructure* tsTrim)
	{
		if(NULL == mDomainTransform) mDomainTransform = DomainTransformDefault;

		return mDomainTransform(pldValue, tsTrim);
	}

	SiteInt DetermineNextTrimCode(CTrimData* trimData)
	{
		if(NULL == mDetermineNextTrimCode) mDetermineNextTrimCode = DetermineNextTrimCodeUsingTable; // Default condition is trim using table
	}

/**********************************************************************************************************************************************For*Doxygen**//**
Perform pretrim datalogging.  Normally you can let the OTP routines perform their own datalogging, but in the case of shared resources you
will need to complete the shared resource loop, measuring values for all sites and then datalog all sites at the same time.  Having access
to this function allows you to perform datalogging in the exact same way that it would be done by the OTP routine run without shared resources.

@code
	DUT::Trim::gtsIBias.PreTrimDatalog()
@endcode
**************************************************************************************************************************************************************/
	void PreTrimDatalog()
	{
		if(NULL == mPreTrimDatalogFunction) mPreTrimDatalogFunction = PreTrimDatalogDefault;

		return mPreTrimDatalogFunction(this);
	}

	void PreTrimDatalog(int &iDSIndex)
	{
		// Will update the DS Index pointer.
		mptriDSIndex = &iDSIndex;

		return PreTrimDatalog();
	}

/**********************************************************************************************************************************************For*Doxygen**//**
Perform post trim datalogging.  Normally you can let the OTP routines perform their own datalogging, but in the case of shared resources you
will need to complete the shared resource loop, measuring values for all sites and then datalog all sites at the same time.  Having access
to this function allows you to perform datalogging in the exact same way that it would be done by the OTP routine run without shared resources.

@code
	DUT::Trim::gtsIBias.PostTrimDatalog()
@endcode
**************************************************************************************************************************************************************/
	void PostTrimDatalog()
	{
		if(NULL == mPostTrimDatalogFunction) mPostTrimDatalogFunction = PostTrimDatalogDefault;

		return mPostTrimDatalogFunction(this);
	}

	void PostTrimDatalog(int &iDSIndex)
	{
		// Will update the DS Index pointer.
		mptriDSIndex = &iDSIndex;

		return PostTrimDatalog();
	}

	~CTrimStructure()
	{
		// Need to erase the corresponding map pointer if the trim object is deconstructed.
		if(sharedTrimInformation.mapTrims.find(msTrimName) != sharedTrimInformation.mapTrims.end())
			sharedTrimInformation.mapTrims.erase(sharedTrimInformation.mapTrims.find(msTrimName));
	}  

	void InitializeDeviceResults();

	void OptimizeStartingTrimCode(int iMaximumVariation=1e16);

	void AddValidTrimStep(std:: string sTrimStep);  // Stores list of valid trim steps.  Note that an empty list implies trimming can be done at any step

	void FindBestTrimCode() ;
	void FindBestTrimCode(int& iDSIndex) ;
	
		// Uses a trim table to converge to best trim code using a small number of iterations.
		// User must provide SetTrimRegister(int iRegister, SiteInt siRegister setting) function and MeasureFunction();
		// The DomainFunction() is optional.  It is used when measured values are in different units from your trim table,
		//		For example, the trim table is in period domain, but the measured value is in frequency domain.
		// Note that bFirstPass can be used by your custom SetTrimRegister() routine to perform slightly different 
		//    steps on the first iteration.  This is useful if the device will be in a different state after measuring,
		//    than what it was in when first entering the trim routine.
		// Note full version of the function allows you to pass in a EnterRegisterWriteMode() function. This is for cases where
		//    measurements are done in a different test mode from the test mode used for making measurements

	SiteInt FindNextTrimCodeUsingTable(CTrimData* trimData);

	void PrioritizeAccuracyOverSpeed(bool bPriority) {mbPrioritizeAccuracyOverSpeed = bPriority;} //Set to TRUE if we want to keep searching even if accuracy resolution is met

	SiteInt	GetStartingTrimCode();
	void	SetStartingTrimCode(int iStartingTrimCode, int iMaximumVariation = 1e16);
	void	StoreResults(SiteInt siTrimCode, PinListData pldMeasurement);
	SiteInt	EvaluateMeasurement( SiteInt siTrimCode, SiteBool &sbKeepSearchingForTrimCode);
		//Evaluate trim results and store the next trim code that should be attempted.

	void EnableTrimDatalogging(int &iDSIndex) {mptriDSIndex = &iDSIndex;};
	SiteDouble GetTargetValue(void) {return msdTarget;};

	void CharacterizeBitWeights(int iTrimTableReferenceCode = 0);	

};  //end class TrimStructure 

/*********************************************************************************************************************************************For*Doxygen**//**
 Structure to help make debugging information.
**************************************************************************************************************************************************************/
class CDebugInformation
{
	friend class CTrimStructure;

	class CTrimInfo
	{
	public:	
		CTrimInfo() {;}
		class CWeightInfo
		{
		public:
			double	mdTrimTableWeight;
			double	mdMeasuredWeight;
		};
		class CMeasureInfo
		{
		public:
			int		miTrimCode;
			double	mdMeasuredValue;
			CMeasureInfo() {;};
			CMeasureInfo(int iTrimCode, double dMeasuredValue)
			{
				miTrimCode = iTrimCode;
				mdMeasuredValue = dMeasuredValue;
			}
		};

		double mdAccuracy;
		SiteDouble msdTarget;
//		double mdTarget;
		std::vector<CMeasureInfo> mvCodeVsMeasurement;
		std::map<int, CWeightInfo> mmapCodeVsTrimWeights;
	};

	int miSite;
	std::map<std::string, CTrimInfo> mmapInformation;

public:
	CDebugInformation() { miSite = 0;}
	void SetSite(int iSite){ miSite = iSite; }

	// Perform cleanup that is needed on each new device
	void NewDevice()
	{
		//Cycle through each trim
		for(std::map<std::string, CTrimInfo>::iterator itInformation = mmapInformation.begin(); itInformation != mmapInformation.end(); itInformation++)
		{
			//Remove measurement based trim weights, but retain the trim table information so can't run a simple clear command
			for(std::map<int, CTrimInfo::CWeightInfo>::iterator itWeights =  itInformation->second.mmapCodeVsTrimWeights.begin(); 
																itWeights != itInformation->second.mmapCodeVsTrimWeights.end();   
																itWeights++)
			{
				itWeights->second.mdMeasuredWeight = 0;
			}

			// Remove all measurement information
			itInformation->second.mvCodeVsMeasurement.clear();
		}
	};

	// Update information for the site specified in miSite (default is 0); 
	void UpdateWithLatestMeasurement(CTrimStructure* tsTrim) 
	{
		// Obtain last set of trim information
		std::vector<CTrimResult>::iterator itTrimResult = tsTrim->mvResults.end() - 1; // Point to the last valid result in the vector.

		//Obtain pointer to the trim information that we are currently dealing with
		CTrimInfo *tiMatchingTrim = & mmapInformation.at(tsTrim->msTrimName);

		// Store trim code and measured value corresponding to miSite for debug purposes
//		mmapInformation.at(tsTrim.msTrimName).mvCodeVsMeasurement.push_back(CTrimInfo::CMeasureInfo(trLastTrim.msiCode[miSite], trLastTrim.mpldMeasurement[miSite]));
		tiMatchingTrim->mvCodeVsMeasurement.push_back(CTrimInfo::CMeasureInfo(itTrimResult->msiCode[miSite], itTrimResult->mpldMeasurement[miSite]));

		//Store trim weight corresponding to miSite for debug purposes
//	CAUTION CAUTION CAUTION CAUTION CAUTION CAUTION CAUTION CAUTION CAUTION CAUTION CAUTION CAUTION CAUTION CAUTION CAUTION CAUTION CAUTION CAUTION CAUTION CAUTION CAUTION CAUTION 
		//	THIS IS VERRRRRRRRRRRRRRRRYYYYYYYYYY TRICKY.
		//	The goal is to record trim weights.  
		//	The problem:
		//		The domain transformation for some trims may be relative to a specific code such as 0.
		//		However this device may not have measurement information for the specified code.
		//		How does one calculate the actual trim weight information when one piece of actual information is missing?
		//	The solution:
		//		If the reference information does not exist, then assume the first measurement (pretrim) is accurate and copy trim weight from table
		//		All additional measurements will have their effective trim weight calculated relative to the first trim weight.

		// For the first trim we need to assume its trim weight is accurate since we have no point of reference to say otherwise.
//		double dFirstMeasurement;
		double dFirstDomainError;
		double dFirstTrimWeight;

		int iFirstTrimCode = tiMatchingTrim->mvCodeVsMeasurement.begin()->miTrimCode; // Trim code for first device being logged by Debug
		dFirstDomainError = tsTrim->mvResults.begin()->mpldDomainError[miSite];
		dFirstTrimWeight =  tsTrim->mmapTrimTable.at(iFirstTrimCode);
		

		// Now we can calculate trim weights for this device and this trim code.
		double dThisDomainError;

		int iTrimCode = itTrimResult->msiCode[miSite];
		dThisDomainError = itTrimResult->mpldDomainError[miSite];

		// This is the big step where trim weight is calculated!!!!!!!!!
		//		The trim table is in the same domain as the domain error and the following relationship exists:
		//		TrimTable(meas2) - TrimTable(meas1) = DomainError(meas2) - DomainError(meas1)
		//		A bit of algebra and we get the calculation below.
		tiMatchingTrim->mmapCodeVsTrimWeights.at(iTrimCode).mdMeasuredWeight =  (dThisDomainError - dFirstDomainError) + dFirstTrimWeight;

	}

};

//Disabling because it may cause more problems than it solves    extern CDebugInformation Debug;


//Declare OTP store/retrieve functions https://confluence.maxim-ic.com/pages/viewpage.action?pageId=41649779
bool StoreCode(std::string strRegister,SiteInt siCode, bool bXYOverride=false, SiteInt siX=0, SiteInt siY=0);
bool RetrieveCode(std::string strRegister, SiteInt &siCode, bool bXYOverride=false, SiteInt siX=0, SiteInt siY=0);
//Declare ABU scratchpad function https://confluence.maxim-ic.com/display/~Govit.Pimthong/ABU+Power+Scratch+Pad+-+Die+ID+Tracking?focusedCommentId=38864421#comment-38864421
	} //end namespace OTP

	
} //end namespace Maxim


#endif


