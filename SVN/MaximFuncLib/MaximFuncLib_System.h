
//DO NOT EDIT THIS FILE
/*** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-
*                                                                            
*	Source title:		MaximFuncLib_System.h                                                                           		  
*	URL:				$URL: https://svn.maxim-ic.com/svn/ets/test_programs/AP89/AP89_FT/Trunk/MaximFuncLib/MaximFuncLib_System.h $
*   Last Modified by:	$LastChangedBy: govit.pimthong $                                       
*	Date:				$Date: 2017-03-09 12:55:55 +0700 (Thu, 09 Mar 2017) $                                                
*   Current Rev:		$Revision: 61735 $
*                                                                            
*	Description:  
*		Maxim library written and maintained by:								 
*			@author		Brad Sitton  (Brad.Sitton@maximintegrated.com)
*		                                                           
*
*   Revision History 
*                                                                            
**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****/
//DO NOT EDIT THIS FILE

///	@file	MaximFuncLib_System.h
///	@brief	Contains functions and classes that involve the ETS system, but are not typically specific to a single instrument/
///			This means they may relate to no instrument or multiple instruments.
/// @author	Brad.Sitton@MaximIntegrated.com


#ifndef MAXIMLIBFUNC_SYSTEM_H
#define MAXIMLIBFUNC_SYSTEM_H

#pragma once
#include <iostream>
#include <fstream>
#include <set>
#include <map>
#include <string>
#include <vector>

// Following comments are for the Doxygen Main Page.  Not sure it belongs here, but since this is where I put random System related functions, it seemed like a good
// place to put a General library wide comments for the Main Page.

/************************************************************************************************************************************************************For*Doxygen**//**
@mainpage ETS Library Main Page

@section overviewSection Overview

This is the official help file for the ETS Template and Library.  Feedback can be provided using the links below:
- <a href="https://jira.maxim-ic.com/secure/CreateIssue!default.jspa?selectedProjectId=11725&issuetype=8">Inquiry</a>
- <a href="https://jira.maxim-ic.com/secure/CreateIssue!default.jspa?selectedProjectId=11725&issuetype=1">Bug Report</a>
- <a href="https://jira.maxim-ic.com/secure/CreateIssue!default.jspa?selectedProjectId=11725&issuetype=4">Improvement</a>
- <a href="https://jira.maxim-ic.com/secure/CreateIssue!default.jspa?selectedProjectId=11725&issuetype=2">New Feature</a>

@note It is easy to overlook the __More__ link at the end of brief descriptions.  This link will take you to a detailed description with much more information and/or examples.  

Opening a namespace in this help file will typically provide an overview of how to get started using the functions in the namespace.  

@section quickStartSection Quick Start Links

@ref quickStartProgramControl @n

@ref quickStartCBit @n
@ref quickStartDatalog @n
@ref quickStartDPAT @n
@ref quickStartI2C @n
@ref quickStartMeter @n
@ref quickStartOTP @n
@ref quickStartPinListData @n

@section sharingResourcesSection	Sharing Resources
@ref sharingInstruments@n


@section usefulFunctions	Useful Functions You Should Know
Click on the functions below to learn more about them.

@code
Maxim::System::Message.Deliver("Best way to display messages in pop up windows and/or output Window.");

ForEachActive_iSite { double dMax = max(dMax, fabs(sdValue[iSite]));}  // Easier site loops
@endcode

**************************************************************************************************************************************************************/	

/************************************************************************************************************************************************************For*Doxygen**//**
@page sharingInstruments Sharing Instruments
@details Simplified method of sharing instruments between sites.

The example shown below is for SPU, but will work for APU and most likely other instruments.

# Problem #
Sometimes resources need to be shared among different sites which requires special handling:
- For example you may need to share 2 SPU's among 4 sites.
- A loop is needed to go through each group of sites that will be tested at the same time.  
    For example, you might test sites 1 and 3 first with sites 2 and 4 being tested the second time through the loop.
- Temporarily assign an instrument to a specific site
- Only force/measure on the sites that are active.
- Measurements need to be combined into a single PinListData variable for datalogging purposes.
- Make sure all sites are active when you finish your resource sharing loop.
- Happens most frequently with SPU since there are only two instruments per sector.

# Solution #

The Maxim::System::CSharedPinGroups class has been developed to help facilitate sharing of resources.  The example below
will show you how to setup SPU6 and SPU7 to be shared among 4 sites on a sector.  It involves defining the pin in the 
Pin Map Editor and inserting code in your program.

-# Setup the SPU __pins__ on the Pin Map Editor to be "No Site"
@image html https://confluence.maxim-ic.com/download/attachments/25103915/ETS_88_Pin_Map_SPU_No_Site_4_Sites.jpg
-# Setup a __group__ of the SPU "No Site" channels on the Pin Map Editor.
@image html https://confluence.maxim-ic.com/download/attachments/25103915/ETS_88_Pin_Map_SPU_No_Site_Group.jpg
-# Examine function definitions in Maxim::System::CSharedPinGroups for clarification on what is being done in
     each step of the example below.
	-# The following can be done in either Globals or in the Test Function, depending on how you plan to use the
	-# The code defines an object that will be used to track the shared pin groups.
@code
	Maxim::System::CSharedPinGroups SPUShareGroup;  // Create a shared pin group
	SPUShareGroup.Share(0, SHARED_SPU_6, 0);        // Group 0 will have SPU6 associated with site 0
	SPUShareGroup.Share(0, SHARED_SPU_7, 1);        // Group 0 will have SPU7 associated with site 1
	SPUShareGroup.Share(1, SHARED_SPU_6, 2);		// Group 1 will have SPU6 associated with site 2
	SPUShareGroup.Share(1, SHARED_SPU_7, 3);        // Group 1 will have SPU7 associated with site 3
@endcode
-# The parameters in the for loop cause the loop:
	-# Increment through each shared pin group defined above
	-# SPU6 and SPU7 are associated with the proper sites at the appropriate time through the loop.  The instruments will return
      to no site upon exiting the loop.
	-# All sites have the proper msSetSiteUserStopped() executed each time through the loop and upon exiting the loop will ensure 
		  that all user stopped events are cleared.
@code
	// Loop through every "shared pin group" which in this case is 0 and 1, the first parameter in the SPUShareGroup.Share command above.
	for(SPUShareGroup.Start(); !SPUShareGroup.Finished(); SPUShareGroup.Next())
	{
		// The following switch statement allows specific relays (settings, etc.) to be configured based
		//   on which group of sites we are dealing with.
		switch (SPUShareGroup.GetSharedInstrumentGroupNumber())
		{
		case 0:										// Group 0 is sites 0 and 1 as defined above
			//Connect SPU's to the proper site
			cbitopen(K903);   
			cbitopen(K904);   
			break;

		case 1:										// Group 1 is sites 2 and 3 as defined above
			//Connect SPU's to the proper site
			cbitclose(K903);   
			cbitclose(K904);   
			break;		
		default:
			Maxim::System::Message.Deliver("Tried to access a SiteGroup that does not exist");
		};

		// Perform normal ETS commands using names you defined in the pin map editor
		sp112set( SPU_Share_Group, SP_FI, 0.0, SP_10V, SP_2A );
		apu12setcapload(FSYNC, APU12_FV, 5 V_f, APU12_10V, APU12_1MA, 2, APU12_PIN_TO_VI );
		lwait( 2 ms_f );

		pldResults = pldResults & AP47::Utils::Test_Ramp_Threshold_Char( 500.0, 1600.0, 10.0, 4.0, 1, Set_ILIM_Trim, Meas_ILIM_Trim); //target=1.0A

		//ramp current down
		sp112set( SPU_Share_Group, SP_FI, 0.0, SP_10V, SP_2A );
		lwait( 1 ms_f );
		apu12setcapload(FSYNC, APU12_FV, 0 V_f, APU12_10V, APU12_1MA, 1, APU12_PIN_TO_VI );
		lwait( 1 ms_f );

		//power down the SPUs for the next loop.
		sp112set( SPU_Share_Group, SP_OFF, 0.0, SP_10V, SP_2A );
		lwait( 1 ms_f );
	}

	//Exit the loop, and perform datalogging
	Maxim::DatalogAll(DSIndex, pldResults);
@endcode

@attention
If you are using Maxim::OTP routines inside a site loop, then you need to 
-# Turn off the automatic datalogging by not passing iDSIndex into the FindBestTrim() function 
-# Perform datalogging after the share group loop has completed.  The methods of interest are:
@code
	DUT::Trim::gtsIBias.PreTrimDatalog(iDSIndex);   // Performed after exiting the site loop
	DUT::Trim::gtsIBias.PostTrimDatalog(iDSIndex); 
@endcode

**************************************************************************************************************************************************************/	



namespace Maxim
{
	bool isChar();
}


template <typename T, size_t N>
/************************************************************************************************************************************************************For*Doxygen**//**
	Copies an array into a vector
	@param	AA is the array
	@param	VV must be a vector that can store the same type of data as AA contains
	@warning	This function only works if called inside the same function where the array was initialized, because this is the only location 
					where the compiler is able to automatically figure out the size of the array.  Remember that in general an array is just a pointer
					to the first element and does not contain any information about the size of the array.
*** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****/
void CopyArrayIntoVector( T(&AA)[N], std::vector<T> &VV )
{
	VV.assign(AA, AA+N);
}


/************************************************************************************************************************************************************For*Doxygen**//**
				Returns the size of an array by calling SizeOfArray(YourArrayHere);
	@param[in]	T is the array that you want the size of
	@return		Size of the array.
	@note		Size of 0 or 1 may be suspicious.  Not sure what happens if this function is used with an array that was passed in as opposed to declared locally.
	@warning	This function only works if called inside the same function where the array was initialized, because this is the only location 
					where the compiler is able to automatically figure out the size of the array.  Remember that in general an array is just a pointer
					to the first element and does not contain any information about the size of the array.
******************************************************************************-*******************************************************************************/
template <typename T, size_t N>
int SizeOfArray( const T(&)[ N ] )
{
  return (int) N;
}
// #define SizeOfArray(X) sizeof(X)/sizeof(X[0]) // Luther's solution, not sure which is better


/// The majority of functions developed within Maxim should fall under the Maxim namespace.  
namespace Maxim
{
	/// Contains functions that belong with ETS system, but are not specific to a particular instrument.
	namespace System{


	
	/*************************************************************************************************************************************For*Doxygen**//**
	Simplifies sharing resources among sites.
	*******************************************************************************************************************************************************/
	class CSharedPinGroups
	{
	private:

		/// Class to store the pin and site information
		class CPinSite
		{
		public:
			PME_INT mpmePin;
			int		miSite;
			CPinSite(){;}
			CPinSite(PME_INT pmePin, int iSite)
			{
				mpmePin = pmePin;
				miSite	= iSite;
			}

		};


		bool mbRunLoopForActiveSitesOnly;

		std::map<int, std::map<int, CPinSite>> mmapSharedPinGroup;
		// This iterator is used to keep track of which group of instrument / site assignments is in effect
		std::map<int, std::map<int, CPinSite>>::iterator mitSharedPinGroup;
	
		std::map<int, CPinSite> mmapAllPins;

	public:
		CSharedPinGroups()
		{
			mbRunLoopForActiveSitesOnly = true;
		}
		///Assigns an instrument to a specific site for the specified "shared instrument group"
		void Share(int iGroup, PME_INT pmePin, int iSite);

		// Will pause all sites that are not used on this iteration of site groups and allocate SPU to the appropriate sites.
		//		If all site groups have been run, it will unpause all sites.
		//		@note	This is an internal function that most likely will never need to be called directly by a user.
		void SiteGroupAllocation();

		/// Position mitSharedPinGroup to the first group of sites/instruments that will be used and pause resources appropriately
		void Start() 
		{
			mitSharedPinGroup = mmapSharedPinGroup.begin();
			SiteGroupAllocation();
		}

		/// Increment mitSharedPinGroup and allocate appropriate resources
		void Next() 
		{
			mitSharedPinGroup++;

			SiteGroupAllocation();
		}

		/// Determine if the end of the shared instrument group has been reached
		bool Finished()
		{
			return (mitSharedPinGroup == mmapSharedPinGroup.end()) ;
		}

		/// Returns the shared instrument group number that it is currently active
		int GetSharedInstrumentGroupNumber()
		{
			return mitSharedPinGroup->first;
		}

		/// Indicates whether the loop should always be run, or only run if there are some active sites.
		/// @param bRunLoopForActiveSitesOnly True if you want to run for only active sites, false otherwise.
		void RunLoopForActiveSitesOnly(bool bRunLoopForActiveSitesOnly)
		{
			mbRunLoopForActiveSitesOnly = bRunLoopForActiveSitesOnly;
		}

	};

/// Connect APU, SPU, or QTMU to any site, for site serial testing
/// @param pmePin	Pin name that is going to be temporarily assigned to a specific site
/// @param iSite	Site that the pin will be assigned to.
int ConnectPinToSite(PME_INT pmePin, int iSite);



/************************************************************************************************************************************************************For*Doxygen**//**
		Serves as a base class for the APU, DPU, and SPU.  
			Contains the parameters that generally show up in a Pin Unit or VI, regardless of manufacturer.  Through the use of virtual functions in this 
			class one can create instrument and possibly even system independent routines.
**************************************************************************************************************************************************************/
	class CPinUnit
	{
	
	public:
	/* Probably the wrong way to handle this
		// Parameters used in various pin unit set/force commands
		SiteDouble	msdForceValue;  ///< Value that the instrument will be forced to
		int			miForceMode;	///< Forcing mode, for example force current or force voltage
		int			miVRange;		///< Voltage range that instrument will be set to
		int			miIRange;		///< Current range that instrument will be set to

		// Parameters used in various pin unit measure commands
		int			miMeasureMode;	///< Measurement mode that instrument will be put in, for example measure voltage or measure current
		int			miIMeasureGain; ///< Gain applied to current measurements.  @note Higher gain increases accuracy at expense of measurement range
		int			miVMeasureGain;	///< Gain applied to voltage measurements.  @note Higher gain increases accuracy at expense of measurement range
		int			miNumberOfSamples;			///< Number of samples that will be taken
		double		mdDelayBetweenSamplesUS;	///< Delay time between samples.
		PinListData mpldMeasuredValue;			///< Value measured by the instrument
*/
		// Additional parameters
		int miErrorFlag;	///< The last error flag that was returned by a function in this class

		// Additional functions
		virtual int GetInstrumentInformation();
		virtual PinListData GetForceValue(bool bGetInstrumentInformation = TRUE);///< Value that the instrument was forced to when GetInstrumentInformation() was last run
		virtual	int	GetForceMode(bool bGetInstrumentInformation = TRUE);		///< Forcing mode when GetInstrumentInformation() was last run
		virtual int	GetVRange(bool bGetInstrumentInformation = TRUE);			///< Voltage range of instrument when GetInstrumentInformation() was last run
		virtual	int	GetIRange(bool bGetInstrumentInformation = TRUE);			///< Current range of instrument when GetInstrumentInformation() was last run
		virtual	int GetMeasureMode(bool bGetInstrumentInformation = TRUE);		///< Measurement mode of instrument when GetInstrumentInformation() was last run
		virtual PinListData GetMeasuredValue(bool bGetInstrumentInformation = TRUE);			///< Value measured by the instrument when GetInstrumentInformation() was last run

/* Following parameters are not available via built in status commands, so will not be supported at this time.
		virtual	int	GetIMeasureGain(bool bGetInstrumentInformation = TRUE);		///< Gain applied to current measurements of instrument when GetInstrumentInformation() was last run.  
																				///< @note Higher gain increases accuracy at expense of measurement range
		virtual	int	GetVMeasureGain(bool bGetInstrumentInformation = TRUE);		///< Gain applied to voltage measurements of instrument when GetInstrumentInformation() was last run.  
											///< @note Higher gain increases accuracy at expense of measurement range
		virtual	int	GetNumberOfSamples(bool bGetInstrumentInformation = TRUE);			///< Number of samples that instrument was set to take when GetInstrumentInformation() was last run
		virtual	int	GetDelayBetweenSamplesUS(bool bGetInstrumentInformation = TRUE);	///< Delay time between samples that instrument was set to when GetInstrumentInformation() was last run.
*/

		virtual int ForceV(SiteDouble dForceValue, int iVRange=MAXIM_INVALID, int iIrange=MAXIM_INVALID, bool bGetInstrumentInformation = TRUE);
		virtual int ForceI(SiteDouble dForceValue, int iVRange=MAXIM_INVALID, int iIrange=MAXIM_INVALID, bool bGetInstrumentInformation = TRUE);
		virtual PinListData MeasureV(int iNumberOfSamples=1, double dDelayBetweenSamplesUS=10, int iMeasureGain=MAXIM_INVALID, bool bGetInstrumentInformation=TRUE);
		virtual PinListData MeasureI(int iNumberOfsamples=1, double dDelayBetweenSamplesUS=10, int iMeasureGain=MAXIM_INVALID, bool bGetInstrumentInformation=TRUE);
		virtual bool IsForceVoltageMode(bool bGetInstrumentInformation = TRUE);
		virtual bool IsForceCurrentMode(bool bGetInstrumentInformation = TRUE);
		virtual double GetVRangeAsDouble(bool bGetInstrumentInformation = TRUE);
		virtual double GetIRangeAsDouble(bool bGetInstrumentInformation = TRUE);
		virtual int AutoIRange(double dValue1 = HUGE_VAL, double dValue2 = HUGE_VAL, bool bGetInstrumentInformation = TRUE);
		virtual int AutoVRange(double dValue1 = HUGE_VAL, double dValue2 = HUGE_VAL, bool bGetInstrumentInformation = TRUE);
		virtual int AutoIGain(double dValue1 = HUGE_VAL, double dValue2 = HUGE_VAL, bool bGetInstrumentInformation = TRUE);
		virtual int AutoVGain(double dValue1 = HUGE_VAL, double dValue2 = HUGE_VAL, bool bGetInstrumentInformation = TRUE);
	};

//		double	GetMaxAbsoluteValueFromVSD(vector<SiteDouble> vsdValue);
//		double	GetMaxAbsoluteValueFromSD(SiteDouble sdValue);

		double	GetMaxAbsoluteValueFromVPLD(vector<PinListData> vpldValue);
		double	GetMaxAbsoluteValueFromPLD(PinListData pldValue);





	} // end of System namespace
} // end of Maxim namespace






#endif