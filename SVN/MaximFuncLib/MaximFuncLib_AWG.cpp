//DO NOT EDIT THIS FILE
/*** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-
*                                                                            
*	Source title:		MaximFuncLib_AWG.CPP                                                                            		  
*	URL:				$URL: https://svn.maxim-ic.com/svn/ets/test_programs/AP89/AP89_FT/Trunk/MaximFuncLib/MaximFuncLib_AWG.cpp $
*   Last Modified by:	$LastChangedBy: govit.pimthong $                                       
*	Date:				$Date: 2017-03-09 12:55:55 +0700 (Thu, 09 Mar 2017) $                                                
*   Current Rev:		$Revision: 61735 $
*                                                                            
*	Description:  
*		Maxim Function library file for AWG Functions.  								 
*		Maxim library written and maintained by:								 
*			Patrick Hayes (Patrick.Hayes@MaximIntegrated.com)	                 
*			Mark Bruening (Mark.Bruening@MaximIntegrated.com)		                                                                       
*                                                                            
**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****/
//DO NOT EDIT THIS FILE

/**********************************************************************************************************************************************For*Doxygen**//**
@file	MaximFuncLib_AWG.cpp
@brief	Maxim Function library file for AWG Functions.
**************************************************************************************************************************************************************/


namespace Maxim
{
	namespace AWG
	{
		std::map<std::string, SiteBool> mapLoadedAWGs;

		/************************************************************************************************************************************************************For*Doxygen**//**
		Return a double vector with a linear ramp from dStart to dStop of size iSize

		@param	[dStart]   Start Point
		@param	[dStop]    Stop Point
		@param	[iSize]    Size of Vector
		
		@return	std::vector<double> of size iSize
				if iSize is <1, return vector of size 1 with dStart
		**************************************************************************************************************************************************************/
		std::vector<double> CreateLinearRampVector(double dStart, double dStop, int iSize)
		{
			int iStep=0;
			std::vector<double> vdRamp;
			vdRamp.push_back(dStart);
			if (iSize <=1) return vdRamp;  //check for 0 or negative steps, return vector size of 1 for this case.
			for (iStep=1; iStep<iSize-1; iStep++)
				vdRamp.push_back(dStart+(dStop-dStart)*iStep/(iSize-1));
			vdRamp.push_back(dStop);
			return vdRamp;
		}

		/************************************************************************************************************************************************************For*Doxygen**//**
		To keep track of whether or not a pattern has been loaded to the AWG yet.  This is purely a book keeping function
			and does not load anything to the AWG of an instrument.
		
		@param	[sAwgName]   Name of Pattern, should be unique per test run.
		@param	[iPin]		optional parameter for a pin.  this allows you to load the same pattern name to multiple pins if needed.
		
		@return	[true]		true if all active sites have been loaded previously
				[false]		false if any active sites have not been loaded previously

		@remarks	IsAWGPatternLoaded function is purely a book keeping function
					- It checks to see if you have already ran this function for all active sites
					- You can use this to load AWGs only once per site per pin to save test time
		@code
			if (!Maxim::AWG::IsAWGPatternLoaded("A"))
				{
					Maxim::AWG::apu12awgloader(FB_POK,"A",APU12_FV,APU12_10V,APU12_100MA,Maxim::AWG::CreateLinearRampVector(0.5,1.5,100));
					mcusequence( MCU_CH0, "A", "%d ON", 100 );
				}
		@endcode
		**************************************************************************************************************************************************************/
		bool IsAWGPatternLoaded(std::string  sAwgName, int iPin )
		{
			bool bExists = true; //Assume don't need to load by default
			std::stringstream ssAwgName;
			SiteBool LoadedSites;
			int iSite;
			std::map<std::string, SiteBool >::iterator itr;

			//Create Unique Key
			ssAwgName << sAwgName;
			ssAwgName << iPin;
	
			//Find the map entry with that name
			itr = mapLoadedAWGs.find( ssAwgName.str().c_str() );
	
			if( itr == mapLoadedAWGs.end() )  //Name doesn't exist in map yet
			{ //Add to map
				bExists = false;
				//Load the site bool
				for( iSite = 0; iSite < Maxim::GetNumSites(); iSite++ ){
					if( msSiteStat( iSite ) == FALSE ) LoadedSites[iSite] = false;
					else						 	   LoadedSites[iSite] = true;
				}
				mapLoadedAWGs[ssAwgName.str().c_str()] = LoadedSites;
			}
			else
			{ //Already in map, check to see if active sites are loaded
				LoadedSites = mapLoadedAWGs[ssAwgName.str().c_str()];
				for( iSite = 0; iSite <Maxim::GetNumSites(); iSite++ )
				{
					if( LoadedSites[iSite] == false && msSiteStat( iSite ) == TRUE )  
					{  //Site has not been loaded and is active
						mapLoadedAWGs[ssAwgName.str().c_str()][iSite] = true; // Set site loaded
						bExists = false;					//Set to false to reload AWG
					}
				}
			}
			return bExists;
		}

		//APU12 and SP112 overloads for awgloader with a vector
		int apu12awgloader( int pin, char* name, int mode, int vrange, int irange, std::vector<double> vdPattern, AWGINFO_STR *regions)
		{
			return ::apu12awgloader(pin, name, mode,vrange,irange,&vdPattern[0],(int)vdPattern.size(),regions);
		}
		int sp112awgloader (int pos, char* name, int mode, int vrange, int irange,  std::vector<double> vdPattern, AWGINFO_STR *regions)
		{
			return ::sp112awgloader(pos, name, mode,vrange,irange,&vdPattern[0],(int)vdPattern.size(),regions);
		}
	}
}