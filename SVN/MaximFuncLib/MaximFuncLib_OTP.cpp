//DO NOT EDIT THIS FILE
/**********************************************************************************************************************************************For*Doxygen**//**
*                                                                            
@file		MaximFuncLib_OTP.CPP                                                                            		  
*	URL:				$URL: https://svn.maxim-ic.com/svn/ets/test_programs/AP89/AP89_FT/Trunk/MaximFuncLib/MaximFuncLib_OTP.cpp $
*   Last Modified by:	$LastChangedBy: govit.pimthong $                                       
*	Date:				$Date: 2017-03-09 12:55:55 +0700 (Thu, 09 Mar 2017) $                                                
*   Current Rev:		$Revision: 61735 $
*                                                                            
*	Description:  
*		Maxim Function library file for OTP trimming functions.  
@brief		Contains generic Trim functions that can be called in test programs to trim parameters while communication with a user defined protocol (I2C, SPI, else).
*		Maxim library written and maintained by:								 
*			Brad Sitton  (Brad.Sitton@maximintegrated.com)
*		in collaboration with:
*			Daniele Ghezzi (Daniele.Ghezzi@maximintegrated.com)	                 
*			Robinson Dagaraga (Robinson.Dagaraga@maximintegrated.com)                                                                            
*
*   Revision History
*		See MaximFuncLib_OtpTrim.h file.
*                                                                            
**************************************************************************************************************************************************************/
//DO NOT EDIT THIS FILE


//#ifdef ALPHA_OTP  //Moving to release

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers



// disable warnings about long names
#ifdef WIN32
  #pragma warning( disable : 4786)
#endif


namespace Maxim
{

	namespace OTP
	{

/// Stores trim information that is shared by all trims of all devices
CSharedTrimInformation	sharedTrimInformation;
CCharacterizationSettings characterizationSettings;
//Disabling, because it may cause more problems than it solves     CDebugInformation Debug;

/************************************************************************************************************************************************************For*Doxygen**//**
		Load a trim structure with information for a specific trim.  Some information is stored in site aware variables 
			such as final trim code.

@param	sTrimName		Name for the trim which will be used in debug messages and characterization file.  Should be in _f units, i.e. 1 uA_F.
@param	sdTarget			The target that the device is being trimmed to Should be in _f units, i.e. 0.8 V_f.
@param	dAccuracy		The required accuracy in _f units, i.e. 1 mV_f.  Typically the value would correspond to something between 0.5 
							and 1.0 LSB (largest gap between adjacent trim codes)
@param	dDatalogUnits	The units that will be used for datalogging.  Ideally dTarget and dAccuracy are provided in the same units.
@param	iDeviceAddress	The address of the device being trimmed.  This will be used by the communication routines.
@param	iTrimRegister	The register that needs to be programmed in order to change the trim of the device.
@param	iDSIndex		Datasheet Index.  If provided, then datalogging of the following will automatically be performed: 
							Pretrim Value, Pretrim Code, Best Value, Best Code, Number of Attempts.	

@code	
		//Assumes global variable has been declared elsewhere: Maxim::OTP::CTrimStructure gtsBatRegV;
	   gtsBatRegV = Maxim::OTP::CTrimStructure("BatRegV", 4.2 V_f, 0.005 V_f, V, 0x31, 0x10, 0); 
@endcode

**************************************************************************************************************************************************************/

void CTrimStructure::LoadTrimInformation( std::string sTrimName, SiteDouble sdTarget, double dAccuracy, double dDatalogUnits, int iDeviceAddress, int iTrimRegister, int& iDSIndex){
	LoadTrimInformation( sTrimName, sdTarget, dAccuracy, dDatalogUnits, iDeviceAddress, iTrimRegister); //Call subset version of this function
	mptriDSIndex = &iDSIndex;
}

// See definition for superset function above
void CTrimStructure::LoadTrimInformation( std::string sTrimName, SiteDouble sdTarget, double dAccuracy, double dDatalogUnits, int iDeviceAddress, int iTrimRegister)
{

	msTrimName		= sTrimName;
	LoadTrimTarget( sdTarget);
	mdAccuracy		= dAccuracy;
	mdDatalogUnits	= dDatalogUnits;
	miDeviceAddress	= iDeviceAddress;
	miTrimRegister	= iTrimRegister;
	miFirstTrimCodeOriginal = 0;

	mbPrioritizeAccuracyOverSpeed = false; //default

	
	miCodeStep = 1;			// Set default trim code step = 1

	// Add or update this trim in the sharedTrimInformation
	sharedTrimInformation.mapTrims[msTrimName] = this;

	// Add or update this trim in the Debug object, which helps make debug information easier to find
//	Debug.mmapInformation[msTrimName].mdAccuracy	= dAccuracy;

	miFirstTrimCodeMaximumVariation = 3200; // Big number so there should be no limitation on trim code variation

	//Check sharedTrimInformation and add any steps that are valid for all trims.
	for( std::set<std::string>::iterator it=sharedTrimInformation.msetsValidTrimSteps.begin(); it != sharedTrimInformation.msetsValidTrimSteps.end(); it++)
		AddValidTrimStep(*it);	

}

	/// Allows you to change trim target without passing any additional information
	/// @param sdTarget	Can accept double or SiteDouble, meaning you can have a device specific target if necessary
	void CTrimStructure::LoadTrimTarget(SiteDouble sdTarget)
	{ 
		msdTarget = sdTarget; 	
//		Debug.mmapInformation[msTrimName].msdTarget	= sdTarget; 
	}

/************************************************************************************************************************************************************For*Doxygen**//**
	Load an array into the trim table. 

@param	iSizeOfTable		Size of the trim table.
@param	dTrimTable[]		An array containing the trim table values.
@param	iTrimCodeArray[]	Optional array that can be omitted if the trim codes that correspond to your trim table start at 0 and increment by 1, 
								i.e. 0, 1, 2, 3...  This allows you to redefine trim codes as -8, -2, 0, 2, or any other way you would like.
@code
// Store trim table for the trim in an array
   double    dBatRegVTrimTable[] = {0, 0.00718589, 0.0124858, 0.017746421, 0.022765875, 0.02756412, 0.032165118, 0.036675819, 0.040325896};,

   // Load the array into your trim object
   gtsBatRegV.LoadTrimTable(8, dBatRegVTrimTable);

@endcode
**************************************************************************************************************************************************************/

void CTrimStructure::LoadTrimTable(int iSizeOfTable, double dTrimTable[], int iTrimCodeArray[])
		//Allows user to provide a seperate array with trim codes that are associated with each trim table value.  This is useful if trim codes are not sequential.
	{ 
		std::map<int, double> mapTrimTable;

		if(iTrimCodeArray == NULL) for(int i=0; i<iSizeOfTable; i++) mapTrimTable[i]=dTrimTable[i];
		else for(int i=0; i<iSizeOfTable; i++) mapTrimTable[iTrimCodeArray[i]]=dTrimTable[i];

		LoadTrimTable(mapTrimTable);
//		mmapTrimTable.clear(); 
//		if(iTrimCodeArray == NULL) for(int i=0; i<iSizeOfTable; i++) mmapTrimTable[i]=dTrimTable[i];
//		else for(int i=0; i<iSizeOfTable; i++) mmapTrimTable[iTrimCodeArray[i]]=dTrimTable[i];
		
	}

/************************************************************************************************************************************************************For*Doxygen**//**
	Load a map into the trim table. 

@param	mapTrimTable		A map containing the trim table.  first is the trim code, second is the associated trim value.

**************************************************************************************************************************************************************/

void CTrimStructure::LoadTrimTable(std::map<int, double> mapTrimTable) {
	mmapTrimTable = mapTrimTable;

	// Update Debug information with Trim Weights
	for (std::map<int, double>::iterator it=mapTrimTable.begin(); it!= mapTrimTable.end(); it++)
	{
//		Debug.mmapInformation[msTrimName].mmapCodeVsTrimWeights[it->first].mdTrimTableWeight = it->second;
	}

	if( !mmapTrimTable.count(miFirstTrimCodeOriginal) ) this->miFirstTrimCodeOriginal = mapTrimTable.begin()->first;
}

/************************************************************************************************************************************************************For*Doxygen**//**
	Returns the pretrim value. 

@return	Pretrim value.

**************************************************************************************************************************************************************/
PinListData CTrimData::PreTrimMeasurement()
{
	if (mvResults.size())	return mvResults.front().mpldMeasurement;
	else return HUGE_VAL;
}
/************************************************************************************************************************************************************For*Doxygen**//**
	Returns the post trim value. 

@return	Post trim value.

**************************************************************************************************************************************************************/
PinListData CTrimData::PostTrimMeasurement()
{
	return mBestTrim.msdMeasurement;
}

/************************************************************************************************************************************************************For*Doxygen**//**
	Returns the pretrim value. 

@return	Pretrim value.  Note that the default value is 999999999, which implies the FindBestTrimCode() method has not been run.

**************************************************************************************************************************************************************/
SiteInt CTrimData::PreTrimCode()
{
	SiteInt siReturnCode;
	
	if (mvResults.size())	return mvResults.front().msiCode;
	else return MAXIM_INVALID;

}
/************************************************************************************************************************************************************For*Doxygen**//**
	Returns the post trim value. 

@return	Post trim value.  Note that the default value is 999999999, which implies the FindBestTrimCode() method has not been run.

@code
	DUT::Trim::gtsIbias.PostTrimCode();   // Use this function for performing the measurement in other places in code, like the post power down / power up verification.
@endcode


**************************************************************************************************************************************************************/
SiteInt CTrimData::PostTrimCode()
{
	return mBestTrim.msiCode;
}
/************************************************************************************************************************************************************For*Doxygen**//**
	Allows the starting trim code to be automatically optimized.  User sets a maximum variation from the iFirstAttemptCode they setup when defining
		the trim.  Then the code will adjust the starting code based on site specific statistics.  The advantage is that you reduce the 
		number of iterations required to get to the final/best trim code.

@param	iMaximumVariation		The maximum variation from the iFirstAttempt code that will be allowed.  By default this will allow any starting trim code.
									However you could for example set variation at 3 if you wanted first code to be at most 3 away from the iFirstAttemptCode
									code you originally defined when setting up the trim. 

**************************************************************************************************************************************************************/
void CTrimStructure::OptimizeStartingTrimCode(int iMaximumVariation){ miFirstTrimCodeMaximumVariation = iMaximumVariation; }

/************************************************************************************************************************************************************For*Doxygen**//**
Adds an operation (step) that all trims will be performed at.

@param	sTrimStep		The name of a trim step where trimming should occur. For example FT25C.  These step names must line up with the trim steps used in limit sheets.

@remark By default no trim steps have been specified, which will cause the library to allow trimming at all steps except QA.  This was done for the case where 
the user would like to control trimming using their own external logic.

**************************************************************************************************************************************************************/
void CSharedTrimInformation::AddTrimStepForAllTrims(std::string sTrimStep)
{ 
	// Save the trim step as being valid for all trims.  Typically this would be a single entry.
	msetsValidTrimSteps.insert(sTrimStep);

	//Cycle through all existing trims to store sTrimStep as a valid trim step
	std::map<std::string, CTrimStructure*>::iterator it;
	for(it=mapTrims.begin(); it!=mapTrims.end(); it++)
	{
		it->second->AddValidTrimStep(sTrimStep);
	}

}

/************************************************************************************************************************************************************For*Doxygen**//**
	Let you know if the given site is OK to trim.  True means the lock bit is not set and that the site is active.

@param	iSite	The site you want to check.  If you pass in MS_ALL then it will check to see if any site is OK to trim.

@return	bool	True if its OK to trim.

**************************************************************************************************************************************************************/
bool CSharedTrimInformation::IsOKToTrim(int iSite){
	bool bOKToTrim;
	
	// iSite == MS_ALL means we are just checking to see if any site is available to be trimmed.  Otherwise only a single site it checked.
	bOKToTrim = (iSite==MS_ALL) ? (0!=msbLockBit.Any(TRUE)) : (0!=sharedTrimInformation.msbLockBit[iSite]);

	// Don't perform trimming if the site is no longer active
	bOKToTrim &= !msSiteStat(iSite);

	return bOKToTrim;
}

/************************************************************************************************************************************************************For*Doxygen**//**
		Initializes device specific data so that information from the previous device does not carry into the current device.
			Function will cycle through all objects of type CTrimStructure.

**************************************************************************************************************************************************************/
void CSharedTrimInformation::NewDevice()
{
	std::map<std::string, CTrimStructure*>::iterator it;

	miNewDeviceResetCount++;

	for(it=mapTrims.begin(); it!=mapTrims.end(); it++)	it->second->InitializeDeviceResults();

	// Make sure debug information is also cleaned up
//	Debug.NewDevice();
}

/************************************************************************************************************************************************************For*Doxygen**//**
	Initializes device specific data for a single instance of a Trim.  Most notably this function is used by CSharedTrimInformation::NewDevice() and 
		is called at the beginning of CTrimStructure::FindBestTrimCode()

**************************************************************************************************************************************************************/
void CTrimStructure::InitializeDeviceResults()
{
	mBestTrim = CTrimResultSD(); //Initialize mBestTrim with obviously invalid values so that it is clear that the current device has not been measured yet.
	msiNumberOfAttempts = 0;
	mvResults.clear();

}

/************************************************************************************************************************************************************For*Doxygen**//**
		Stores list of valid trim steps.  Note that an empty list implies trimming can be done at any step,  

**************************************************************************************************************************************************************/
void CTrimStructure::AddValidTrimStep(std:: string sTrimStep) 
{ 
	msValidTrimSteps.insert(sTrimStep);
}  


/************************************************************************************************************************************************************For*Doxygen**//**
@brief  Will perform the trim using a lookup table. Subset version.  Use this version if the @b same test mode/setup is used for both writing the register 
		and measuring the device. 

@param	SetTrimRegisterFunction				Function that writes to the trim register.  In many cases this may just be the I2C or similar communication routine.
												A custom routine can be defined if your device has a complicated storage scheme, i.e. trims are sharing registers
@param	MeasureFunction		Function that is used to make a measurement.

@param	DomainFunction		Translates measurement into the same domain as the trim table.  For example, trim table may be in % of pretrim, 
								or measurement in kHz with table in period, etc.  By default the two are in the same domain so no translation needed.

**************************************************************************************************************************************************************/
void CTrimStructure::LoadTrimFunctions(	SiteInt		(*SetTrimRegisterFunction)(int iDeviceAddress, int iRegister, SiteInt siRegisterSetting),
										PinListData (*MeasureFunction)(CTrimStructure *), 
										PinListData	(*DomainFunction)(PinListData, CTrimStructure*))
{
	LoadTrimFunctions(NULL, SetTrimRegisterFunction, MeasureFunction, DomainFunction);
}

/************************************************************************************************************************************************************For*Doxygen**//**
@brief	Will perform the trim using a lookup table. Use this version if writing the register requires a @b different test mode/setup
		than what is used for measuring the device. 

@param	EnterRegisterWriteModeFunction		Function that is used to reenter register write mode after performing a measurement.

@param	SetTrimRegisterFunction				Function that writes to the trim register.  In many cases this may just be the I2C or similar communication routine.
												A custom routine can be defined if your device has a complicated storage scheme, i.e. trims are sharing registers
@param	MeasureFunction		Function that is used to make a measurement.

@param	DomainFunction		Translates measurement into the same domain as the trim table.  For example, trim table may be in % of pretrim, 
								or measurement in kHz with table in period, etc.  By default the two are in the same domain so no translation needed.
**************************************************************************************************************************************************************/
void CTrimStructure::LoadTrimFunctions(	void		(*EnterRegisterWriteModeFunction)(),
										SiteInt		(*SetTrimRegisterFunction)(int iDeviceAddress, int iRegister, SiteInt siRegisterSetting),
										PinListData (*MeasureFunction)(CTrimStructure *), 
										PinListData	(*DomainFunction)(PinListData, CTrimStructure*))
{
	mEnterRegisterWriteMode =	EnterRegisterWriteModeFunction;
	mSetTrimRegister		=	SetTrimRegisterFunction;
	mMeasure				=	MeasureFunction;
	mDomainTransform		=	DomainFunction;
}


void CTrimStructure::LoadDatalogFunctions( void (*PreTrimDatalogFunction)(CTrimStructure *), void (*PostTrimDatalogFunction)(CTrimStructure *))
{
	mPreTrimDatalogFunction		= PreTrimDatalogFunction;
	mPostTrimDatalogFunction	= PostTrimDatalogFunction;
}



/***************************************************************************************************************************************For*Doxygen**//**
Will find the best trim code using settings that you have loaded into the trim structure. See example below

By default this function will datalog the following values in this order:
- Pre Trim Measurement
- Pre Trim Code                                                   
	-	Many times this is a fixed code, so not necessary, but if we adjusted first guess based on most common trim code, then we need this
- Post Trim Measurement
- Post Trim Code
- Number of Attempts
	-	Pre-trim counts as the first attempt.  
	-	Post trim counts as a second attempt.  
	-   So if you did a single pretrim measurement and a single post trim measurement, the "Number of Attempts" will be 2.  
		- Counting was done this way, because if you were on target with your pretrim measurement then you should not make any additional attempts.  
			In this scenario it does not make sense to say we trimmed in 0 attempts, which means pretrim should be counted as the first attempt.
	-	Number of additional attempts are counted also.  
	-	Note that only the final post trim attempt is datalogged.
		- Measurements for every attempt are available via the mvResults vector in the trim object.

Maxim::OTP::CTrimData::EnableDatalogging() is used to turn OTP datalogging on or off.  Datalogging is turned on by default.

@code
	// Put your device in the correct DC state to start searching for the best trim code.
	DUT::Trim::gtsIBias.FindBestTrimCode();  // This line will use trim table and other information that you have set up to find the best trim code.
	DUT::Trim::gtsIBias.mvResults;			// This vector gives you a list of all measure results for this trim.  Most likely this would be useful during debug
@endcode
**************************************************************************************************************************************************************/
void CTrimStructure::FindBestTrimCode()
{
	SiteInt		siPreviousTrimCode;
	SiteInt		siTrimCode;
	SiteInt		siNextTrimCode;
	PinListData	pldResult;
	SiteBool	sbKeepSearchingForTrimCode;

	// If no space for trim results exist, create an entry
	if(!mvResults.size()) mvResults.push_back(CTrimResult());

	mitCurrentResult = mvResults.begin();

	siNextTrimCode = GetStartingTrimCode();

	//Check to see if this is a valid step/operation to trim at
	//	If no trims steps are listed, then all trim steps are considered valid
	//	If the current loaded test operation is found in the list of msValidTrimSteps, then it is considered valid
	if((0 == msValidTrimSteps.size()) || msValidTrimSteps.count(Maxim::GetTestStep()))
	{
		// Check for QA, which should not perform trimming
		std::string sTestStep = Maxim::GetTestStep();
		if(sTestStep.find("QA")!=std::string::npos) 
		{
			std::stringstream ssMessageToDisplay;
			ssMessageToDisplay << "Maxim::OTP::CTrimStructure::FindBestTrimCode is being run at QA for: " << this->msTrimName;
			ssMessageToDisplay << "\nTrimming should never be done at QA";
			Maxim::System::Message.Deliver(ssMessageToDisplay);
		}

		// This is a valid trim step, now set sbTrimSite so that only active sites will be trimmed
		for (int iSite = 0; iSite < Maxim::GetNumSites(); iSite++) sbKeepSearchingForTrimCode[iSite] = msSiteStat(iSite);

	}
	else sbKeepSearchingForTrimCode = FALSE;  // Not a valid trim step, so don't search for an answer CodeReviewBRS: Perhaps we should still get pre-trim.

	// Enter the main loop which will make multiple attempts to find the best trim code for active sites
	for(int iAttempts = 0; (iAttempts < miMaximumAttempts)&&sbKeepSearchingForTrimCode.Any(TRUE); iAttempts++){


		if(iAttempts==0)	siTrimCode = GetStartingTrimCode(); //If first attempt, then use GetStartingTrimCode, otherwise use previously calculated NextCode
		else				siTrimCode = siNextTrimCode; 

		if(iAttempts == 0) EnterRegisterWriteMode( ); // Useful if writing to the device is done in a different test mode from measuring.
														//	Assume the first pass the device was ready to write.
		SetTrimRegister(miDeviceAddress, miTrimRegister, siTrimCode); // Uniform for first attempt, but site aware at other places
	
		// Perform MeasureFunction() and pass results to the Evaluation function which will make decisions about whether this trim code is better than others
		//		and what trim code should be attempted next.
		siNextTrimCode = EvaluateMeasurement(siTrimCode, sbKeepSearchingForTrimCode);

		// Datalog pretrim values
		if ((0 == iAttempts)&&(IsDataloggingEnabled())) PreTrimDatalog();


	} // Exit main loop that makes up to iMaximumAttempts to find the best trim code

	//Luther: Reenter best trim code to device before exit, if the last code attempted was not equal to the mBestTrim.msiCode for all sites
	bool bBestTrimCodeLoaded = TRUE; // Assume true initially and the loop below will set to false if any site has false.
	ForEachActive_iSite // A #define that makes site loops cleaner
	{
		bBestTrimCodeLoaded &= (mBestTrim.msiCode[iSite] == siTrimCode[iSite]);
		if(mBestTrim.msdError[iSite] < 2* mdAccuracy)  // Only update BestTrimCodeCount if mBestTrim is within 2x desired accuracy.  This prevents bad things, like updating on 
														// failing/dead devices.  The 2x is a bit of a judgment call, but there is no absolute right answer.  BRS 3/10/14
			mmapBestTrimCodeCount[mBestTrim.msiCode[iSite]][iSite] = mmapBestTrimCodeCount[mBestTrim.msiCode[iSite]][iSite] + 1; //Update count of how often each trim code is used
	}

	if(!bBestTrimCodeLoaded)  
	{
		EnterRegisterWriteMode( ); // Useful if writing to the device is done in a different test mode from measuring.
		SetTrimRegister(miDeviceAddress, miTrimRegister, PostTrimCode()); // Uniform for first attempt, but site aware at other places
	 }
	//Datalog the results if datalogging has been enabled.
	if(IsDataloggingEnabled()) PostTrimDatalog();


}

bool CTrimData::IsDataloggingEnabled()
{
	return (mptriDSIndex != NULL)&&(mbDataloggingEnabled);
}

/***************************************************************************************************************************************For*Doxygen**//**
@overload

@param iDSIndex	Use this parameter if you want to take advantage of automatic datalogging

@code
	// Put your device in the correct DC state to start searching for the best trim code.
	DUT::Trim::gtsIBias.FindBestTrimCode(iDSIndex);  // This line will use trim table and other information that you have set up to find the best trim code.
	DUT::Trim::gtsIBias.mvResults;			// This vector gives you a list of all measure results for this trim.  Most likely this would be useful during debug
@endcode
**************************************************************************************************************************************************************/
void CTrimStructure::FindBestTrimCode(int& iDSIndex)
{
	mptriDSIndex = &iDSIndex;
	EnableDatalogging(true);
	FindBestTrimCode();
}

/************************************************************************************************************************************************************For*Doxygen**//**

	Perform measurement and evaluate trim results. Return the next code that should be attempted. 
		Note that much of the information is passed through members of the class instead of being parameters to the function call.

@param	siTrimCode		The code that is loaded into the device during this evaluation.

@param	sbKeepSearchingForTrimCode  Keeps track of which sites are viable for looking for trim code.  No need to 
										search if the device is inactive, has found the ideal code, or similar conditions
										are met.

@return	The next trim code that should be attempted.

**************************************************************************************************************************************************************/
SiteInt CTrimStructure::EvaluateMeasurement( SiteInt siTrimCode, SiteBool &sbKeepSearchingForTrimCode)
{

	// Creates new entry in results vector and loads siTrimCode.
	if(mitCurrentResult == mvResults.end())
	{
		mvResults.push_back(CTrimResult());
		mitCurrentResult = mvResults.end()-1;
	}

	// Handles cases where trimming is done in a site loop, therefore trim results from different site groups need
	//   to be merged, based on which attempt they were on when measurement was made.
	mitCurrentResult->mpldMeasurement = mitCurrentResult->mpldMeasurement & Measure();
	ForEachActive_iSite
	{	
		mitCurrentResult->msiCode[iSite] = siTrimCode[iSite];
	}

	// Make the measurement and store the results into mvResults
	if (mvResults.back().mpldMeasurement.iGetNumPins()!=1)// Make sure there is not more than one pin
	{
		std::stringstream ssMessage;
		ssMessage << "CTrimStructure::EvaluateMeasurementUsingTable was passed measurement data for more than one pin.\n";
		ssMessage << "That functionality is not yet supported\n" << this->msTrimName << " was being evaluated";
		Maxim::System::Message.Deliver(ssMessage);
	} 

	//Need to perform calculations in a local variable and later in the routine the data for the active site will be copied over.
	//  This is needed because PLD operators do not filter based on site, they perform operations on all available data ... or something like that BRS3/31/14
	PinListData pldError, pldDomainError;
	pldError		=  mitCurrentResult->mpldMeasurement - msdTarget;

	// Calculate and store the error in terms of datalog units and trim table based units.  DomainFunction() measured value to trim table domain.
	pldDomainError	= DomainTransform(mitCurrentResult->mpldMeasurement, this)- DomainTransform(msdTarget, this); 

	//If this is the first trim attempt, then by default it is the best attempt.
	if(mvResults.size() == 1) {
		ForEachActive_iSite {
			mBestTrim.msdMeasurement[iSite]	= mvResults.back().mpldMeasurement[iSite];
			mBestTrim.msdDomainError[iSite]	= mvResults.back().mpldDomainError[iSite];
			mBestTrim.msdError[iSite]			= mvResults.back().mpldError[iSite];
			mBestTrim.msiCode[iSite]			= mvResults.back().msiCode[iSite];
		}
	}

	// Evaluate the latest results to see if any should be recorded as the best trim.
	ForEachActive_iSite
	{
		//If this trim code has the smallest error so far, then save the trim code and the associated domain error
		//Store Best Trim per site

		if (abs(mBestTrim.msdDomainError[iSite]) > abs(pldDomainError[iSite]))
		{
			// Note that each variable of the class has to be copied one by one since there is no guarantee that all sites 
			//   will achieve the best trim code during the same pass through the measurement loop.  BRS 7/9/13
			mBestTrim.msdMeasurement[iSite]	= mitCurrentResult->mpldMeasurement[iSite];
			mBestTrim.msdDomainError[iSite]	= pldDomainError[iSite];
			mBestTrim.msdError[iSite]			= pldError[iSite];
			mBestTrim.msiCode[iSite]			= mitCurrentResult->msiCode[iSite];

			// Need to copy error values into "Current Results" now that it has been determined this is an active site
			mitCurrentResult->mpldError[iSite]			= pldError[iSite];
			mitCurrentResult->mpldDomainError[iSite]	= pldDomainError[iSite];
		}
	}

	// Determine the next code that should be attempted, given the latest measurement results
	SiteInt siNextTrimCode = mDetermineNextTrimCode(this);

	//Determine if we need to keep searching
	ForEachActive_iSite
	{
		// No need to keep searching since the next trim code to check is the same as the best trim code we have checked so far.
		if(mBestTrim.msiCode[iSite] == siNextTrimCode[iSite]) sbKeepSearchingForTrimCode[iSite] = FALSE;

		// If we are above the required accuracy or have prioritized accuracy over speed (fewer iterations) 
		//		don't change state of sbKeepSearchingFor TrimCode.  Otherwise, set to FALSE so we quit searching on iSite.
		sbKeepSearchingForTrimCode[iSite] &= (abs(mBestTrim.msdError[iSite]) > abs(mdAccuracy)) || mbPrioritizeAccuracyOverSpeed;
	} // Exit the loop which determines the best trim code to try on the next iteration

//	Debug.UpdateWithLatestMeasurement(this); //Update debug information

	// Increment the current result in preparation for the next iteration
	mitCurrentResult ++;

	return siNextTrimCode;
}

/************************************************************************************************************************************************************For*Doxygen**//**

	Return the next trim code that should be attempted. Will calculate how far off from target the current measurement
		is, then using the trim table will determine which code to attempt next.

@param	trimData	Contains the data for the trim being evaluated and will be used to determine the next code.

@return	Trim code that should be attempted next.

**************************************************************************************************************************************************************/
SiteInt DetermineNextTrimCodeUsingTable(CTrimData* trimData)
{
	SiteInt siNextTrimCode;
	ForEachActive_iSite
	{
		trimData->msiNumberOfAttempts[iSite]++;
		//*****************************************************************************************************************
		// Determine what the next trim code should be based on analyzing the measurement with the current trim code, 
		//   value and domain transfer function.
		//*****************************************************************************************************************
			
		// In this step, the deltas between various trim codes are most important.
		// mmapTrimTable is composed of trim codes and corresponding values.
		// We want to find the trim code that corresponds to a value which is higher/lower than the current trim code by dDomainError.
		// The next line of code determines the value, which is dDesiredTrimTableValue.
		double dDesiredTrimTableValue = trimData->mmapTrimTable.find(trimData->mitCurrentResult->msiCode[iSite])->second 
										- trimData->mitCurrentResult->mpldDomainError[iSite]; 
				
		//Find the trim code of the trim table entry which has the value closest to dDesiredTrimTableValue
		//Since there is no guarantee that codes are stored in order, we search through all values for the closest match.
		std::map<int, double>::iterator it=trimData->mmapTrimTable.begin();
		siNextTrimCode[iSite] = it->first;
		double dSmallestError = trimData->mmapTrimTable.find(siNextTrimCode[iSite])->second - dDesiredTrimTableValue;
		it++;
		for( ; it!=trimData->mmapTrimTable.end(); it++)
		{
			double dThisError = trimData->mmapTrimTable.find(it->first)->second - dDesiredTrimTableValue;
			if(abs(dThisError) < abs(dSmallestError))
			{
				siNextTrimCode[iSite] = it->first;
				dSmallestError = dThisError;
			}
		}
	}

	return siNextTrimCode;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Set the first trim code that should be attempted during trim.

@param	iStartingTrimCode	The trim code that should be attempted during pre-trim

@param	iMaximumVariation	The maximum amount that the starting trim code can vary if there is another trim code that is occurring more often for this lot.
								This is only important if the trim is set to optimize for speed over accuracy.

**************************************************************************************************************************************************************/
void	CTrimStructure::SetStartingTrimCode(int iStartingTrimCode, int iMaximumVariation)
{
	miFirstTrimCodeOriginal			= iStartingTrimCode;
	miFirstTrimCodeMaximumVariation = iMaximumVariation;
}

/************************************************************************************************************************************************************For*Doxygen**//**

	Return the first trim code that should be attempted.  This can be thought of as the pre-trim value.  In the past
		people have often used a fixed value provided by design, but this routine has the option to use the most
		common trim code for the given lot as the starting point.

@return	First trim code that should be attempted.

**************************************************************************************************************************************************************/
SiteInt CTrimStructure::GetStartingTrimCode(){
	SiteInt siMaxCount = 0;
	SiteInt siStartingTrimCode = miFirstTrimCodeOriginal;

	//Search all trim codes to find the one with the highest number of hits.
	//	Note that if you don't want any variation, then set miFirstTrimCodeMaximumVariation = 0 with OptimizeStartingTrimCode
	for(std::map<int, SiteInt>::iterator it = mmapBestTrimCodeCount.begin(); it != mmapBestTrimCodeCount.end(); it++)
	{
		//Check to see if trim code is within acceptable range of variation and then loop through all sites
		if(abs(it->first - miFirstTrimCodeOriginal) < miFirstTrimCodeMaximumVariation)
		ForEachActive_iSite
		{
			// If this trim code at this site has the largest count, then change the first trim code.
			//		In theory all sites should have the same starting trim code, but reality is that they may not.
			//		If you are worried about that, you should do error checking in other places.  The goal of this routine
			//      is to get you to the final post trim code as quickly as possible.
			if (it->second[iSite] > siMaxCount[iSite])
			{
				siMaxCount[iSite] = it->second[iSite];
				siStartingTrimCode[iSite] = it->first;
			}
		}
	}
	
	//Ignore the statistics if you have fewer than 10 hits.  This should avoid wild variations when first setting up a lot.
	for (int iSite=0; iSite<Maxim::GetNumSites(); iSite++) if (siMaxCount[iSite] < 10) siStartingTrimCode[iSite] = miFirstTrimCodeOriginal;

	return siStartingTrimCode;
}


/************************************************************************************************************************************************************For*Doxygen**//**

	Measure and report results for all trim codes that a device has.  Results can be printed to the output window and/or sent to a csv file
	that could be opened with Excel, or sent to the ETS Output screen where it could be copied into your program as the bit weights that will be used.
	By default, the csv file is put in a folder called TrimData and will have the name of the trim.

	@param iTrimTableReferenceCode The trim code that will correspond to 0 change in the trim table.  By default this is set to code 0.

**************************************************************************************************************************************************************/
void CTrimStructure::CharacterizeBitWeights(int iTrimTableReferenceCode)
{

	// Trim tables are set up such that values represent change in measurement from the pre-trim value.  Within this class the pretrim
	//	code is called miFirstCodeOriginal and should be the nominal trim code.  User can use SetFirstTrimCode() to change this value before
	//	characterizing if they want to have the 0 point of their characterization different than their first attempt trim code.  
	//	Note that the efficiency of the trim routine is not dependent on which trim code is used here as 0 point in trim table, but the
	//	choice of 0 point may make it easier to compare to design data.

	//Make sure that there is a valid reference code for trim weights to be calculated with respect to.
	if(mmapTrimTable.find(iTrimTableReferenceCode) == mmapTrimTable.end())
	{
		std::stringstream ssMessage;
		ssMessage << "Maxim::OTP::CTrimStructure::CharacterizeBitWeights has \n mCharacterizationSettings.miTrimTableReferenceCode set to ";
		ssMessage << iTrimTableReferenceCode << "\n but this code does not exist in the trim table of " << msTrimName;
		ssMessage << "\nCharacterization will not be performed";
		Maxim::System::Message.Deliver(ssMessage);
		return;
	}


	// Measure device for each trim code that is stored in the trim table.
	PinListData pldTrimReferenceValue;
	std::vector<PinListData> vpldMeasuredValues;
	Maxim::OTP::CTrimStructure tsDummyTrim; //Used to set up a virtual pretrim value which gets used by some domain transformation functions.

	for(std::map<int, double>::iterator it=mmapTrimTable.begin(); it!=mmapTrimTable.end(); it++)
	{
		EnterRegisterWriteMode();										// Useful if writing to the device is done in a different test mode from measuring.
		SetTrimRegister(miDeviceAddress, miTrimRegister, (*it).first);
		vpldMeasuredValues.push_back(Measure());

		//If we are at the reference trim code, then record the measured value.  This typically corresponds to code 0 in the trim table
		if((*it).first == iTrimTableReferenceCode)
		{
			pldTrimReferenceValue = vpldMeasuredValues.back(); 
			tsDummyTrim.mvResults.push_back(CTrimResult());
			tsDummyTrim.mvResults.back().mpldMeasurement = pldTrimReferenceValue;
			tsDummyTrim.mvResults.back().msiCode = iTrimTableReferenceCode;
			tsDummyTrim.mmapTrimTable[iTrimTableReferenceCode] = 0; // By definition the trim table entry at the iTrimTableReferenceCode has a delta of 0.
		}
	}

	// Calculate trim weights for trim table, along with some statistics.
	std::vector<PinListData> vpldTrimWeights;
	std::vector<double> vdMeasuredAverage, vdTrimWeightAverage;
	for(std::vector<PinListData>::iterator it= vpldMeasuredValues.begin(); it != vpldMeasuredValues.end(); it++)
	{
		PinListData pldTrimWeights;

		pldTrimWeights = DomainTransform(*it, &tsDummyTrim) - DomainTransform(pldTrimReferenceValue, &tsDummyTrim);
		vpldTrimWeights.push_back(pldTrimWeights);

		double dMeasuredSum=0.0, dTrimWeightSum=0.0;
		int		iNumberOfActiveSites = 0;
		ForEachActive_iSite
		{
			iNumberOfActiveSites += 1;
			dMeasuredSum	+=  (*it)[iSite];
			dTrimWeightSum	+=  pldTrimWeights[iSite];
		}
		if (iNumberOfActiveSites>0)
		{
			vdTrimWeightAverage.push_back(dTrimWeightSum / iNumberOfActiveSites); 
			vdMeasuredAverage.push_back(dMeasuredSum / iNumberOfActiveSites); 
		}
		else
		{
			vdTrimWeightAverage.push_back(HUGE_VAL); 
			vdMeasuredAverage.push_back(HUGE_VAL); 
		}

	}

	// Output the characterization values ------------------------------------------------------------------------------------
	int iColumnWidth = characterizationSettings.miColumnWidth;
	if(characterizationSettings.mbOutputToFile)
	{
		// If no file name is provided, then create one based on the trim name.
		if (msCharacterizationFileName.size() == 0)
		{
			msCharacterizationFileName = "TrimData\\OTPWeightChar_" + this->msTrimName + ".csv";
			CreateDirectory("TrimData", NULL);
		}

	
		// Open file or exit function if there are problems.
		std::ofstream outputFile;
		outputFile.open(msCharacterizationFileName, std::ofstream::app);
		if (outputFile.bad())
		{
			std::stringstream ssMessage;
			ssMessage << "Maxim::OTP::CTrimStructure::CharacterizeBitWeights could not open file: " << msCharacterizationFileName;
			Maxim::System::Message.Deliver(ssMessage);
			return ;
		}

		outputFile.seekp(0, std::ios::end);

		//If output file is empty, then insert headers.  Make compliant with TMT NT spreadsheet format so
		//   GBD can read the file.  Want to remain text based so that it can be read from any text editor also
		if(!outputFile.tellp())
		{
			outputFile << "Spreadsheet Format";
			outputFile << "\nTest Program: " ;
			outputFile << "\nLot ID: " << this->msTrimName << " Characterization Data";
			outputFile << "\nOperator: ";
			outputFile << "\nComputer: ";
			outputFile << "\nDate: ";
			outputFile << "\n";

			//Print "Test Numbers"
			outputFile << std::setw(iColumnWidth) << "," << std::setw(iColumnWidth) << ",";
			for(int i=0; i< (int) (2*mmapTrimTable.size()); i++) outputFile << "1.01." << i << ",";
			outputFile << "\n";
			// Print column headers for each of the trim weights
			outputFile << std::setw(iColumnWidth) << "," << std::setw(iColumnWidth) << ",";
			for(std::map<int, double>::iterator it = mmapTrimTable.begin(); it != mmapTrimTable.end(); it++)
				outputFile << std::setw(iColumnWidth) << "Weight Code " << it->first << ",";
			// Print column headers for each of the measurements
			for(std::map<int, double>::iterator it = mmapTrimTable.begin(); it != mmapTrimTable.end(); it++)
				outputFile << std::setw(iColumnWidth) << "Measure Code " << it->first << ",";
			outputFile << "\n \n"; // Two end lines
			// Put in fillers for where limits would normally be in a TMT file
			outputFile << std::setw(iColumnWidth) << "," << std::setw(iColumnWidth) << ",";
			for(int j=0; j<2; j++)
			{
				for(int i=0; i < (int) mmapTrimTable.size(); i++) outputFile << std::setw(iColumnWidth) << "none,";
			}
			outputFile << "\n";
			outputFile << std::setw(iColumnWidth) << "Serial#, ";
			outputFile << std::setw(iColumnWidth) << "Site#, ";
			for(int i=0; i < (int) (2*mmapTrimTable.size()); i++) outputFile << std::setw(iColumnWidth) << "DatalogUnits,";
			outputFile << "\n";
		}

		ForEachActive_iSite 
		{
		// Output to file, if enabled
			// Output serial number
			char cBuffer[32];
			msGetSerialNumberString(iSite, cBuffer, 32);
			outputFile << std::setw(iColumnWidth-1) << cBuffer << ","; 
				// Function definition does not match ETS help files BRS 7/21/13
			// Output the test site that the row of data was obtained from
			outputFile << std::setw(iColumnWidth-1) << iSite << ",";
			// Output the trim weights
			for(std::vector<PinListData>::iterator it=vpldTrimWeights.begin(); it != vpldTrimWeights.end(); it++)
			{
				outputFile << std::setw(iColumnWidth-1) << (*it)[iSite] << ",";
			}
			// Output the measured values
			for(std::vector<PinListData>::iterator it=vpldMeasuredValues.begin(); it != vpldMeasuredValues.end(); it++)
			{
				outputFile << std::setw(iColumnWidth-1) << (*it)[iSite] << ",";
			}
			outputFile.seekp(-1, std::ios::end); //Reset file pointer that we can over-write the last comma
			outputFile << std::endl; // end row with a newline
		}

		outputFile.close();
	}
	
	// Output to screen, if enabled
	if(characterizationSettings.mbOutputToScreen)
	{
		std::stringstream ssScreenOutput;
		// Output the test site that the row of data was obtained from
		ssScreenOutput << "\n" << this->msTrimName << " average trim weights using all active sites\n You can cut and paste into your program.";
		// Output the trim weights
		int iCount=0;
		for(std::vector<double>::iterator it=vdTrimWeightAverage.begin(); it != vdTrimWeightAverage.end(); it++)
		{
			if(!(iCount%characterizationSettings.miScreenMaxColumnsPerRow))
			{
				ssScreenOutput << std::endl;
				etsprintf(ssScreenOutput.str().c_str());
				ssScreenOutput.str("");
			}
			ssScreenOutput << std::setw(iColumnWidth-1) << (*it) << ",";
			iCount++;
		}
		ssScreenOutput << std::endl;
		etsprintf(ssScreenOutput.str().c_str());
		ssScreenOutput.str("");

		// Output the measured values
		iCount=0;
		ssScreenOutput << this->msTrimName << " average measured value using all active sites\n";
		for(std::vector<double>::iterator it=vdMeasuredAverage.begin(); it != vdMeasuredAverage.end(); it++)
		{
			if(!(iCount%characterizationSettings.miScreenMaxColumnsPerRow))
			{
				ssScreenOutput << std::endl;
				etsprintf(ssScreenOutput.str().c_str());
				ssScreenOutput.str("");
			}
			ssScreenOutput << std::setw(iColumnWidth-1) << (*it) << ",";
			iCount++;
		}
		ssScreenOutput << std::endl; // end row with a newline
		etsprintf(ssScreenOutput.str().c_str());
		ssScreenOutput.str("");

	}

	EnterRegisterWriteMode( ); // Useful if writing to the device is done in a different test mode from measuring.
	//Set to best trim code if it exists.
	if(this->mvResults.size() > 0) // If number of attempts are greater than 0, then the FindBestTrimCode function must have been run.
			SetTrimRegister(miDeviceAddress, miTrimRegister, PostTrimCode()); 
	else 	SetTrimRegister(miDeviceAddress, miTrimRegister, this->miFirstTrimCodeOriginal); 

}


/************************************************************************************************************************************************************For*Doxygen**//**

	Default domain transfer function that gets used if the user passes in a NULL pointer.  This function simply returns the pldValue it was passed.

@param	pldValue	Value passed into the function.  Typically this would be a measurement made while searching for the best trim code.
@param	tsTrim		Pointer to the trim that is being worked on.  Since the function pointer is passed we must have a consistent set of input parameters
						even if they are not used as in this case.
@return	Returns pldValue with no transformation.

**************************************************************************************************************************************************************/
PinListData	DomainTransformDefault(PinListData pldValue, CTrimStructure* tsTrim) 
{return pldValue;}

/************************************************************************************************************************************************************For*Doxygen**//**

	Reciprocal domain transfer function.

@param	pldValue	Value passed into the function.  Typically this would be a measurement made while searching for the best trim code.
@param	tsTrim		Pointer to the trim that is being worked on.  Since the function pointer is passed we must have a consistent set of input parameters
						even if they are not used as in this case.
@return	Returns 1/pldValue.

**************************************************************************************************************************************************************/
PinListData	DomainTransformReciprocal(PinListData pldValue, CTrimStructure* tsTrim)
{ 
	return(1.0/pldValue);
} 


/************************************************************************************************************************************************************For*Doxygen**//**
Looks up the trim table value corresponding to a given code.

@param siTrimCode The trim code to be looked up

@return A site double containing the trim table value corresponding to the provided trim code
**************************************************************************************************************************************************************/
SiteDouble	CTrimData::GetTrimTableValue(SiteInt siTrimCode)
{
	SiteDouble sdTrimTableValue;
	ForEachActive_iSite
	{
		sdTrimTableValue[iSite] = mmapTrimTable.find(siTrimCode[iSite])->second;
	}
	return sdTrimTableValue;
}

/************************************************************************************************************************************************************For*Doxygen**//**

	Domain transfer function that calculates offset in percentage from pretrim.

	@note Working with a trim table based on a pre-trim code implies that pre-trim is always done with the pre-trim code that corresponds to 0 change,
	        which is frequently code 0, but does not have to be.  This routine is able to handle cases where this is not true, with no extra
			effort required for the user.
			In cases where the first attempted code is not the one that gives 0 change according to the trim table, then this function will 
			estimate what would have been measured for the code corresponding to 0 change in the trim table and use that as the pre-trim value.
			

@param	pldValue	Value passed into the function.  Typically this would be a measurement made while searching for the best trim code.
@param	tsTrim		Pointer to the trim that is being worked on.  In this case tsTrim is used to obtain the pretrim value.
@return	100*(pldValue - preTrim)/preTrim.  The 100* turns it into a percentage.

**************************************************************************************************************************************************************/
PinListData	DomainTransformOffsetPercentOfPretrim(PinListData pldValue, CTrimStructure* tsTrim) 
{	
	PinListData pldEffectivePreTrimValue = tsTrim->PreTrimMeasurement();
	pldEffectivePreTrimValue = pldEffectivePreTrimValue/(1+tsTrim->GetTrimTableValue(tsTrim->PreTrimCode())/100.0) ;
	PinListData pldResult;
	ForEachActive_iSite
	{
		if (pldEffectivePreTrimValue[iSite] == 0.0)
			pldResult[iSite] = HUGE_VAL;
		else
			pldResult[iSite] = (100*(pldValue[iSite] - pldEffectivePreTrimValue[iSite])/pldEffectivePreTrimValue[iSite]);
	}
	return pldResult;
} 

/************************************************************************************************************************************************************For*Doxygen**//**

	Domain transfer function that calculates offset as ratio from pretrim.

	@note Working with a trim table based on a pre-trim code implies that pre-trim is always done with the pre-trim code that corresponds to 0 change,
	        which is frequently code 0, but does not have to be.  This routine is able to handle cases where this is not true, with no extra
			effort required for the user.
			In cases where the first attempted code is not the one that gives 0 change according to the trim table, then this function will 
			estimate what would have been measured for the code corresponding to 0 change in the trim table and use that as the pre-trim value.
			

@param	pldValue	Value passed into the function.  Typically this would be a measurement made while searching for the best trim code.
@param	tsTrim		Pointer to the trim that is being worked on.  In this case tsTrim is used to obtain the pretrim value.
@return	Returns The ratio (pldValue - preTrim)/preTrim.

**************************************************************************************************************************************************************/
PinListData	DomainTransformOffsetRatioOfPretrim(PinListData pldValue, CTrimStructure* tsTrim) 
{	
	PinListData pldEffectivePreTrimValue = tsTrim->PreTrimMeasurement()/(1+tsTrim->GetTrimTableValue(tsTrim->PreTrimCode())) ;

	PinListData pldResult;
	ForEachActive_iSite
	{
		if (pldEffectivePreTrimValue[iSite] == 0.0)
			pldResult[iSite] = HUGE_VAL;
		else
			pldResult[iSite] = (pldValue[iSite] - pldEffectivePreTrimValue[iSite])/pldEffectivePreTrimValue[iSite];
	}
	return pldResult;
} 

/************************************************************************************************************************************************************For*Doxygen**//**

	Domain transfer function that calculates offset in percentage from target.

@param	pldValue	Value passed into the function.  Typically this would be a measurement made while searching for the best trim code.
@param	tsTrim		Pointer to the trim that is being worked on.  In this case tsTrim is used to obtain the target value.
@return	Returns 100*(pldValue - preTrim)/preTrim.  The 100* turns it into a percentage.

**************************************************************************************************************************************************************/
PinListData	DomainTransformOffsetPercentOfTarget(PinListData pldValue, CTrimStructure* tsTrim) 
{	
	PinListData pldTarget = tsTrim->GetTargetValue();
	return(100*(pldValue - pldTarget)/pldTarget);
} 

/************************************************************************************************************************************************************For*Doxygen**//**

	Domain transfer function that calculates ratio of change from pretrim.

@param	pldValue	Value passed into the function.  Typically this would be a measurement made while searching for the best trim code.
@param	tsTrim		Pointer to the trim that is being worked on.  In this case tsTrim is used to obtain the target value.
@return	Returns  the ratio (pldValue - preTrim)/preTrim.

**************************************************************************************************************************************************************/
PinListData	DomainTransformOffsetRatioOfTarget(PinListData pldValue, CTrimStructure* tsTrim) 
{	
	PinListData pldTarget = tsTrim->GetTargetValue();
	return((pldValue - pldTarget)/pldTarget);
} 

/************************************************************************************************************************************************************For*Doxygen**//**

	Default function for datalogging pretrim measurements.

@param	tsTrim		Pointer to the trim that is being worked on.  In this case tsTrim is used to obtain the target value.

**************************************************************************************************************************************************************/
void	PreTrimDatalogDefault(CTrimStructure* tsTrim) 
{	
		//Datalog PreTrim Measured Value
		Maxim::DatalogAll((*tsTrim->mptriDSIndex), tsTrim->PreTrimMeasurement() * tsTrim->mdDatalogUnits);
		//Datalog PreTrim Code 
		Maxim::DatalogAll(*(tsTrim->mptriDSIndex), tsTrim->PreTrimCode());
} 

/************************************************************************************************************************************************************For*Doxygen**//**

	Default function for datalogging post trim measurements.

@param	tsTrim		Pointer to the trim that is being worked on.  In this case tsTrim is used to obtain the target value.

**************************************************************************************************************************************************************/
void	PostTrimDatalogDefault(CTrimStructure* tsTrim) 
{	
		//CodeReviewBRS 7/12/13  Comments below were part of a brain storming session and can be deleted once DatalogAll is confirmed to work properly.
		//Option 1: may cause problems with power down
		//Turn off sites that are not OK to trim by using msSetSiteStopped
		//DatalogAll SiteInt SiteDouble PinListData
		//Flush Datalog
		//Restart sites with msSetSiteStopped
		//Option 2: Set values in Not OK to Trim sites that are active to a "default" type of number (pre = best = post)

		//Datalog Best Trim Measured Value
		Maxim::DatalogAll(*(tsTrim->mptriDSIndex), tsTrim->PostTrimMeasurement() * tsTrim->mdDatalogUnits);
		//Datalog BestTrim Code
		Maxim::DatalogAll(*(tsTrim->mptriDSIndex), tsTrim->PostTrimCode());
		//Datalog the number of attempts it took to get to the best code for this site
		Maxim::DatalogAll(*(tsTrim->mptriDSIndex), tsTrim->NumberOfAttempts());	
} 




/************************************************************************************************************************************************************For*Doxygen**//**
		Load a trim structure with information for a specific trim.  Some information is stored in site aware variables 
			such as final trim code.

@param	sTrimName		Name for the trim which will be used in debug messages and characterization file.  Should be in _f units, i.e. 1 uA_F.
@param	sdTarget			The target that the device is being trimmed to Should be in _f units, i.e. 0.8 V_f.
@param	dAccuracy		The required accuracy in _f units, i.e. 1 mV_f.  Typically the value would correspond to something between 0.5 
							and 1.0 LSB (largest gap between adjacent trim codes)
@param	dDatalogUnits	The units that will be used for datalogging.  Ideally dTarget and dAccuracy are provided in the same units.
@param	iDeviceAddress	The address of the device being trimmed.  This will be used by the communication routines.
@param	iTrimRegister	The register that needs to be programmed in order to change the trim of the device.
@param	iDSIndex		Datasheet Index.  If provided, then datalogging of the following will automatically be performed: 
							Pretrim Value, Pretrim Code, Best Value, Best Code, Number of Attempts.	

@code	
		//Assumes global variable has been declared elsewhere: Maxim::OTP::CTrimStructure gtsBatRegV;
	   gtsBatRegV = Maxim::OTP::CTrimStructure("BatRegV", 4.2 V_f, 0.005 V_f, V, 0x31, 0x10, 0); 
@endcode

**************************************************************************************************************************************************************/

		//Define OTP store/retrieve functions https://confluence.maxim-ic.com/pages/viewpage.action?pageId=41649779
		#include <sqlite3Maxim.h>
		#include <Windows.h>
		#include <string>
		//#define SQLITE_DEBUG
		/************************************************************************************************************************************************************For*Doxygen**//**

			Function for checking if directory exists 

		@param dirName_in  name of directory
		@return true if directory exists

		**************************************************************************************************************************************************************/
		bool dirExists(const std::string& dirName_in)
		{
		  DWORD ftyp = GetFileAttributesA(dirName_in.c_str());
		  if (ftyp == INVALID_FILE_ATTRIBUTES)
			return false;  //something is wrong with your path!

		  if (ftyp & FILE_ATTRIBUTE_DIRECTORY)
			return true;   // this is a directory!

		  return false;    // this is not a directory!
		}
		/************************************************************************************************************************************************************For*Doxygen**//**

			Function for generating filename for SQL database and opening database 

		@param ppSQLiteDatabase  Pointer to SQLite database object
		@return true if successfully opens

		**************************************************************************************************************************************************************/
		bool OpenSQLiteDB(sqlite3 ** ppSQLiteDatabase,bool bReadOnly=false)
		{
			const char* cPath="C:\\MAXIM_WAFERSORT_OTP\\";
			if (!dirExists(cPath))
				if (!CreateDirectory(cPath,NULL))
				{
					etsprintf("Maxim::OTP::OpenSQLiteDB Error: Unable to CreateDirectory %s.\n",cPath);
					return false;
				}
			
			char cWaferID[128];
			char cLOTNUM[128];
			std::string strFileName;
			int iRet;
			//Get LOT ID and wafer number
			iRet=GetETSVariable(SUBLOT_NUMBER,cWaferID,sizeof(cWaferID));
			cWaferID[iRet]=0;
			iRet=GetETSVariable(LOT_NUMBER,cLOTNUM,sizeof(cLOTNUM));
			cLOTNUM[iRet]=0;
			strFileName=cPath;
			strFileName.append(cLOTNUM);
			strFileName.append("_");
			strFileName.append(cWaferID);
			strFileName.append(".sqlite");
			int iFlags=SQLITE_OPEN_NOMUTEX;
			if (bReadOnly)
				iFlags=iFlags|SQLITE_OPEN_READONLY;
			else
				iFlags=iFlags|SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE;
			iRet=sqlite3_open_v2(strFileName.c_str(),ppSQLiteDatabase,iFlags,NULL);
			if (iRet!=SQLITE_OK) 
			{
					etsprintf("Maxim::OTP::OpenSQLiteDB Error: %d: Unable to Open Database %s.\n",iRet,strFileName.c_str());
					return false;
			}
			etsprintf("Maxim::OTP::OpenSQLiteDB Success: Database Opened: %s\n",strFileName.c_str());
			return true;
		}

		/************************************************************************************************************************************************************For*Doxygen**//**

			Function for storing OTP trim codes to disk for later use at a different temperature.  

		@param	strRegister		Name of Trim
		@param  siCode			SiteInt with Trim Code
		@return Returns true if successfully writes to file

		**************************************************************************************************************************************************************/
		bool StoreCode(std::string strRegister,SiteInt siCode, bool bXYOverride, SiteInt siX, SiteInt siY)
		{
			const char* cTableSetup="CREATE TABLE IF NOT EXISTS OTP_TRIMS ( TRIM_NAME TEXT NOT NULL, X INT NOT NULL, Y INT NOT NULL, TRIM_CODE INT NOT NULL, PRIMARY KEY (TRIM_NAME, X, Y));";
			sqlite3 *pDb;	
			sqlite3_stmt *ppStmt;
			//Find/Create/Open database file based on program name and lot id
			if (!OpenSQLiteDB(&pDb))
				return false;
			sqlite3_busy_timeout(pDb,1000);
			//Get XY
			if (!bXYOverride)
			{
				if (!GetUserSwitch(7))
				{
					etsMessageBox("Maxim::OTP::StoreCode Error: User Switch 7 (Prober) is set to False.  X/Y information not available\n", MB_OK);
					return false;
				}
				Maxim::Wafer::GetXYCoordinates(siX,siY);
			}
			//Prepare Database
			//CREATE TABLE IF NOT EXISTS OTP_TRIMS ( TRIM_NAME TEXT NOT NULL, X INT NOT NULL, Y INT NOT NULL, TRIM_CODE INT NOT NULL, PRIMARY KEY (TRIM_NAME, X, Y))
			int iRet;
			iRet=sqlite3_prepare_v2(pDb,cTableSetup,(int)strlen(cTableSetup),&ppStmt,NULL);
			if (iRet!=SQLITE_OK)
			{
					sqlite3_finalize(ppStmt);
					sqlite3_close(pDb);
					etsprintf("Maxim::OTP::StoreCode Error: %d: Unable to Create SQL statement.\n",iRet);
					return false;
			}
			iRet=sqlite3_step(ppStmt);
			sqlite3_finalize(ppStmt);
			if (iRet!=SQLITE_DONE)
			{
					sqlite3_close(pDb);
					etsprintf("Maxim::OTP::StoreCode Error: %d: Unable to Create Table.\n",iRet);
					return false;
			}

			//For each active site
			for (int iSite=0; iSite<Maxim::GetNumSites();iSite++)
			{
				if (msSiteStat(iSite))
				{
					char cBuffer[256];
					iRet=sprintf_s(cBuffer,"INSERT OR REPLACE INTO OTP_TRIMS VALUES ( \"%s\", %d, %d, %d );",strRegister.c_str(),siX[iSite],siY[iSite],siCode[iSite]);
					iRet=sqlite3_prepare_v2(pDb,cBuffer,(int)strlen(cBuffer),&ppStmt,NULL);
					if (iRet!=SQLITE_OK)
					{
						sqlite3_finalize(ppStmt);
						sqlite3_close(pDb);
						etsprintf("Maxim::OTP::StoreCode Error: %d: Unable to Create SQL statement.\n",iRet);
						return false;
					}
					iRet=sqlite3_step(ppStmt);
					sqlite3_finalize(ppStmt);
					if (iRet!=SQLITE_DONE)
					{
							sqlite3_close(pDb);
							etsprintf("Maxim::OTP::StoreCode Error: %d: Unable to Insert Rows: %s : X=%d, Y=%d, Code=%d\n",iRet,strRegister.c_str(),siX[iSite],siY[iSite],siCode[iSite]);
							return false;
					}
					else
					{
						etsprintf("Maxim::OTP::StoreCode Success: %s : X=%d, Y=%d, Code=%d\n",strRegister.c_str(),siX[iSite],siY[iSite],siCode[iSite]);
					}
				}
			}
			//Store in File, overwrite if already exists
	
			//Close File
			sqlite3_close(pDb);		
			return true;
		}	
		/************************************************************************************************************************************************************For*Doxygen**//**

			Function for retrieving OTP trim codes from disk

		@param	strRegister		Name of Trim
		@param  siCode			SiteInt for Trim Code
		@return Returns true if successfully reads from file

		**************************************************************************************************************************************************************/
		bool RetrieveCode(std::string strRegister, SiteInt &siCode, bool bXYOverride, SiteInt siX, SiteInt siY)
		{
			sqlite3 *pDb;
			sqlite3_stmt *ppStmt;
			int iRet;
			//Find/Create/Open database file based on program name and lot id
			if (!OpenSQLiteDB(&pDb,true))
				return false;
			sqlite3_busy_timeout(pDb,1000);
			//Get XY
			if (!bXYOverride)
			{
				if (!GetUserSwitch(7))
				{
					etsMessageBox("Maxim::OTP::RetrieveCode Error: User Switch 7 (Prober) is set to False.  X/Y information not available\n",MB_OK);
					return false;
				}
				Maxim::Wafer::GetXYCoordinates(siX,siY);
			}
			//For each active site
			for (int iSite=0; iSite<Maxim::GetNumSites();iSite++)
			{
				if (msSiteStat(iSite))
				{
					char cBuffer[256];
					iRet=sprintf_s(cBuffer,"SELECT TRIM_CODE FROM OTP_TRIMS WHERE TRIM_NAME=\"%s\" AND X=%d AND Y=%d;",strRegister.c_str(),siX[iSite],siY[iSite]);
					iRet=sqlite3_prepare_v2(pDb,cBuffer,(int)strlen(cBuffer),&ppStmt,NULL);
					if (iRet!=SQLITE_OK)
					{
						sqlite3_finalize(ppStmt);
						sqlite3_close(pDb);
						etsprintf("Maxim::OTP::RetrieveCode Error: %d: Unable to Create SQL statement.\n",iRet);
						return false;
					}
					iRet=sqlite3_step(ppStmt);
					if (iRet!=SQLITE_ROW)
					{
							sqlite3_close(pDb);
							etsprintf("Maxim::OTP::RetrieveCode Error: %d: Unable to Get Results.\n",iRet);
							return false;
					}
					siCode[iSite]=sqlite3_column_int(ppStmt,0);
					etsprintf("Maxim::OTP::RetrieveCode Success: %s : X=%d, Y=%d, Code=%d\n",strRegister.c_str(),siX[iSite],siY[iSite],siCode[iSite]);
					sqlite3_finalize(ppStmt);		
				}
			}
			//Retrieve from File
			
			//Close File
			return true;
		}

	} //end of OTP name space

} // end of Maxim name space

// #endif // Moving to release