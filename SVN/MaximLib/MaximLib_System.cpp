//DO NOT EDIT THIS FILE
/*** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-
*                                                                            
*	Source title:		MaximFuncLib_System.cpp                                                                            		  
*	URL:				$URL: https://svn.maxim-ic.com/svn/ets/test_programs/AP89/AP89_FT/Trunk/MaximLib/MaximLib_System.cpp $
*   Last Modified by:	$LastChangedBy: govit.pimthong $                                       
*	Date:				$Date: 2017-03-09 12:55:55 +0700 (Thu, 09 Mar 2017) $                                                
*   Current Rev:		$Revision: 61735 $
*                                                                            
*	Description:  
*		Maxim Function library file for System functions.  
*		Contains generic System functions.
*		Maxim library written and maintained by:								 
*			Brad Sitton  (Brad.Sitton@maximintegrated.com)
*
*   Revision History
*		
*                                                                            
**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****/
//DO NOT EDIT THIS FILE

/**********************************************************************************************************************************************For*Doxygen**//**
																																							 @file	MaximLib_System.cpp
																																							 @brief	Maxim library file for System functions.  Contains generic System functions.
																																							 **************************************************************************************************************************************************************/


/// The majority of functions developed within Maxim should fall under the Maxim namespace.  
namespace Maxim
{

	/// Contains functions that belong with ETS system, but are not specific to a particular instrument.
	namespace System
	{
		/************************************************************************************************************************************************************For*Doxygen**//**

		Calculates the power line frequency of the meter and returns the value in Hz.

		**************************************************************************************************************************************************************/

		double GetPowerLineFrequency(void)
		{
			clock_t lClockStart, lClockStop;
			double dDeltaTime;
			double dMeter;
			static bool statbDone = FALSE;
			static double statdPowerLineFrequency; 
	
			// If statement will cause line frequency to only be checked on the first call of this function
			if (!statbDone) 
			{
				Maxim::Meter::DMM::Config(DMM_DCV, DMM_RANGE_1V, DMM_RES_10PLC, DMM_APE_NA, DMM_FILT_NA,	DMM_INPUT_10G, DMM_TRIG_NA);
				Maxim::Meter::DMM::Autozero(false);
				Maxim::Meter::DMM::Display(DMM_DISP_OFF);
				lwait(250 ms_f);		// This delay is needed to have the previous instructions executed and no impact in the meter measurement
				lClockStart = clock();
				dMeter = Maxim::Meter::Meas();
				lClockStop = clock();

				dDeltaTime = (double)(lClockStop - lClockStart) / CLOCKS_PER_SEC;
				if (dDeltaTime > 0.187 && dDeltaTime < 0.3)		//We are measuring 10 PLC.  60 Hz = 16.7 ms.  50 Hz = 20 ms.  So we expect 60 Hz * 10 = 167 ms + overhead.  50 Hz * 10 = 200 ms + overhead.  So pick a number in the middle (187 ms).
				{
					statdPowerLineFrequency = 50;
				}
				else if (dDeltaTime > 0.125 && dDeltaTime < 0.187)
				{
					statdPowerLineFrequency = 60;
				}
				else
				{
					statdPowerLineFrequency = 10;	//Something went wrong.  Return 10Hz, which is the greatest common divisor or 50 and 60, so is a whole divisor of line cycles for each. 
				}
				statbDone = TRUE;
			}
			return statdPowerLineFrequency;
		}

	/************************************************************************************************************************************************************For*Doxygen**//**
	Global object used to report errors

	@code
	// Simple message
	Maxim::System::Message.Deliver("Error in trim routine");

	// Detailed message
	std::stringstream ssMessage;
	ssMessage << "CTrimStructure::EvaluateMeasurementUsingTable was passed measurement data for more than one pin.\n";
	ssMessage << "That functionality is not yet supported\n" << this->msTrimName << " was being evaluated";
	Maxim::System::Message.Deliver(ssMessage);
	@endcode

	@attention It is recommended that you use this object to report all of your error messages as it provides flexibility in the way messages are reported.
	Read the CMessage class definition to see more display options.
	**************************************************************************************************************************************************************/
		CMessage Message; ///< Global object used to report errors

	/************************************************************************************************************************************************************For*Doxygen**//**
	Display an error message.  Using breakpoints, one can trap on any error message called by this function.  
	Will add a time stamp and allow you to disable pop up messages for the remainder of the device.
	@code
	Maxim::System::Message.Deliver("Best way to display messages in Pop Up Windows and/or the Output Window.");
	@endcode

	@param	sMessageToDisplay	The error message to be displayed.
	@param	iSite			Site number that the error is associated with.  
	-1 is used for all sites.
	-2 is used if site association is unknown.

**************************************************************************************************************************************************************/
		void CMessage::Deliver(std::string sMessageToDisplay, int iSite)
		{
			time_t rawTime; // Time object to store system time readings in

			time(&rawTime); // Retrieve the system time
			char cTimeOfError[26]; // MSVC documentation suggests largest string is 26 characters.
			ctime_s(cTimeOfError, 26, &rawTime); // Convert time into a string


			std::stringstream ssOutputMessage;
			std::stringstream ssProgramTime, ssTimeStamp;

			double dTime = ltime(7) / 1e6;
			ssProgramTime << std::setprecision(3) << dTime;

			// First write error message to file in comma delimited format, if mbLogMessagesToFile is TRUE
			if(mbLogMessagesToFile){
				std::ofstream  ofsOutputFile(Maxim::System::GetCompleteFileName("Error.log"), std::ios::app);
				if(!ofsOutputFile.failbit){
					if(ofsOutputFile.tellp() < 20) ofsOutputFile << "Calendar Time, Test Program Time (s), Error Message, Site" << std::endl;  // Write header line if it does not already exist
					ofsOutputFile << cTimeOfError << " , " << ssProgramTime << " , " << '"' << sMessageToDisplay << '" , ' << iSite << std::endl;
					ofsOutputFile.close();
				}
			}

			// Send message to MST output screen in multiple pieces since there is a limit of 256 characters in etsprintf
			// And ETS uses some of those characters for the "Sector ?: " statement 
			unsigned int uiMaxString = 240;	// Note: Need to reserve one of these locations for the null terminator that 
											// etsprintf uses
			for( unsigned int uiMessageStart = 0; uiMessageStart < sMessageToDisplay.size(); uiMessageStart += uiMaxString)
			{
				std::string sMessagePiece;
				// Determine size of message piece that will be sent in this call to etsprintf, then perform required copy, and etsprintf.
				unsigned int uiSizeOfMessagePiece = (unsigned int) min(uiMaxString,  (sMessageToDisplay.size() - uiMessageStart));
				sMessagePiece = sMessageToDisplay.substr(uiMessageStart, uiSizeOfMessagePiece);
				sMessagePiece += '\n';
				etsprintf(sMessagePiece.c_str());
			}
			std::stringstream ssTimingMessage;
			ssTimingMessage << "Message generated: " << cTimeOfError <<  "Time from start of test for this device was "<<  ssProgramTime.str() << " seconds on site: " << iSite << std::endl ;
			ssTimingMessage << "Recommend you trap in the function on this message and look at call stack\n";
			etsprintf(ssTimingMessage.str().c_str()); // Print error to output screen

			// Combine message into a single object for remaining display methods
			ssOutputMessage << sMessageToDisplay << std::endl << ssTimingMessage.str();

			// Display information on pop up screen if appropriate.
			//   Engineer can disable completely at the program level
			//   User can disable pop ups for remainder of given device.
			//   Don't show pop ups in operator mode, unless you are in off line mode
			if(mbDisplayPopUp && !mbHideRemainingMessages && (!Operator()||!bOnline())){
				ssOutputMessage << std::endl << "Hide Pop Ups for remainder of this device?" << std::endl;
				mbHideRemainingMessages = (IDYES == etsMessageBox(ssOutputMessage.str().c_str(), MB_YESNO));
			}

			// If an active iSite was passed in, then fail the device to bin 32
			if ((iSite>=0)&&msSiteStat(iSite)) msFailBin(iSite, "32");

			//How to throw alarm ETS call
			//Investigate assert C++.com
			//Disable asserts in release mode
			//If alarms can be set, then disable pop up in production
			// Intercept MST alarms, for example overshooting range.



			// Do we need to include site number in output?

		}

		/*  This function most likely will not be needed due to a change in strategy
		int GetVIMapIndex(int iPinGroup, int iGroupType)
		{	
		int iIndex = MAXIM_INVALID;
		if((iPinGroup < 1024)&&(iGroupType==NAME_START))
		{
		std::stringstream ssMessageToDisplay;
		ssMessageToDisplay << "Maxim::System::GetVIMapIndex failed to get a valid index /n  A GroupType is needed when iPinGroup < 1024 /n";
		ssMessageToDisplay << "Instruments channels aren't unique, i.e. 6 could be a CBit, an APU, or an SPU.\n";  
		Maxim::System::Message.Deliver(ssMessageToDisplay);
		}
		else iIndex = iPinGroup + (iGroupType!=NAME_START) ? 0 : iGroupType*1000 + 100,000 ;

		return iIndex;
		}
		*/




		//CTimeTool TimeTool;

/************************************************************************************************************************************************************For*Doxygen**//**
		Adds the current project directory pathname to sFileName which is provided by the user.

@param	sFileName	The name of the file you want to use.

@return	The full path of the current project along with the path to the file you want to use.
	
@code
		// Open an output file stream that will be written to OutputFile.csv
		std::ofstream  ofsOutputFile(Maxim::System::GetCompleteFileName("OutputFile.csv"), std::ios::app);

		// Write some data to OutputFile.csv, separating with commas and putting a return at the end of the line.
		ofsOutputFile << iData1 << " , " << dData2 << " , "  << iSite << std::endl;
@endcode
**************************************************************************************************************************************************************/
		std::string GetCompleteFileName(std::string sFileName){
			int iRC;
			char cProjectFolder[256];  //Full path to project folder

			// Obtain the directory that ETS is currently running out of.  Handle errors that Pat Hayes has observed in the past. -- BRS
			iRC=GetETSVariable(PROJECT_PATH,cProjectFolder,sizeof(cProjectFolder));
			if (iRC <0) 
					iRC=0;
			if (iRC >(sizeof(cProjectFolder)-1))
					iRC=sizeof(cProjectFolder)-1;
			cProjectFolder[iRC]=0;

			// Add path to file name
			sFileName = cProjectFolder + sFileName;

			return sFileName;			
		}
	}

}

