//DO NOT EDIT THIS FILE
/*** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-
*                                                                            
*	Source title:		Maximlib_PinMap.CPP                                                                            		  
*	URL:				$URL: https://svn.maxim-ic.com/svn/ets/test_programs/AP89/AP89_FT/Trunk/MaximLib/MaximLib_PinMap.cpp $
*   Last Modified by:	$LastChangedBy: govit.pimthong $                                       
*	Date:				$Date: 2017-03-09 12:55:55 +0700 (Thu, 09 Mar 2017) $                                                
*   Current Rev:		$Revision: 61735 $
*                                                                            
*	Description:  
*		Maxim library file for PinMap functions
*		Maxim library written and maintained by:								 
*			Brad Sitton (Brad.Sitton@Maxim-IC.com)
*			Patrick Hayes (Patrick.Hayes@Maxim-IC.com)	                 
*			Mark Bruening (Mark.Bruening@Maxim-IC.com)
*
*   Revision History
*		
*                                                                            
**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****/
//DO NOT EDIT THIS FILE

/**********************************************************************************************************************************************For*Doxygen**//**
@file	Maximlib_PinMap.cpp
@brief	Maxim library file for PinMap functions
**************************************************************************************************************************************************************/

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
#define MAXIMLIB_LIB


// disable warnings about long names
#ifdef WIN32
  #pragma warning( disable : 4786)
#endif

namespace Maxim {

/************************************************************************************************************************************************************For*Doxygen**//**
@brief	Contains classes and objects used to access information that was stored via the PinMap editor and/or set by the groupset command.  
		Most items in this namespace will be used by library functions and will not need to be accessed directly by the test engineer.
**************************************************************************************************************************************************************/


    namespace PinMap{

/************************************************************************************************************************************************************For*Doxygen**//**
Overload of ETS groupset function.  Recommend not using, since anything that can be done in this function
	can be done in the pin map editor.  This function does not work with I2C or other non-tester CBits.
	It is only provided for backward compatibility reasons.  This is slightly different from the MaximCBitGroupSet function.
	MaximCBitGroupSet is required when setting up groups of I2C CBits.

@param	iPosition	The logical position identifying the new group. Valid range is 256 – 32767.  For APU-12 groups, valid range is 1024 – 32767.
@param	ptrcName	The name to assign to the group.
@param	ptrcResources	A character string defining the resources to be included in the group

**************************************************************************************************************************************************************/
int Maximgroupset(int iPosition, char *ptrcName, char *ptrcResources, ...)
{
    va_list args;
    va_start(args, ptrcResources);
    int iErrorFlag=0;

    char ptrcResourceList[1024];

    vsprintf_s(ptrcResourceList, 1024, ptrcResources, args);
    
    std::string sResourceList (ptrcResourceList) ;


    iErrorFlag = groupset(iPosition, ptrcName, ptrcResourceList);

    if(iErrorFlag) ;// ETS failed on groupset
    else
/* This error check caused a problem for a case where engineer really wanted to redefine a groupset if more than 4 sites in their pin map.  At a future date I may 
   reinstate the error check with some sort of disable feature, but for now I am commenting it out.
	if (mapPGMEInt.count(iPosition)) {
            std::stringstream ssMessageToDisplay;
            ssMessageToDisplay << "Maxim::System::Maximgroupset failed."  << std::endl << "You used a group number number that already existed"<< std::endl;
            ssMessageToDisplay << "You passed the group number: " << iPosition << std::endl;
            Maxim::System::Message.Deliver(ssMessageToDisplay.str()); // Severity level 1, program should not be run.
            iErrorFlag = -1; // Wanted to return something other than 0 and did not want to conflict with ETS error codes.
        }
        else */
		{ // Group number was OK, so we can proceed to add it to mapPGMEInt.

            GROUPSETSTAT_STR groups[1];
            groupsetstat(iPosition, ptrcName, groups, 1, GROUPSETSTAT_STR_REV); // The requirement for groups to be an array confused me initially since it seems like 
																				//    you are always retrieving a single group ... then I recalled that -1 returns all groups

            //Appears that ETS groupset command only works for PMEInts, not GMEInts, so I will default that parameter in the following function call.
            mapPGMEInt[iPosition] = MaximPGMEInt(iPosition, ptrcName, (nameset_e) groups[0].brdtype, true);

			// ipos array appears to be an array of resources terminated with 0xFF.  Lower byte of ipos is resource number, upper byte is ISOCOMM port per 
			//   some email notes I read.  BRS 3/12/13
            for(int i=0; (groups[0].ipos[i]&0xFF) != 0xFF; i++) mapPGMEInt[iPosition].AddToGroup(groups[0].ipos[i]&0xFF); 
                                                                                             //   
  
        }

	va_end(args);
    return iErrorFlag;
}


// Global variable definitions
	std::map <int, MaximPGMEInt> mapPGMEInt;	// Map of all PME_INTS and GME_INTS.
	std::map<int, std::map<int, int>> mapResourceChannelSite;	// Map of maps to track which resources are associated with which sites


/************************************************************************************************************************************************************For*Doxygen**//**
Temporary storage when importing group information from pin map file.

@param	results		A pointer to a set of strings that contain information about the various tables in the PMD file (which is of format SQLite3).
**************************************************************************************************************************************************************/
PinMapGroupInfo::PinMapGroupInfo( char** results)
{
    if (results != NULL){
        msName = results[1];
        miPosition = atoi(results[3]);
        meType = (nameset_e) atoi(results[4]);
    }
}

/************************************************************************************************************************************************************For*Doxygen**//**
Two separate calls to this function are used to load in all of the relevant PME Int and GME Int information.  Commands were pulled from 
	SQLite3 example commands and inspection of the PMD file contents using SQLite viewer.

@param	db					SQLite3 database file that is being read
@param	sGroupCommand		Contains the SQLite3 command that will select either Groups of Pins, or jut Pins
@param	sResourceCommand		Indicates whether the filter applied will be for Pin Groups, or for individual Resource Numbers.
@param	bIsPMEInt			Indicates whether PMEInts are being read in or GMEInts are being read in.  Possible that this information could have been inferred by the sGroupCommand.
**************************************************************************************************************************************************************/
int LoadPinMapGroupHeaders(sqlite3*db, std::string sGroupCommand, std::string sResourceCommand, bool bIsPMEInt )
{
    int iRC;
    int iRows, iColumns;
    char* error;
    char** results;
    std::map <int, PinMapGroupInfo> groups;

    // Load in the general information for each group of pins
    iRC = sqlite3_get_table(db, sGroupCommand.c_str(), &results, &iRows, &iColumns, &error);
    if (iRC)
    {
        etsprintf("Error executing SQLite3 command: %s \n Error: %s\n", sGroupCommand, sqlite3_errmsg(db));
        sqlite3_free(error);
    }
    else
    {
        // Load the Group table 
        for (int rowCounter = 1; rowCounter <= iRows; ++rowCounter)
        {
            int firstCell = rowCounter*iColumns; // Identify the first cell for the given row
            int groupID = atoi(results[firstCell]); // Group index number
            groups[groupID] = PinMapGroupInfo(&results[firstCell]);
        }
    }

    // Combine general information with the list of resources associated with a group
    iRC = sqlite3_get_table(db, sResourceCommand.c_str(), &results, &iRows, &iColumns, &error);
        if (iRC)
    {
        etsprintf("Error executing SQLite3 query: %s\n", sqlite3_errmsg(db));
        sqlite3_free(error);
    }
    else
    {
        // Load the mapPGMEInt with all information
        for (int rowCounter = 1; rowCounter <= iRows; ++rowCounter)
        {
            int firstCell = rowCounter*iColumns; // Identify the first cell for the given row
            int groupID = atoi(results[firstCell+1]); // Group index number

            mapPGMEInt[groups[groupID].miPosition] = MaximPGMEInt(groups[groupID].miPosition, groups[groupID].msName, groups[groupID].meType,
                bIsPMEInt); 
            for (int columnCounter=2; columnCounter<iColumns; columnCounter++){
                int pin = atoi(results[firstCell + columnCounter]);
                if (pin>=0)	mapPGMEInt[groups[groupID].miPosition].AddToGroup(pin);
                else{
                    if (pin == -2){	// A -2 seems to be a trigger that the resource is site independent and that the next column will have the resource number
                        pin = atoi(results[firstCell + columnCounter +  1]);
                        for (int site = 0; site < Maxim::GetNumSites(); site++) mapPGMEInt[groups[groupID].miPosition].AddToGroup(pin); // Add same resource number to each site
                    }
                    columnCounter=iColumns;
                }
            }
        }
    }
    sqlite3_free_table(results);

    return 0;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Reads the PMD file for this test program and then stores useful information for PME Int and GME Int's.  Results are stored in the 
	mapPGMEInt. This function should be run once at program load.

@return	iRC which I believe is a location pointer of what is currently being read from the file.  Not clear why this needs to be returned.
**************************************************************************************************************************************************************/
int LoadPGMEInt()
{
    int iRC;
    sqlite3 *db;
    char fileName[256];

    iRC=GetETSVariable(PMD_FILE,fileName,sizeof(fileName));
    if (iRC <0) 
            iRC=0;
    if (iRC >(sizeof(fileName)-1))
            iRC=sizeof(fileName)-1;
    fileName[iRC]=0;

    // Open file, exit function if there are problems.
    std::ifstream inputFile;
    inputFile.open(fileName, std::ifstream::in);
    if (inputFile.bad()){
        etsprintf("Could not find file: %s \n", fileName);
        return 1;
    }
    inputFile.close();
    iRC = sqlite3_open(fileName, &db);
    if (iRC)
    {
        etsprintf("Error opening SQLite3 database: %s \n", sqlite3_errmsg(db));
        sqlite3_close(db);
        return 2;
    }

    // Load the GME_INT information into global map
    iRC &= LoadPinMapGroupHeaders(db, "SELECT * FROM Groups;", "SELECT * FROM PinGroup;", false);

    // Load the PME_INT information into global map
    iRC &= LoadPinMapGroupHeaders(db, "SELECT * FROM Pins;", "SELECT * FROM ResNum;", true);

    // Load PME_INT and GME_INT information into appropriate Maxim CBit Maps  
    //   Debatable whether this should be included here or in a separate function.
    std::map <int, MaximPGMEInt>::iterator it;

    sqlite3_close(db);

	// Create virtual CBitGroupRelayDriver for all Relay Groups.
    for (it=mapPGMEInt.begin(); it!=mapPGMEInt.end(); it++)	// Cycle through all instrument groups
	{
        if (it->second.IsCBit())								// Find groups that are associated with CBits
        {
            std::vector<int> viCBitList = it->second.GetGroupMembers();	//Get a list of all CBits associated with this group.
            std::set<int> cBitSet; 
            for (unsigned int i=0; i < viCBitList.size(); i++) cBitSet.insert(viCBitList[i]);

			//Update mapRelayDriver with information for this CBit group
            Maxim::CBits::Extended::mapRelayDriver[it->second.GetName()] = new Maxim::CBits::Extended::MaximCBitGroupRelayDriver(it->second.GetName(), viCBitList, it->second.GetPosition());
             
			// If we have reached PMEInts, then associate the site with them.  Assumption is that resources are listed starting at site 0 and incrementing by 1.
            if (it->second.IsPMEInt()) {
                vector<int>::iterator itCBit;
                int site = 0;
                for (itCBit = viCBitList.begin(); itCBit != viCBitList.end(); itCBit++){
                    Maxim::CBits::Extended::maximCBits.mapCBits[*itCBit].SetSite(site);
                    site++;
                }
            }
        }

		if(it->second.IsPMEInt())
		{
			std::vector<int> viResources = it->second.GetGroupMembers();
			for(unsigned int i=0; i < viResources.size(); i++)
			{
				// Store the site associated with a specific instrument and channel number using a map of maps
				//   This is an enabler for datalogging a single instrument out of a group of instruments
				mapResourceChannelSite[it->second.GetType()][it->second.GetGroupMembers().at(i)] = i;
			}
		}

    }



    return iRC;

}

/************************************************************************************************************************************************************For*Doxygen**//**
Creates a map of resources associated with a given PME Int or GME Int and assigns the proper site.

@return		A map of sites based on instrument

@see the wrapper function CountResources() which has an easier syntax, but really calls this function.
**************************************************************************************************************************************************************/
std::map<int, int>	MaximPGMEInt::GetInstrumentSiteMap()
{
	map<int, int> mapInstrumentSite;

    vector<int>::iterator it;
    int iCount=0;
    if(this->IsPMEInt())
	{
		int iSite=0;
		for(std::vector<int>::iterator it=mviGroupMembers.begin(); it!= mviGroupMembers.end(); it++)
		{
			mapInstrumentSite[*it] = iSite++; // Store site information and increment site.
		}
	}
    else
	{
        for(it=this->mviGroupMembers.begin(); it!=this->mviGroupMembers.end(); it++)
		{
			map<int, int> mapTemp = mapPGMEInt[*it].GetInstrumentSiteMap();
			mapInstrumentSite.insert(mapTemp.begin(), mapTemp.end());
        }
    }
    return mapInstrumentSite;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Provide a map associating each instrument with a site

@param		iPinGroup	MST Pin or Group for which number of resources need to be counted

@return		Map of instrument vs. site.  When dealing with instruments directly, the site is unknown and 0 will be returned.

**************************************************************************************************************************************************************/
std::map<int, int> GetInstrumentSiteMap(int iPinGroup)
{ 
	// Need to pass default values back for instruments since they don't have PinMap information associated with them
	if(iPinGroup < 128)
	{
		std::map<int, int> miDefault;
		miDefault[iPinGroup] = 0;   // Site is unknown so return a default value of one. 
		return miDefault;
	}
	else
	return mapPGMEInt.find(iPinGroup)->second.GetInstrumentSiteMap();
}
/************************************************************************************************************************************************************For*Doxygen**//**
Counts the total number of resources associated with a given PME Int or GME Int.  For example if you use a different set of 3 resources for each of 4 sites
	the return value is 12.  1 resource shared by 4 sites will return 4.

@return		The total number of resources associated with the given PME Int or GME Int.

@see the wrapper function CountResources() which has an easier syntax, but really calls this function.
**************************************************************************************************************************************************************/
int MaximPGMEInt::CountResources()
{
    vector<int>::iterator it;
    int iCount=0;
    if(this->IsPMEInt()) iCount += (int) this->mviGroupMembers.size();
    else{
        for(it=this->mviGroupMembers.begin(); it!=this->mviGroupMembers.end(); it++){
            iCount += Maxim::PinMap::CountResources(*it);  // Note that this is NOT the member function with the same name
															// Need this strategy since *it might be an instrument (<128) instead of PME or GME Int.
        }
    }
    return iCount;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Counts the total number of resources associated with a given PME Int or GME Int.  For example if you use a different set of 3 resources for each of 4 sites
		the return value is 12.  1 resource shared by 4 sites will return 4.

@param		iPinGroup	MST Pin or Group for which number of resources need to be counted

@return		Number of resources  

**************************************************************************************************************************************************************/
int CountResources(int iPinGroup)
{ 
	// Need to pass default values back for instruments since they don't have PinMap information associated with them
	if(iPinGroup < 128) return 1;
	else				return mapPGMEInt.find(iPinGroup)->second.CountResources();
}

/************************************************************************************************************************************************************For*Doxygen**//**
Get the name of a given pin or group

@param	iPinGroup	MST Pin or Group for which number of resources need to be counted

@return		Name of the pin or group.  
                                                                            
**************************************************************************************************************************************************************/
std::string GetPinName(int iPinGroup)
{ 
	// Need to pass default values back for instruments since they don't have PinMap information associated with them
	if(iPinGroup < 128) return std::string("Unknown");
	else				return mapPGMEInt.find(iPinGroup)->second.GetName();
}

/************************************************************************************************************************************************************For*Doxygen**//**
Return the list of resources associated with a pin or group

@param	iPinGroup	MST Pin or Group for which number of resources need to be counted

@return		Vector with all resources associated with the pin or group  
                                                                            
**************************************************************************************************************************************************************/
std::vector<int> GetResources(int iPinGroup)
{
	vector<int> viResourceList, viGroupMembers;

	// If accessing instrument directly, need to handle a bit differently since mapPGMEInt entry does not exist for instrruments.
	if(iPinGroup < 128)
	{
		std::vector<int> viPinGroup;
		viPinGroup.push_back(iPinGroup);
		return viPinGroup;
	}

	viGroupMembers = mapPGMEInt.find(iPinGroup)->second.GetGroupMembers();

	for(vector<int>::iterator it= viGroupMembers.begin(); it < viGroupMembers.end(); it++){
		if(*it < 1000) viResourceList.push_back(*it);	// Points to an APU channel
		else {											// Was a group, so we need to break it down to APU channels
			vector<int> viSubResourceList = GetResources(*it);
			viResourceList.insert(viResourceList.end(),viSubResourceList.begin(), viSubResourceList.end());
		}
	}
	return viResourceList;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Return the type of instrument associated with a pin or group

@param	iPinGroup	MST Pin or Group for which number of resources need to be counted

@return		Instrument type

Valid instrument types are defined in cdef500d.h with enum nameset_e.
	NAME_START,
    NAME_CBIT,
    NAME_GROUP,
    NAME_QMS,
    NAME_SP500,
    NAME_SP100,
    NAME_MCU,
    NAME_DPIN_DP,
    NAME_DPIN_RP,
    NAME_QTMU,
    NAME_DPU16,
    NAME_HPU,
    NAME_APU12,
    NAME_SP112,


**************************************************************************************************************************************************************/
nameset_e GetInstrumentType(int iPinGroup)
{
	if(iPinGroup < 128) return NAME_START;	// Equivalent to unknown.  We only know the type for PME or GME Int.  Don't know type for raw instrument since  
											//		instruments have overlapping numbers.  Specifically, each instrument starts at 0.
	return mapPGMEInt.find(iPinGroup)->second.GetType();
}

/************************************************************************************************************************************************************For*Doxygen**//**
Counts the number of resources in a DPIN group.

@param	sPinGroup	MST Pin or Group for which number of resources need to be counted

@return		Number of resources in group
                                                                 
**************************************************************************************************************************************************************/
	int CountResources(std::string sPinGroup)
	{
		return dpinstat(sPinGroup.c_str(), -1, NULL, MS_ALL);
	}


	// Not sure if this function is needed or not.
	std::vector<int> GetResources(std::string sPinGroup);

/************************************************************************************************************************************************************For*Doxygen**//**
Finds the next group number that is equal or greater than iPinGroup.  Typically this would be used before 
	a call to groupset() to avoid collisions in group numbers

@param	iPinGroup	MST Pin or Group for which number of resources need to be counted

@return		The next available group number.
                                                                            
**************************************************************************************************************************************************************/
		int FindAvailableGroupNumber(int iPinGroup)
		{
			while(mapPGMEInt.count(iPinGroup)&&(iPinGroup<32768)) iPinGroup++; // Increase iPinGroup until an unused group is found.

			if (iPinGroup==32768) Maxim::System::Message.Deliver("Maxim::System::FindAvailableGroupNumber had an error \n");

			return iPinGroup;
		}




    }//namespace System
}//namespace Maxim


