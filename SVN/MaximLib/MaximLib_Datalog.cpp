//DO NOT EDIT THIS FILE
/*** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-
*                                                                            
*	Source title:		Maximlib_Datalog.CPP                                                                            		  
*	URL:				$URL: https://svn.maxim-ic.com/svn/ets/test_programs/AP89/AP89_FT/Trunk/MaximLib/MaximLib_Datalog.cpp $
*   Last Modified by:	$LastChangedBy: govit.pimthong $                                       
*	Date:				$Date: 2017-03-09 12:55:55 +0700 (Thu, 09 Mar 2017) $                                                
*   Current Rev:		$Revision: 61735 $
*                                                                            
*	Description:  
*		Maxim library file for datalog functions
*		Maxim library written and maintained by:								 
*			Patrick Hayes (Patrick.Hayes@MaximIntegrated.com)	                 
*			Mark Bruening (Mark.Bruening@MaximIntegrated.com)                                                                            
*
*   Revision History
*		See Maximlib.h file.
*                                                                            
**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****/
//DO NOT EDIT THIS FILE

/**********************************************************************************************************************************************For*Doxygen**//**
@file	Maximlib_Datalog.cpp
@brief	Maxim library file for datalog functions
**************************************************************************************************************************************************************/

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers

#include <queue>
#include <deque>
#include <math.h>	//for _HUGE (+infinity)
#include <float.h>
#undef max
#undef min
#include <limits>
#include <unordered_map>
#include <unordered_set>


//Variables set in DatalogInit
PDS_INT gdsiTestNumber;			//Array of Test Numbers from the Datasheet
PDS_CHAR gdscTestName;			//Array of Test Names from the Datasheet
PDS_DOUBLE gdsdOfflineAnswer;	//Array of Offline Answers from the Datasheet
int giNumSites;					//Number of sites in the program's Pin Map (not all sites are necessarily active).
bool gbOfflineDevel = false;	
bool gbOfflineAnswer = false;
bool pbSiteDatalogged[MAX_SITES];
PDS_DOUBLE pdsdLoLimit, pdsdHiLimit;
PDS_INT pdsiTestNumber;
std::string MaxLogFormat="9.3";
PDS_DOUBLE pdsdLogFormat;
std::vector<double> vdUnitsToBase;
PDS_CHAR pdscUnits;
int piDSSize = 0;
//end of variables set in DatalogInit

//variables for QTMU
//int QTMU_samples = 1;
//end of variables for QTMU

class CTestTime {
	protected:
		long pTestNumber;
		std::string pTestName;
		double pTime;
	public:
		CTestTime(long testnum, std::string testname, double time)
		{
			pTestNumber=testnum;
			pTestName=testname;
			pTime=time;
		}
		void Log()
		{
		std::string format;
		format = "Time : %7d  %"+ MaxLogFormat + "f %5s %22s %-30s\n"; 
		etsprintf(format.c_str(),pTestNumber,pTime,"ms","",pTestName.c_str());
		}

};
	
std::queue<CTestTime*> QTestTime;

// Used to track datasheet items that were datalogged for some but not all sites.
//   This class was needed to handle site loops where some but not all sites were datalogged.  
//   Careful handling/evaluation is needed to determine if an error message should be displayed during
//   DatalogFlush
class CMissingDatalogTracker {
private:

	std::map<int, int> mmapMissingDatalog;
public:
	void Register(int iTestNumber, unsigned int uiMissingData)
	{

		if(mmapMissingDatalog.count(iTestNumber))
			mmapMissingDatalog[iTestNumber] &= uiMissingData; //Update status 
		else
			mmapMissingDatalog[iTestNumber] = uiMissingData;
	}
	
	void ReportErrors()
	{
		//Cycle through each test that was logged as having data missing at some site at some point
		for(std::map<int, int>::iterator it=mmapMissingDatalog.begin(); it!= mmapMissingDatalog.end(); it++)
		{
			// If there are any sites missing data, issue an error message
			if(it->second)
			{
				for(int iSite=0; iSite < giNumSites; iSite++)
				{
					if(it->second&(1<<iSite))
					{
						etsprintf("Error!  Site %d is active but not being datalogged for Test# %d.  Setting Alarm Bin 32\n",iSite, it->first);
						msFailBin(iSite,"32");
						msFailSite(iSite);
					}
				}
			}
		}

		//All errors reported, now we can clear the map
		mmapMissingDatalog.clear();
	}

	bool Tracking(int iTestNumber)
	{
		return  mmapMissingDatalog.count(iTestNumber)>0;
	}
};

CMissingDatalogTracker MissingDatalogTracker;

 class CDatalog {
	protected:
		int pindex;
		int psite;
		double presult;
		RESULTS_STR *presults;
		int presultsSize;
		int pelementOffset;
		int pelementSize;
		std::string strFail;
		void RealTimeDatalog(bool single)
		{
#ifdef GPSW_REAL_TIME_DATALOG 
			if (GetUserSwitch( GPSW_REAL_TIME_DATALOG )&&!Maxim::Operator())
			{
			bool lo_limit;
			bool hi_limit;
				//char sTempResult[15];
				LPSTR TestName=gdscTestName[pindex];
				if (TestName == NULL) 
				{
					TestName="";
				}
				//TEST#,7	RESULT (max of numbers on datasheet),	UNITS	LOWER	UPPER	--ALARM--	TEST NAME
				std::string format;			
				if (pdsdLoLimit[pindex]==std::numeric_limits<double>::max( )) 
					lo_limit = false;
				else 
					lo_limit = true;

				if (pdsdHiLimit[pindex]==std::numeric_limits<double>::max( )) 
					hi_limit = false;
				else 
					hi_limit = true;

				//presult is set to std::numeric_limits<double>::max( ) when left blank on the Datasheet.
				//sprintf(sTempResult, "%9.5f", std::numeric_limits<double>::max( ));  //Uncomment to show the issue
				//sprintf_s(sTempResult, "%9.5e", std::numeric_limits<double>::max( ));  	//Scientific notation works
				//sprintf_s(sTempResult, "%9.5g", std::numeric_limits<double>::max( ));   //Or let printf choose between %f and %e
				//MWB modified the result formatting below from %f to %g to fix the issue.

				if (lo_limit && hi_limit)
					format ="Site%1d: %7d  %s %" + MaxLogFormat + "g %5s %10.4f %10.4f  %-30s\n"; 
				else if (lo_limit && !hi_limit) 
					format ="Site%1d: %7d  %s %" + MaxLogFormat + "g %5s %10.4f %14s  %-30s\n"; 
				else if (!lo_limit && hi_limit) 
					format ="Site%1d: %7d  %s %" + MaxLogFormat + "g %5s %14s %10.4f  %-30s\n"; 
				else
					format ="Site%1d: %7d  %s %" + MaxLogFormat + "g %5s %14s %14s  %-30s\n"; 

				if (single)
				{
					strFail=" ";
					if (lo_limit && hi_limit)
					{
						if (presult <pdsdLoLimit[pindex] || presult>pdsdHiLimit[pindex]) strFail="F"; 	
						etsprintf(format.c_str(),psite,gdsiTestNumber[pindex], strFail.c_str(),presult,pdscUnits[pindex],pdsdLoLimit[pindex],pdsdHiLimit[pindex], TestName);
					}	
					else if (lo_limit && !hi_limit) 
					{
						if (presult <pdsdLoLimit[pindex]) strFail="F"; 	
						etsprintf(format.c_str(),psite,gdsiTestNumber[pindex], strFail.c_str(),presult,pdscUnits[pindex],pdsdLoLimit[pindex],"", TestName);
					}
					else if (!lo_limit && hi_limit) 
					{
						if (presult>pdsdHiLimit[pindex]) strFail="F"; 	
						etsprintf(format.c_str(),psite,gdsiTestNumber[pindex], strFail.c_str(),presult,pdscUnits[pindex],"",pdsdHiLimit[pindex], TestName);
					}
					else
						etsprintf(format.c_str(),psite,gdsiTestNumber[pindex], strFail.c_str(),presult,pdscUnits[pindex],"","", TestName);
				}
				else
				{
					for (int site=0; site<giNumSites;site++)
					{
						strFail=" ";
						if (msSiteStat(site))
						{
						if (lo_limit && hi_limit)
						{
							if (presults[site].value <pdsdLoLimit[pindex] || presults[site].value>pdsdHiLimit[pindex]) strFail="F"; 	
							etsprintf(format.c_str(),site,gdsiTestNumber[pindex], strFail.c_str(),presults[site].value,pdscUnits[pindex],pdsdLoLimit[pindex],pdsdHiLimit[pindex], TestName);
						}
						else if (lo_limit && !hi_limit) 
						{
							if (presults[site].value <pdsdLoLimit[pindex]) strFail="F"; 	
							etsprintf(format.c_str(),site,gdsiTestNumber[pindex], strFail.c_str(),presults[site].value,pdscUnits[pindex],pdsdLoLimit[pindex],"", TestName);
						}
						else if (!lo_limit && hi_limit) 
						{
							if (presults[site].value>pdsdHiLimit[pindex]) strFail="F"; 
							etsprintf(format.c_str(),site,gdsiTestNumber[pindex], strFail.c_str(),presults[site].value,pdscUnits[pindex],"",pdsdHiLimit[pindex], TestName);
						}
						else
							etsprintf(format.c_str(),site,gdsiTestNumber[pindex], strFail.c_str(),presults[site].value,pdscUnits[pindex],"","", TestName);
						}
					}
				}
			}	//end of if (GetUserSwitch( GPSW_REAL_TIME_DATALOG )&&!Maxim::Operator())
#endif
		}	//End of void RealTimeDatalog(bool single)


	public:
		int GetDSIndex() { return this->pindex; }
		virtual int Log(void) =0;	
		void SetLogMulti(int index, RESULTS_STR *results, int resultsSize , int elementOffset , int elementSize)
		{
			//Store Result
			Maxim::Results::SetResult(index,results);
			pindex=index;
			presults=results;
			presultsSize=resultsSize;
			pelementOffset=elementOffset;
			pelementSize=elementSize;
			RealTimeDatalog(false);
		}
		void SetLogSingle(int site, int index, double result)
		{
			//Store Result
			Maxim::Results::SetResult(index,result,site);

			psite=site;
			pindex=index;
			presult=result;
			RealTimeDatalog(true);
		}

 };

 class CDatalogSingle: public CDatalog	{
	 public:
		int Log (void)
		{
			int retval=0;
			SetTestNumber(0);	//not using Test-Number (only using Sub-Test-Number) to make the test numbers in the STDF match the text datalog file
			if (pindex>piDSSize)
				etsprintf("Index number %d is greater than DSSIZE %d.\n",pindex,piDSSize);
			else
				SetSubTestNumber(gdsiTestNumber[pindex]);
			retval= msLogResult(psite,pindex,presult);
			Maxim::DatalogLib::SiteDatalogged(psite);
			Maxim::DPAT::DPAT_data(pindex, presult, psite);
#ifdef GALAXY_PAT
			Maxim::Galaxy::Data(psite,Maxim::Limits::GetTestNumberbyIndex(pindex),Maxim::Limits::GetTestNamebyIndex(pindex),presult*Maxim::Limits::STDFUnitsScaleToBase(pindex));
#endif
			return retval;
		}
 };

 class CDatalogMulti: public CDatalog	{
	 public:
		int Log (void)
		{
			int retval = 0;
			int index;
			SetTestNumber(0);	//not using Test-Number (only using Sub-Test-Number) to make the test numbers in the STDF match the text datalog file
			if (pindex>piDSSize)
				etsprintf("Index number %d is greater than DSSIZE %d.\n",pindex,piDSSize);
			else
				SetSubTestNumber(gdsiTestNumber[pindex]);
			retval = msLogResultAll(pindex,presults,presultsSize,pelementOffset, pelementSize);

			for (int result=0;result<presultsSize;result++)
			{		
				index=pelementOffset + result*pelementSize;
				if (index < presultsSize && presults[index].site!=-2)
					if (presults[index].site>0)
						Maxim::DatalogLib::SiteDatalogged(presults[index].site);
					else
						Maxim::DatalogLib::SiteDatalogged(result);
			}

			//Pass values to DPAT and check to make sure active site is datalogged
			unsigned int uiMissingData = 0; // Assume no data is missing
			for (int iSite=0; iSite<Maxim::GetNumSites();iSite++)
			{
				if (msSiteStat(iSite))
				{
					Maxim::DPAT::DPAT_data(pindex, presults[iSite].value, iSite);
#ifdef GALAXY_PAT
					Maxim::Galaxy::Data(iSite,Maxim::Limits::GetTestNumberbyIndex(pindex),Maxim::Limits::GetTestNamebyIndex(pindex),presults[iSite].value*Maxim::Limits::STDFUnitsScaleToBase(pindex));
#endif
					if (presults[iSite].site==-2) uiMissingData |= 1 << iSite;
					//{
					//	etsprintf("Error!  Site %d is active but not being datalogged for Test# %d.  Setting Alarm Bin 32\n",iSite,Maxim::Limits::GetTestNumberbyIndex(pindex));
					//	msFailBin(iSite,"32");
					//	msFailSite(iSite);
					//}
				}

			}
			// If any missing data was encountered or if this test is already being tracked, then need to register the results
			if(uiMissingData || MissingDatalogTracker.Tracking(gdsiTestNumber[pindex])) MissingDatalogTracker.Register(gdsiTestNumber[pindex], uiMissingData);

			delete presults;
			return retval;
		}

		~CDatalogMulti()
		{
			delete presults;
		}

 };


std::queue<CDatalog*> QDatalog;
namespace Maxim
{


/************************************************************************************************************************************************************For*Doxygen**//**
@brief Replace the built in msLogResultAll function with added functionality.  

- Maxim::DatalogAll overrides the native msLogResultAll and adds a datalog function using PinListData or SiteVar. 
	- DatalogAll logs to every site included in the RESULT_STR or PinListData.
- __Index is auto-incremented__
- Multi-pin measurements will be logged as individual datasheet lines (index is incremented per pin)
- \ref quickStartPinListData "Example Datalogging"
- \ref DataloggingSiteLoops "Example Datalogging in Site Loops" 
- \ref sharingInstruments "Sharing Instruments"

@param	[index] The Test index from the DataSheet.  Typically, use DSIndex.  index is automatically incremented.
@param	[pld]	A PinListData variable containing the measurement results.

@return		Returns SUCCESS if the data was stored in the queue.  Returns FAILURE if there was an error.

@remarks:
		This version of DatalogAll supports datalogging more than one pin at a time.  

		Datalog results are stored internally until the datalog is output with function Maxim::DatalogFlush();
		This prevents the power down functions from being called until Maxim::DatalogFlush(); is called.  
		This promotes power down sequencing best practices by only allowing the power down functions to be called at designated places in the test program.
**************************************************************************************************************************************************************/
	int DatalogAll( int &index,  PinListData pld)
	{
		RESULTS_STR *Results;
		int iRet;	
		if (pld.iGetNumPins() < 1)
		{
			return FAILURE;
		}
		else
		{
			Results = pld.ResultsStructPtr();
			iRet = SUCCESS;
			for (int i = 0; i < pld.iGetNumPins(); i++)
			{
				iRet = DatalogAll(index, Results, giNumSites, i * giNumSites,  1) || iRet;			//Assumes Group Ordering in the Pin Map Editor options 
																									//is set to the second option (PinA site1, PinA site2)
			}
			delete[] Results; 
			return iRet;
		}
		
	}


/************************************************************************************************************************************************************For*Doxygen**//**
@brief Replace the built in msLogResultAll function with added functionality.  

- Maxim::DatalogAll overrides the native msLogResultAll and adds a datalog function using PinListData or SiteVar. 
	- DatalogAll logs to every site included in the RESULT_STR or PinListData.
- __Index is auto-incremented__
- Multi-pin measurements will be logged as individual datasheet lines (index is incremented per pin) 
- \ref quickStartPinListData "Example Datalogging"
- \ref DataloggingSiteLoops "Example Datalogging in Site Loops" 
- \ref sharingInstruments "Sharing Instruments"

@param	[index] The Test index from the DataSheet.  Typically, use DSIndex.  index is automatically incremented.
@param	[results] A pointer to an array of RESULTS_STR.  See msLogResultAll documentation.
@param	[resultsSize] Must be equal to NUM_SITES.  See Remarks.
@param	[elementOffset] See msLogResultAll documentation.
@param	[elementSize] See msLogResultAll documentation.

@return		Returns SUCCESS if the data was stored in the queue.  Returns FAILURE if there was an error.

@remarks
		This version of DatalogAll does not support datalogging more than one pin at a time.  
		To datalog more than one pin at a time, use the PinListData version of this function, or call it in a loop.  

		Datalog results are stored internally until the datalog is output with function Maxim::DatalogFlush();
		This prevents the power down functions from being called until Maxim::DatalogFlush(); is called.  
		This promotes power down sequencing best practices by only allowing the power down functions to be called at designated places in the test program.
**************************************************************************************************************************************************************/
	int DatalogAll( int &index, RESULTS_STR *results, int resultsSize , int elementOffset , int elementSize)
	{
		int i;
		CDatalog* tempDatalog;
		RESULTS_STR* results2;

		if (results == NULL) 
		{	//retrieve the results from the ETS "utility mailbox" (the last measured results)
			//groupgetresults( results, giNumSites);	//If results was not passed in, retrieve results for 1 pin and all sites.
			etsprintf("Error! msLogResultAll results not passed in.\n");	//Made the decision to no longer support this at Maxim.  Programs should explicitly pass in results.
			return FAILURE;
		}

		if (resultsSize != giNumSites)	//Only supporting datalogging one pin at a time.  This is required to increment index properly.
		{
			etsprintf("Error! msLogResultAll resultsSize not equal to the number of sites.\n");
			return FAILURE;
		}	

		results2 = new RESULTS_STR[giNumSites];	//Create an array to copy results.
				

		//Copy only the results that are being datalogged at this index.
		for (i=0 ; i<resultsSize; i++)	
		{
			results2[i]=results[elementOffset + (elementSize * i)];	//elementSize is included to support the other datalog style, pins then sites, instead of sites then pins.
																	//However, sites then pins is the preferred method.
		}

		if (gbOfflineDevel && gbOfflineAnswer) //If not on a tester, overwrite the results with the Offline_Answers provided on the DataSheet.
		{			
			for (i=0; i<resultsSize;i++)
			{	
				results2[i].value=gdsdOfflineAnswer[index];	//Use the offline answer at DSINDEX for each pins value
			}
		}

		//Store the datalog results until Maxim::DatalogFlush(); is called
		tempDatalog= new CDatalogMulti;
		tempDatalog->SetLogMulti(index++,results2,resultsSize,0,1);	//elementOffset is set to 0 since results2 already took care of the offset.  elementSize was also taken care of by results2.
		QDatalog.push(tempDatalog);	//Add the results to the buffer.


		if (Maxim::DatalogLib::gTestTimeEnable)		//Datalog Test Time
		{
			CTestTime* tempTestTime;
			LPSTR TestName=gdscTestName[index-1];
			if (TestName == NULL) TestName="";
			int TestNumber=gdsiTestNumber[index-1];
			double TestTime=double(ltime(6))/1000.0;
			mark(6);

			tempTestTime = new CTestTime(TestNumber,TestName,TestTime);
#ifdef GPSW_REAL_TIME_DATALOG 
			if (GetUserSwitch( GPSW_REAL_TIME_DATALOG )&&GetETSVariable(SECURITY_LVL) != 0)
				tempTestTime->Log();
			else
#endif
				QTestTime.push(tempTestTime);
			//etsprintf("Test Time: %10d %30s %9.1f ms\n",TestNumber,TestName,TestTime);
			Maxim::DatalogLib::gTestTimeCumulative=Maxim::DatalogLib::gTestTimeCumulative + TestTime;
		}

		return SUCCESS;
		
	}

	//template <class T> int DatalogAll( int &index,   SiteVar<T> sv)
	//{
	//		Code in .h file due to Template restriction.
	//}

	/*int DatalogAll( int &index, SiteBool sb)
	{
		int iRet;
		unsigned int uiSite;	
		iRet = SUCCESS;
		for (uiSite=0; uiSite<sb.size(); uiSite++)
		{
			if (msSiteStat(uiSite)) //if site active
				iRet = Datalog(uiSite, index, (double) sb[uiSite]) || iRet;
		}
		index++;
		return iRet;
	}*/


/************************************************************************************************************************************************************For*Doxygen**//**
Replace the built in msLogResult function with added functionality. 

@details
- Designed to be called in a site loop.
	- Useful for variables that are not site-aware.  (Use Maxim::DatalogAll for PinListData or SiteVar.)
- Datasheet Index must be manually incremented after the site loop.
- \ref quickStartPinListData "Example Datalogging"
- \ref DataloggingSiteLoops "Example Datalogging in Site Loops" 
- \ref sharingInstruments "Sharing Instruments"

Calling the Datalog function with parameters __will NOT trigger Maxim_OnFailSite()__ being called for failing sites.

@param	[site] The test site number to datalog.
@param	[index] The Test index from the DataSheet.  Typically, use DSIndex.  index must be manually incremented.
@param	[result] The result to datalog.

@returns	See msLogResult documentation.

@remarks
		- Datalog results are stored internally until the datalog is output with function Maxim::DatalogFlush();
		- This prevents the power down functions from being called until Maxim::DatalogFlush(); is called.
		- This promotes power down sequencing best practices by only allowing the power down functions to be called at designated places in the test program.

**************************************************************************************************************************************************************/
	int Datalog( int site, int index, double result)
	{
		CDatalog* tempDatalog;
		static int lastindex=-1;

		//Datalog Test Time


		if (gbOfflineDevel && gbOfflineAnswer) //If not on a tester, overwrite the results with the Offline_Answers provided on the DataSheet.
		{			
			result = gdsdOfflineAnswer[index];			
		}

		//Store the datalog results until Maxim::DatalogFlush(); is called
		tempDatalog = new CDatalogSingle;
		tempDatalog->SetLogSingle(site,index,result);
		QDatalog.push(tempDatalog);
		

		if (Maxim::DatalogLib::gTestTimeEnable)
		{
			CTestTime* tempTestTime;
			if (lastindex!=index)
			{
				LPSTR TestName=gdscTestName[index];
				if (TestName == NULL) TestName="";
				int TestNumber=gdsiTestNumber[index];
				double TestTime=double(ltime(6))/1000.0;
				mark(6);
				tempTestTime = new CTestTime(TestNumber,TestName,TestTime);
#ifdef GPSW_REAL_TIME_DATALOG 
				if (GetUserSwitch( GPSW_REAL_TIME_DATALOG )&&GetETSVariable(SECURITY_LVL) != 0)
					tempTestTime->Log();
				else
#endif
					QTestTime.push(tempTestTime);
				//etsprintf("Test Time: %10d %30s %9.1f ms\n",TestNumber,TestName,TestTime);
				Maxim::DatalogLib::gTestTimeCumulative=Maxim::DatalogLib::gTestTimeCumulative + TestTime;
				lastindex=index;
			}

		}
		return SUCCESS;
	
	}



/************************************************************************************************************************************************************For*Doxygen**//**
Replace the built in msLogResultInit function with added functionality. 

@param	[TestNumber] Not used, see Remarks.  Here only to maintain compatibility with the built in msLogResultInit function.
@param	[SubTestNumber] See msLogResultInit documentation.
@param	[TestDesc] See msLogResultInit documentation.
@param	[LogFormat] See msLogResultInit documentation.
@param	[TestLimitLo] See msLogResultInit documentation.
@param	[TestLimitHi] See msLogResultInit documentation.
@param	[TestLimitUnits] See msLogResultInit documentation.
@param	[LoLimitBin] See msLogResultInit documentation.
@param	[HiLimitBin] See msLogResultInit documentation.
@param	[LoSpec] See msLogResultInit documentation.
@param	[HiSpec] See msLogResultInit documentation.
@param	[NumSites] Number of sites in the program's Pin Map (Pass in the pre-defined NUM_SITES constant)
@param	[OfflineAnswer] (optional) The Offline Answer DataSheet column array.
@param	[DataSheetSize]

@returns	See msLogResultInit documentation.

@remarks		Pass in the OfflineAnswer PDS_DOUBLE if you want the datalog routines to pull measurements from the 
			Datasheet's column while developing on an offline system (without a tester).

		TestNumber is not used (Only using SubTestNumber).  This is done to make the STDF file test numbers match the text datalog test numbers
   Revision History
		20121025 MWB added the check for invalid fail bins.  
																			
**************************************************************************************************************************************************************/
	int DatalogInit( PDS_INT TestNumber, PDS_INT SubTestNumber, PDS_CHAR TestDesc, 
									PDS_DOUBLE LogFormat, PDS_DOUBLE TestLimitLo, PDS_DOUBLE TestLimitHi, 
									PDS_CHAR TestLimitUnits, PDS_CHAR LoLimitBin,  PDS_CHAR HiLimitBin, 
									PDS_DOUBLE LoSpec, PDS_DOUBLE HiSpec, int NumSites, PDS_DOUBLE OfflineAnswer, int DataSheetSize)
	{
		gdsdOfflineAnswer = OfflineAnswer;
		gbOfflineAnswer = true;

		return DatalogInit(TestNumber,SubTestNumber,TestDesc,LogFormat,TestLimitLo, TestLimitHi,TestLimitUnits,LoLimitBin,HiLimitBin,LoSpec,HiSpec, NumSites, DataSheetSize);
	}

	int DatalogInit( PDS_INT TestNumber, PDS_INT SubTestNumber, PDS_CHAR TestDesc, 
									PDS_DOUBLE LogFormat, PDS_DOUBLE TestLimitLo, PDS_DOUBLE TestLimitHi, 
									PDS_CHAR TestLimitUnits, PDS_CHAR LoLimitBin,  PDS_CHAR HiLimitBin, 
									PDS_DOUBLE LoSpec, PDS_DOUBLE HiSpec, int NumSites, int DatasheetSize)
	{
		//Determine if this is an offline workstation or an online tester.
		UTILSTAT_STR testerInfo;
		utilstat(&testerInfo,sizeof(UTILSTAT_STR));
		gbOfflineDevel = !(testerInfo.online);	

		//Save other globals.
		gdsiTestNumber=SubTestNumber;
		gdscTestName=TestDesc;
		giNumSites = NumSites;
		piDSSize = DatasheetSize;
		pdsdLoLimit=TestLimitLo;
		pdsdHiLimit=TestLimitHi;
		pdsiTestNumber=SubTestNumber;
		pdscUnits=TestLimitUnits;
		pdsdLogFormat=LogFormat;
		//Find max log format
		double maxwidth=0;
		for (int i=0; i<piDSSize;i++)
		{
			if ((int)LogFormat[i]>maxwidth)
				maxwidth=(int)LogFormat[i];
		}
		char buffer[10];
		_itoa_s((int)maxwidth,buffer,10);
		MaxLogFormat=buffer;
		MaxLogFormat=MaxLogFormat + ".5";


		SetDlogSort( NO_SORT);	//Do not sort the datalog (datalog is generated in the order it is output)  
								//MST 2011A has bugs with the other options.  TODO revisit this call in future MST versions.

		
		//Make sure the Fail Bins are properly filled in.
		if (!bVerify_DataSheet_Fail_Bins(SubTestNumber, LoLimitBin, HiLimitBin)) 
		{
			etsMessageBox("Some tests on the Datasheet have invalid fail bins assigned. \nAll tests need a fail bin, otherwise failures could go to bin 1. \nAll Fail Bins must be assigned to a hardware bin.\nSee output window for details.", MB_OK);
			return FAILURE;		//use the same return type as msLogResultInit.  
		}

		return msLogResultInit(TestNumber,SubTestNumber,TestDesc,LogFormat,TestLimitLo, TestLimitHi,TestLimitUnits,LoLimitBin,HiLimitBin,LoSpec,HiSpec);
	}

		namespace DatalogLib
		{
			BOOL gTestTimeEnable=FALSE;
			double gTestTimeCumulative =0;
		}
	

	/*********************************************************************************************************************************************For*Doxygen**//**
	Calls the DatalogFlush() function

	@deprecated
	
	Calling Datalog() with no parameters calls a completely different code set than when parameters are passed in.  This seemed to cause confusion, so the function
	was renamed as DatalogFlush(), however we needed to keep this version of the function for backwards compatibility.
	**************************************************************************************************************************************************************/
	int Datalog()
	{
		
		return DatalogFlush();
	}
	/*******************************************************************************************************************************************For*Doxygen**//**
	Datalogs all results stored in the datalog queue by Datalog() and DatalogAll().

	- Make sure the tester instruments are in a safe state before flushing the datalog.
		- If any site failed a test, the Maxim_OnFailSite function will be immediately called to power down the failing site. 
		- The Engineer has the responsibility to make sure the Maxim_OnFailSite call will not cause glitches. 
		- Place the Maxim::DatalogFlush() call only where it is safe to call the power down routine.
	- Maxim::DatalogFlush() must be called at least once before the end of the ETS_PRGFLOW_FUNC.
		- It can optionally be called multiple times in a test function if it is desired to power down a failing site at that time.
	- See MaximLib_Datalog.cpp file in the MaximLib folder for further documentation.
	- Note that in older programs this function was named Datalog(), but it caused confusion so has been renamed DatalogFlush().

	@code int DatalogFlush();  //Triggers flush of datalog queue @endcode

	@returns	Function returns SUCCESS if the test passed.  Returns FAILURE if the test results were outside of the limits.

	@remarks
			Datalog results are stored internally until the datalog is output with this function.
			This prevents the power down functions from being called until Maxim::DatalogFlush(); is called.  
			This promotes power down sequencing best practices by only allowing the power down functions to be called at designated places in the test program.
	**************************************************************************************************************************************************************/
	int DatalogFlush()
	{
		CDatalog* tempDatalog;
		int status=0;
		//int stoponfail;
		//int site;

		//stoponfail= GetETSVariable( STOP_ON_FAIL );
		//SetETSVariable (STOP_ON_FAIL,FALSE);	//disable STOP_ON_FAIL until all tests in the datalog queue are output.
		while(!QDatalog.empty())
		{
			tempDatalog=QDatalog.front();
			status=tempDatalog->Log()||status;
			delete tempDatalog;
			QDatalog.pop();
		}
		
		MissingDatalogTracker.ReportErrors();
		//SetETSVariable(STOP_ON_FAIL,stoponfail);	//restore STOP_ON_FAIL to its previous value/
		/*
		for ( site = 0; site < giNumSites; site++ )		//for all sites (active or not)
		{
			if ( msSiteStat( site ) )	//if site is valid (is not inactive, and has not failed)
			{
				if (msTestStat(site))	//if any tests at the site failed
					msFailSite(site);	//mark the site as failed.
			}
		}
		*/

		return status;
	}
	namespace DatalogLib
	{
		void FlushTestTimeQueue()
		{
			CTestTime* tempTestTime;

			while(!QTestTime.empty())
			{
				tempTestTime=QTestTime.front();
				tempTestTime->Log();
				delete tempTestTime;
				QTestTime.pop();
			}
		}
	}
	// msgroupstat does not appear to work.  But if it did, MWB thinks this function would be able to return the number of pins (per site) in the pin group.  This could be divided by NUM_SITES to get the number of pins.
	// msgroupstat works in RAIDE, but not in code.
	//int iGetNumPinsInGroup(int iGroupOrPin)
	//{
	//	USHORT * usptrResources;

	//	//USHORT * usptrResources = new USHORT[200];

	//	unsigned int uiSize = 0;
	//	int iPinCount;
	//	int status;
	//	status = msgroupstat(iGroupOrPin, usptrResources, uiSize);	//Get an array of the resources in the group or pin.  uiSize is the size of the array in bytes.
	//	iPinCount = ((uiSize/sizeof(USHORT)) - 1);	//usptrResources is an array with one element per pin in the group, plus an extra terminating (-1) element.
	//	return iPinCount;
	//}


	/************************************************************************************************************************************************************For*Doxygen**//**
	Returns the total number of digital resources in the Digital pin group set by dpingroup, or in the Vector Editor.
	
	@param	[sName] A string with the name of the DPin group.
	
	@returns	Function returns the number of digital resources in the pin group if sName is a valid group.  Returns 0 or an error if sName is not valid.

	@remarks	This returns the total number of pins in the group, counting multiple times for the same pin at different sites.
				So if the group contains one pin set with one digital resource per site (in a quad site program), and another pin set to no_site, this function will return 5.
				See also function iGetNumPinsInGroup
	**************************************************************************************************************************************************************/
	int iGetNumResourcesInGroup(LPCTSTR sName)
	{
		int iPins = dpinstat(sName, -1, NULL, MS_ALL);		
		if (iPins > 0) 
		{
			return iPins;
		}
		else 
		{
			return 0;
		}
	}

	/************************************************************************************************************************************************************For*Doxygen**//**
	Returns the total number of pins in the Digital pin group set by dpingroup, or in the Vector Editor.

	@param	[sName] A string with the name of the DPin group.

	@returns	Function returns the number of pins if sName is a valid group.  Returns 0 or an error if sName is not valid.

	@remarks
			This returns the total number of pins in the group, counting multiple times for the same pin at different sites.
			So if the group contains one pin set with one digital resource per site (in a quad site program), and another pin set to no_site, this function will return 2.
			See also function iGetNumPinsInGroup
	**************************************************************************************************************************************************************/
	int iGetNumPinsInGroup(std::string sName)
	{
		int iPinCount, iPinCountNoSite, iSite;
		int iPins = dpinstat(sName.c_str(), -1, NULL, MS_ALL);		//This returns the total number of pins in the group, counting multiple times for the same pin at different sites.
		if (iPins > 0) 
		{
			DPIN_STR* pData = new DPIN_STR[iPins];
			int* aiSites = new int[giNumSites];
			dpinstat(sName.c_str(), iPins, pData, MS_ALL);

			//Count the pins required for the PLD structure.  Pins in the group may be a combination of pins per site and pins with no site.		
			//Init count
			iPinCountNoSite = 0;
			for (iSite = 0; iSite < giNumSites; iSite++)
			{
				aiSites[iSite] = 0;
			}
			//Count number of pins at each site and number of no_site pins.
			for (int iPin = 0; iPin < iPins; iPin++)	
			{
				iSite = pData[iPin].Site;
				if ((iSite >= 0) && (iSite <  giNumSites))
				{
					aiSites[iSite]++;	//Found a pin connected to this site
				}
				else	//Found a pin that is not attached to a site
				{
					iPinCountNoSite++;
				}							
			}

			//Find the maximum number of pins connected to any site
			iPinCount = aiSites[0];	
			for (iSite = 1; iSite < giNumSites; iSite++)
			{
				if (aiSites[iSite] > iPinCount) 
					iPinCount = aiSites[iSite];
			}

			//Find the total number of pins (site + no_site)
			iPinCount = iPinCount + iPinCountNoSite;
			

			delete[] pData;	
			delete[] aiSites;	
			return iPinCount;
		}
		else 
		{
			return 0;
		}
	}
	
		namespace Limits
	{
		double GetLoLimitbyIndex(int index)
		{
			if (index <piDSSize)
				return pdsdLoLimit[index];
			else
				return DBL_MAX;
		}
		double GetLoLimitbyTestNum(int testnum)
		{
			for (int i =0; i<piDSSize; i++)
				if (pdsiTestNumber[i]==testnum)
					return pdsdLoLimit[i];
			return DBL_MAX;
		}
		double GetHiLimitbyIndex(int index)
		{
			if (index <piDSSize)
				return pdsdHiLimit[index];
			else
				return -DBL_MAX;
		}
		double GetHiLimitbyTestNum(int testnum)
		{
			for (int i =0; i<piDSSize; i++)
				if (pdsiTestNumber[i]==testnum)
					return pdsdHiLimit[i];
			return -DBL_MAX;
		}
		char* GetTestNamebyIndex(int index)
		{
			if (index <piDSSize)
				return gdscTestName[index];
			else
				return "ERROR";			
		}
		char* GetUnitsbyIndex(int index)
		{
			if (index <piDSSize)
				if (pdscUnits[index]==NULL)
					return "";
				else return pdscUnits[index];
			else
				return "ERROR";			
		}
		int GetTestNumberbyIndex(int index)
		{
			if (index <piDSSize)
				return gdsiTestNumber[index];
			else
				return 0;			
		}
	}

}

	/************************************************************************************************************************************************************For*Doxygen**//**
	For internal usage only (not exposed through the header).  Call groupgetresults and convert the result to a PLD. 
	
	@param [iExpectedSize] The expected size of the results array.  Overestimate if unknown.  The returned PLD will contain num_pins * NUM_SITES elements
	
	@returns	Function returns a new PLD with the results from the magic groupgetresults box.
	**************************************************************************************************************************************************************/
	PinListData pld_groupgetresults(int iExpectedSize)
	{
		int iReturnedSize, iNumPins, i, iSite;
		PinListData pldTemp;
		RESULTS_STR* Results;
		SiteInt siTotalCount;
		Results=new RESULTS_STR[iExpectedSize];
		iReturnedSize = groupgetresults(Results,iExpectedSize);	//Get the results from the last measurement 

		//Determine the number of pins
		iNumPins = 1;	//Assume at least on pin
		for (i = 0; i < iReturnedSize; i++)
		{
			iSite = Results[i].site;
			if (iSite >= 0)  //If valid site
			{
				siTotalCount[iSite]++;	//Count the number of pins in each site.
				if (siTotalCount[iSite] > iNumPins)
					iNumPins = siTotalCount[iSite];	//get the max number of pins
			}
		}
		
		//Convert the RESULTS_STR array to a PLD.
		pldTemp = PinListData(Results,iNumPins, iReturnedSize);
		delete[] Results;
		return pldTemp;
	}

	namespace Maxim
	{
		namespace DatalogLib
		{
			bool SiteDatalogged(int iSite) //set to true for site, return true if tested already, false if not.
			{
				bool pbOld = pbSiteDatalogged[iSite];
				pbSiteDatalogged[iSite]=true;
				return pbOld;
			}

			void SiteDatalogged()  //reset to false at beginning of program;
			{
				for (int iSite=0; iSite < giNumSites; iSite++)
				{
					pbSiteDatalogged[iSite]=false;
				}
			}
		}
	}



/************************************************************************************************************************************************************For*Doxygen**//**
Prints out error messages to the ETS Output if any blank or invalid fail bins are found on the Datasheet

@param	[TestNumber] The Test Number vector from the DataSheet
@param	[LoLimitBin] The Low Fail Bin vector from the DataSheet
@param	[HiLimitBin] The High Fail Bin vector from the DataSheet

@return		false and prints errors if blank or invalid bins are found on the DataSheet.  
@remarks	Devices that fail to a test with blank or invalid bin numbers would default to bin 1.  This function will warn the Engineer.*		
**************************************************************************************************************************************************************/
	bool bVerify_DataSheet_Fail_Bins( PDS_INT TestNumber, PDS_CHAR LoLimitBin,  PDS_CHAR HiLimitBin)
	{
		MS_BINSTAT msbinInfo;
		std::unordered_set<int> usetBinsChecked;
		std::string sLimitType;
		int iSBin;
		bool bInvalidBinFound = false;
		BOOL iProberHandler = (GetUserSwitch(GPSW_Prober_Handler));	//BOOL is actually type int
		if (Maxim::bTest_Step_Is("HW_CHECKER"))
		{
			iProberHandler = false;	//ETS Loader does not modify the PDS bins when the test step is "HW_CHECKER". See notes below.
			return true;	//Work-around while waiting for the ETS Loader to be released to production.  
							//Skip the bin check for HW_Checker test step since the Loader does not make the SEProbe modifications at that step.
							//The bin check will still run at any other test step.  
		}

		//Test cases:
		//All rows with a non-blank TestNumber must have both LoLimitBin and HiLimitBin set to a number [1, 512] (inclusive), excluding bin = 4.  
		//All LoLimitBin and HiLimitBin SBins must map to a HBin and 'P', 'F', or 'A'.  Descriptions are not checked and may be blank. 
		//In the Bin Table, HBin and "P/F/A" must both be filled in or both be blank.  It is not valid to have one blank and the other filled in. 
		//  Blanks are not allowed when the SBin is used by a test number. 
		//  SBin, HBin, "P/F/A" combinations are only checked if the SBin is actually used in a test row. 
		//SBin 1 must be set to HBin 1 and 'P'
		//SBins 2, 3, and 4 must be either:
		//  1. Blank (when not used for any tests)
		//  2. Set to 'P' and HBin = SBin.  (For downgrading: https://confluence.maxim-ic.com/display/ETS88/ETS-88+DataSheet#ETS-88DataSheet-Downgrading)
		//  No other values or combinations are valid. 
		//SBins [5, 512] (inclusive) must be either:
		//  1. Blank (when not used for any tests)
		//  2A. (For non-SEProbe handlers) set to (HBin = 7 or HBin = 8), and ("P/F/A" = 'F' or "P/F/A" = 'A')
		//  2B. (For SEProbe handlers) set to (HBin >= 5) and ("P/F/A" = 'F' or "P/F/A" = 'A')
		//        Bins 5 - 512 on a prober are remapped by Loader version 4.0 to set HBin = SBin. This is to work-around a missing feature in the SEProbe Driver.   
		//        Future prober driver updates may allow the HW bins to be set back to bins 7 or 8.  So HBin = SBin is not a requirement. 
		//TODO? enforce SBin 32 as alarm bin?


		for (unsigned int i = 0; i < LoLimitBin.size(); i++)	//Use LoLimitBin.size also for HiLimitBin.size since they come from the same Datasheet and should be equal.
		{
			//Only check for rows with test numbers to allow for Datasheets with blank rows between test blocks.  Blank rows are stored as 0 in the PDS_TESTNUM vector.
			//Blank rows are not a best practice, but many programs already have them.  Known issue: This also does not check the row if the engineer is using test number 0.
			if (TestNumber[i] != 0)	//If row has a test number on it.  
			{  
				if ((!LoLimitBin[i]) || (!HiLimitBin[i])) //If null pointer. 
				{	
					etsprintf("Test number %d has a blank fail bin.\n",TestNumber[i]);
					bInvalidBinFound = true;
					//Option to replace invalid bins with a valid bin (32 = Alarm Bin) was explored, but committee decided to print the error and halt loading instead.
					//LoLimitBin[i] = "32";	//32 = Alarm Bin.  The Template already has this bin. It goes to HW bin 8.					
				}
				else	//low and high bins are not blank, check them. 
				{		
					for (int iLimitType = 0; iLimitType <= 1; iLimitType++)	//For low and high limits
					{
						//Convert SW bin to integer. Set string for any errors.
						if (iLimitType == 0)
						{
							iSBin=atoi(LoLimitBin[i]);
							sLimitType = "low";
						}
						else
						{
							iSBin=atoi(HiLimitBin[i]);
							sLimitType = "high";
						}

						//Make sure a fail bin or device grading bin is assigned (bin 1, 2, and 3 are valid for grading. Bin 5 or higher is valid for fails).
						//The atoi function will also return 0 for non-numeric strings.  So this is also caught here.
						if (iSBin < 1 || iSBin > 512 || iSBin == 4)	//512 is the last DataSheet entry, bin 4 is not valid in a test since it would grade to bin 5. 
						{
							etsprintf("Test number %d has an invalid %s fail bin = %d.\n",TestNumber[i], sLimitType.c_str(), iSBin);
							bInvalidBinFound = true;
						}
						else
						{
							//Check to make sure software bin is mapped to a correctly configured hardware bin and P/F/A category
							//Note: this does not check all SBins.  It only checks the bins that are actually called on the DataSheet. 
							if (usetBinsChecked.count(iSBin) == 0)	//only check each SBin once. 
							{
								usetBinsChecked.insert(iSBin);
								msBinStat(0,iSBin,&msbinInfo);
								if (msbinInfo.hdw_bin == -1)
								{
									etsprintf("Software Bin Number %d is not mapped to a Hardware Bin.\n", iSBin);
									bInvalidBinFound = true;
								}
								if(msbinInfo.bin_type == 0)	
								{
									//Known issue: if HBin is blank, and 'A' is used, msbinInfo.bin_type is set to 0.  bin_type is handled properly for blank HBins and 'F' or 'P'
									//  This causes the below message to incorrectly be displayed in that case.  The solution is to fill in an HBin number. 
									etsprintf("Software Bin Number %d is not mapped to Pass, Fail, or Alarm.\n", iSBin);
									bInvalidBinFound=true;
								}					
								else if(msbinInfo.bin_type=='P')	
								{
									if(iSBin > 4)	//Only SBins 1 - 4 should be type 'P'
									{
										etsprintf("Software Bin Number %d is incorrectly mapped to P, it should be F or A.\n", iSBin);
										bInvalidBinFound=true;
									}
									else	//bins 1-4 (<1 is checked above)
									{
										if (msbinInfo.hdw_bin != iSBin)
										{
											etsprintf("Software Bin Number %d is a Pass Bin.  It must be mapped to Hardware Bin Number %d.\n", iSBin, iSBin);
											bInvalidBinFound=true;
										}
									}
								}
								else	// 'F' or 'A'
								{									
									if(iSBin > 4)	//Bins 5 - 512 (>512 is checked above)
									{
										if (!iProberHandler) //non SEProbe
										{
											if(!(msbinInfo.hdw_bin == 7 || msbinInfo.hdw_bin == 8))	
											{
												etsprintf("Software Bin Number %d is a Fail or Alarm bin.  It must be mapped to Hardware Bin 7 or 8.\n", iSBin);
												bInvalidBinFound=true;
											}
										}
										else	//SEProbe (so far, only SEProbe sets iProberHandler to true)
										{
											if(msbinInfo.hdw_bin < 5)	//Not restricting HBins > 512 for SEProbe, since they may be valid software bins. 
											{
												etsprintf("Software Bin Number %d is a Fail or Alarm bin.  It cannot be mapped to Hardware Bin %d.\n", iSBin, msbinInfo.hdw_bin);
												bInvalidBinFound=true;
											}
										}
									}
									else	//bins 1-4 (<1 is checked above).  
									{
										etsprintf("Software Bin Number %d is a Fail or Alarm bin.  It must be mapped to a Pass bin.\n", iSBin);
										bInvalidBinFound=true;
									}																		
								}
							}
						}
					}
				}
			}			
		}
		return !bInvalidBinFound;
	}

typedef std::unordered_map<std::string, double> mapStringDouble;
namespace Maxim
{
	namespace Limits
	{
		double STDFUnitsScaleToBase(int iIndex)
		{
			static bool bLoaded=false;
			if (!bLoaded)
			{
				bLoaded=true;
				mapStringDouble mapUnitsToBase;
				//"V"	 VOLTS	 0
				mapUnitsToBase["V"]=1;
				//"Volt"	VOLTS	0
				mapUnitsToBase["Volt"]=1;
				//"Volts"	VOLTS	0
				mapUnitsToBase["Volts"]=1;
				//"mV" VOLTS	3
				mapUnitsToBase["mV"]=1.E-3;
				//"uV"	VOLTS	6
				mapUnitsToBase["uV"]=1.E-6;
				//"nV"	VOLTS	9
				mapUnitsToBase["nV"]=1.E-9;
				//"pV"	VOLTS	12
				mapUnitsToBase["pV"]=1.E-12;
				//"fV"	VOLTS	15
				mapUnitsToBase["fV"]=1.E-15;
				//"A"	AMPS	0
				mapUnitsToBase["A"]=1;
				//"Amp"	AMPS	0
				mapUnitsToBase["Amp"]=1;
				//"Amps"	AMPS	0
				mapUnitsToBase["Amps"]=1;
				//"mA"	AMPS	3
				mapUnitsToBase["mA"]=1.E-3;
				//"uA"	AMPS	6
				mapUnitsToBase["uA"]=1.E-6;
				//"nA"	AMPS	9
				mapUnitsToBase["nA"]=1.E-9;
				//"pA"	AMPS	12
				mapUnitsToBase["pA"]=1.E-12;
				//"f"	AMPS	15
				mapUnitsToBase["fA"]=1.E-15;
				//"s"	SECONDS	0
				mapUnitsToBase["s"]=1;
				//"sec"	SECONDS	0
				mapUnitsToBase["sec"]=1;
				//"secs"	SECONDS	0
				mapUnitsToBase["secs"]=1;
				//"ms"	SECONDS	3
				mapUnitsToBase["ms"]=1.E-3;
				//"us"	SECONDS	6
				mapUnitsToBase["us"]=1.E-6;
				//"ns"	SECONDS	9
				mapUnitsToBase["ns"]=1.E-9;
				//"ps"	SECONDS	12
				mapUnitsToBase["ps"]=1.E-12;
				//"fs"	SECONDS	15
				mapUnitsToBase["fs"]=1.E-15;
				//"GHz"	HERTZ	-9
				mapUnitsToBase["GHz"]=1.E9;
				//"MHz"	HERTZ	-6
				mapUnitsToBase["MHz"]=1.E6;
				//"KHz"	HERTZ	-3
				mapUnitsToBase["KHz"]=1.E3;
				//"Hz"	HERTZ	0
				mapUnitsToBase["Hz"]=1;
				//"%"	PERCENT	2	
				mapUnitsToBase["%"]=1.E-2;					
				vdUnitsToBase.resize(piDSSize);
				for (int iRow=0; iRow<piDSSize;iRow++)
					{
					std::string sUnits;
					sUnits=Maxim::Limits::GetUnitsbyIndex(iRow);
					if (sUnits.empty())
						vdUnitsToBase[iRow]=1;													
					else if (mapUnitsToBase.count(sUnits)>0)
						vdUnitsToBase[iRow]=mapUnitsToBase[sUnits];
					else vdUnitsToBase[iRow]=1;		
					}	
			}
			return vdUnitsToBase[iIndex];
		}
	}
}