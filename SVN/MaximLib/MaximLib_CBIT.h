//DO NOT EDIT THIS FILE
/*** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-
*                                                                            
*	Source title:		Maximlib_CBIT.h                                                                           		  
*	URL:				$URL: https://svn.maxim-ic.com/svn/ets/test_programs/AP89/AP89_FT/Trunk/MaximLib/MaximLib_CBIT.h $
*   Last Modified by:	$LastChangedBy: govit.pimthong $                                       
*	Date:				$Date: 2017-03-09 12:55:55 +0700 (Thu, 09 Mar 2017) $                                                
*   Current Rev:		$Revision: 61735 $
*                                                                            
*	Description:
*		Maxim library header file for CBIT
*		Maxim library written and maintained by:		
*			Brad Sitton (Brad.Sitton@Maxim-IC.com
*			Patrick Hayes (Patrick.Hayes@Maxim-IC.com)	                 
*			Mark Bruening (Mark.Bruening@Maxim-IC.com)                                                                            
*
*   Revision History                                                    
*                                                                            
**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****/
//DO NOT EDIT THIS FILE

/**********************************************************************************************************************************************For*Doxygen**//**
@file	Maximlib_CBit.h
@brief	Maxim library file for CBIT
**************************************************************************************************************************************************************/

#ifndef MAXIMLIB_CBIT_H
#define MAXIMLIB_CBIT_H


#include <string>
#include <algorithm>
#include <iostream>
#include <fstream>
#include <iomanip>
#include <sstream>
#include <iterator>
#include <functional>
#include <map>
#include <set>
#include <vector>
#include <stdarg.h>


namespace Maxim {
	namespace CBits {

/************************************************************************************************************************************************************For*Doxygen**//**
@page quickStartCBit CBit Quick Start

@details
# Overview #
- Extend the capabilities of the standard ETS-88 function set
	- Control the I2C relays using standard ETS-88 functions
	- Keeps track of relay settling time on the fly so you don't have to calculate delay times in your head, just make a simple function call to wait until all relays are settled. 
- Optimizes relay control
	- Will not waste time closing/opening a relay that is already in the proper state
	- Will make all changes on a single relay driver at the same time. 
- Flexibility
	- Easily add your own relays to the relay library (needed to provide specs for open/close time)
	- Allows you to add drivers for new cbit driver chips, although we encourage use of the PCA9671 whenever practical
	- cbit_open and cbit_close commands will now take strings, or C++ sets as parameters. 

@note This library is in no way related to the I2C_Control functions that people used for I2C relays before this library existed.

@author [Brad Sitton](mailto:Brad.Sitton@maximintegrated.com "Email Brad")

@tableofcontents

@section enableCBitLibrary Enable CBit Library
- Copy the latest version of the Maxim ETS-88 Libraries
- Start using the standard ETS-88 commands to control the PCA9671 chips on the i2c bus
- Define groups of relays if needed.
-- This is most useful when dealing with i2c relays which can't be handled in the pin map editor.

@section exampleSection Example Code

The objective of this code is to set up K200 to control 4 CBits which are associated with separate sites in a quad site solution and then perform a few basic relay commands.

=====
Perform in Globals.h
@code
	extern int K200;
@endcode

====
Perform in Globals.cpp
@code
	int K200;
@endcode

====
Perform in Maxim_UserInit()
@code
	//Load all CBits that are part of a given group into a single vector
	std::vector<int> viK200Group;
	viK200Group.push_back(1000);
	viK200Group.push_back(1001);
	viK200Group.push_back(1002);
	viK200Group.push_back(1003);
 
	//Define K200 using the vector you just created
	K200 = Maxim::CBits::MaximCBitGroupSet("PullUpK200", viK200Group);

	//Indicate which CBits need to be associated with a '''single''' site. 
	//This only needs to be done if the CBit was set up outside of the pin map editor, for example I2C CBits.
	//If you do not perform this step, then the CBits will be associated with all sites and will continue to
	//open/close even if the site has become inactive
	Maxim::CBits::SetCBitSite(1000, 0); //CBit 1000 only applies to site 0
	Maxim::CBits::SetCBitSite(1001, 1); //CBit 1001 only applies to site 1
	Maxim::CBits::SetCBitSite(1002, 2); //CBit 1002 only applies to site 2
	Maxim::CBits::SetCBitSite(1003, 3); //CBit 1003 only applies to site 3
@endcode

====
The following block represents extended functions that typically are not needed
@code
	//Indicate which CBits need to be associated with '''multiple''' sites. 
	//This only needs to be done if the CBit was set up outside of the pin map editor, for example I2C CBits.
	vector<int> viSiteGroup;
	viSiteGroup.push_back(0);
	viSiteGroup.push_back(1);
	Maxim::CBits::SetCBitSite(1004, viSiteGroup); //CBit 1004 is active on sites 0 and 1
	Maxim::CBits::SetCBitLogic(1004, CBitLogic0IsRelayOpen); // Setting logic for CBit 2004.

	// Define the type of relays associated with each CBit
	// Allows the use of WaitUntilRelaysSettle for automatic calculation of relay delay times.
	// Ideally this will line up with your schematic and it may be possible to automatically generate this list.
	// Optional step
	Maxim::CBits::AssignCBitToRelay(K200, "70-98140500-00");  // This assumes all relays in a group are of the same type.
															  // Otherwise you need to set the types on a CBit by CBit basis.
	Maxim::CBits::AssignCBitToRelay(K26, "70-98140500-00");   // Assumes K26 was defined in the pin map editor.
	Maxim::CBits::AssignCBitToRelay(K27, "70-98140500-00");   // Assumes K27 was defined in the pin map editor.
@endcode

====
Sample code using the CBits defined above

@code
	//************************************
	// Perform in your test functions
	//************************************

	cbitclose(K200);
	cbitopen(K26, K27);

	//Set voltages, do whatever else is needed
	Maxim::CBits::WaitUntilRelaysSettle();  // Defaults to 5000uS if you have not defined the type of relay associated with each CBit

	// You can mix regular CBits and I2C CBits
	cbitopen(K26, K200);
	cbitclose(K27);
	Maxim::CBits::WaitUntilRelaysSettle(1000 us_f);  // Waits an extra 1000uS in addition to the amount of time required for relays to settle.
												//        Useful if there is a servo loop or capacitor that needs to settle after the relays settle.
@endcode

@section defaultAssignmentSection Default CBit Assignments

- The following relay drivers are automatically set up in software and should cover the needs of most projects.
-- In order to use the optional drivers, you need to add the PCA9671 driver chips to your test hardware and wire them such that their addresses conform to the standard below.
- If you have additional relay drivers, then you will need to make a call to DefineRelayDriver.
- __Recommend__ using the following design if you need to add relay drivers to your contactor board: [I2C CBit Daughter Card](http://ezlib.maxim-ic.com/archive/hw/173828/)
- [Available I2C Addresses](https://confluence.maxim-ic.com/download/attachments/25103899/ETS88_I2C.pdf)


CBit Values | I2C Address | Location   | SRM Adapter CBit Values
----------- | ----------- | ---------- | ----------------------- 
0-31        | N/A         | Tester     | N/A
1000-1015   | 0x20        | Load Board | N/A
1016-1031   | 0x22        | Load Board | N/A
1032-1047   | 0x24        | Load Board | N/A
1048-1063   | 0x26        | Optional   | 2000-2015
1064-1079   | 0x28        | Optional   | 2016-2031
1080-1095   | 0x2A        | Optional   | 2032-2047
1096-1111   | 0x2C        | Optional   | 2048-2063
3000-3015   | 0x30        | Optional   | N/A
3016-3031   | 0x32        | Optional   | N/A
3032-3047   | 0x34        | Optional   | N/A
3048-3063   | 0x36        | Optional   | N/A
3064-3079   | 0x38        | Optional   | N/A
3080-3095   | 0x3A        | Optional   | N/A
3096-3111   | 0x3C        | Optional   | N/A
3112-3127   | 0x3E        | Optional   | N/A
5000-5015   | 0x50        | Optional   | N/A
5016-5031   | 0x52        | Optional   | N/A
5032-5047   | 0x54        | Optional   | N/A
5048-5063   | 0x56        | Optional   | N/A
5064-5079   | 0x58        | Optional   | N/A
5080-5095   | 0x5A        | Optional   | N/A
5096-5111   | 0x5C        | Optional   | N/A
5112-5127   | 0x5E        | Optional   | N/A


@warning Address 0x2E should not be used on test hardware as it is being used by Maxim defined low level functions on the load board.

@section debugTipsSection Control I2C CBits while Trapped!!!
__Want to know the state of your CBit without constantly updating the Raid window?__
- Place the following into your watch window: Maxim::CBits::Extended::maximCBits.mapCBitStates
- By default, the designators are of the form "CBIT 14", however you can change this to anything you would like, for example "K14a". 
-- Use: Maxim::CBits::SetCBitDesignator(14, "K14a");
- '''Note:''' Relay states will not be updated if you open/close them using Raide since Raide was developed by Teradyne and does not use the CBit library.

__Want to open/close I2C CBits while you are trapped at a break point?__
- From Visual Studio top menu, select Debug->Windows->Immediate
-- Shortcut is Ctrl-Alt-I
- Enter a command such as cbitclose(1012) or cbitclose(YourRelayName)
- This requires that you installed CBit library files on or after 2/1/13

__Note about immediate mode and cbit groups/names defined in pin map editor__
- Suppose in the pin map you defined a cbit as K2
-- cbitclose(K2) will not work in the immediate window
-- cbitclose(K2.m_nPinNum) will work in the immediate window!!!
-- '''Caution''' the .m_nPinNum extension is only for this special instance
--- It will generate an error for I2C CBits, integers (i.e. cbitclose(5)), or many other things
--- It will generate an error if you try to use it in your test program.
--- It is only for names defined in the pin map editor in the immediate window.
--- I did not make the rules, just discovered the work around, if anyone has a better solution let me know -- [Brad Sitton](mailto:brad.sitton@maximintegrated.com)

**************************************************************************************************************************************************************/


		enum RelayDriverType {RelayDriverETS, RelayDriverGroup, RelayDriverPCA9671, RelayDriverUnknown};

		// Set up some standard C functions as an interface, which may be less intimidating for the average test engineer
		void SetUpCBits();
		int  GetRelaySpecifications(std::string sMaximInventoryNumber);
		void DefineRelaySpecifications(std::string sMaximInventoryNumber, unsigned long ulWaitUSOpen, unsigned long ulWaitUSClose);
		void DefineRelayDriver( std::string sDesignator, RelayDriverType relayDriver, std::vector<int> viResources, int iDriverAddress=-1);
		void WaitUntilRelaysSettle(unsigned long ulExtraWaitUS = 0);
		void AssignCBitToRelay(int iCBitNumber, std::string sRelayType);

		void SetCBitDesignator(int iCBitNumber, std::string sCBitDesignator); 

		void SetCBitSite(int iCBit, std::vector<int> iSiteList);
		void SetCBitSite(int iCBit, int iSite);

		void RelayDriverSetup();

		int MaximGetCBitState(int);

		int MaximCBitGroupSet( std::string sDesignator, std::vector<int> iRelayList);


		std::stringstream OutputAllCBitStates(std::string sMessage="");  // Will send all relay states to the output as well as a string stream


		namespace Extended {  // Low level functions that are not expected to be used very often

		/// Used to differentiate between normally open or normally closed relays.  
		/// See Maxim::CBits::Extended::SetCBitLogic for more information
		enum eCBitLogic 
		{  /// Used when relay will be closed when CBit is set to 0 (ground)
			CBitLogic0IsRelayClosed, 
			/// Used when relay will be open when CBit is set to 1
			CBitLogic0IsRelayOpen    
		};

		void CBitSiteMapCleanUp();

		class RelayProperties{
// Stores the properties associated with a specific type of relay.  In general this should be information from the relay datasheet.
private:	
	std::string		sPartNumber;					// Maxim inventory number for the specific relay
	unsigned long	ulWaitUSOpen, ulWaitUSClose;	// Worst case open and close times for the relay, preferably from the datasheet.
	
public:

	RelayProperties( std::string sPartNumber = "UNKNOWN", unsigned long ulWaitUSOpen = 5000, unsigned long ulWaitUSClose = 5000);  // Constructor for Relay Properties

	unsigned long	GetWaitUSOpen();	// Returns the number of uS to open a relay or switch
	unsigned long	GetWaitUSClose();	// Returns the number of uS to close a relay or switch
};
	
class RelayDriver{
// Serves as a base class to store the MaximCBitGroupRelayDriverCommon properties and design the common methods associated with a specific relay driver.   
// Currently virtual commands are used to make ETS tester, i2c and group relay drivers use a common function set.
protected:
	std::string			msDesignator;	// Unique name that identifies a relay driver.  Frequently this will be the designator from the PCB schematic.
	RelayDriverType		mDriverType;	// THIS MAY BE REDUNDANT AND THEREFORE DELETED IN FUTURE VERSIONS.  Lets us know if the relay driver type is i2C, ETS tester, group ....
	bool				mbPendingAction;	// Set true if there is register information waiting to be written to the relay driver.  This allows user to set all register states 
										//   and then issue a single write command rather than writing to driver every time a cbit is changed.  Will reduce overall test time.
	unsigned int		muiRegister;		// Register setting
	unsigned int		muiRegisterMask;	// Bits set to 1 correspond to Register bits where 1 is relay open instead of closed.  Not using this, may use in the future.
	unsigned int		muiPendingRegister;	//	Register setting that will be applied on the next apply pending.
	std::map<int, int>	mmapiCBitList;	//	Map of all CBits controlled by the driver.  first is CBit Number, second is position in mRegister.

public:
	RelayDriver();	//Default constructor

	virtual int					ApplyPending();			// Writes data from tester memory to the relay driver.
	virtual unsigned int		GetAddress();			// Returns the address of the relay driver.  Not sure if this function will be used.
	bool						GetPendingAction();		// Checks to see if the relay driver has data waiting to be written.
	unsigned long				GetPendingRelaySettleTime(); // Tells how long it will take for all pending relays for the given driver to settle, once the close relay command is given.
	RelayDriverType				GetRelayDriverType() {return mDriverType;} // Returns the relay driver type.  This might be redundant information.  It is only used in one place at this time.
	std::string					GetDesignator() { return msDesignator;} // Returns the relay driver name/designator

	std::stringstream			OutputRegister(std::string sPrefix, int msb, int lsb, int register);  // Will facilitate debug.  Writes register settings to the ETS output screen and 
																								//   returns a string stream allowing output to be stored to a file.
	virtual void				PrepareToCloseRelayList() {;};		// Updates cbits that are part of the group to go to a closed state the next time pending actions are applied.
	virtual void				PrepareToOpenRelayList() {;};		// Updates cbits that are part of the group to go to a open state the next time pending actions are applied.
	virtual void				SetPendingAction(bool state, unsigned int uiCBitNumber=-1, int iState=-1);	// Sets a member variable to indicate if there is CBit data waiting to be written to the driver.
	virtual std::stringstream	VerifyCBitsInMemory();			// Read relay driver hardware and update memory in case they get out of sync.
																			//   Automatically does etsprintf, and returns a stream so you can put into a file.
	virtual int					GetState() { return -1;};		// Required for getting the state of cbits in a group driver.  This serves as a place holder and is superceded
																//	 by the appropriate GetState function.
	void						SetRelayType(std::string sRelayType);
	void						PendingApplied();				// Will call PendingApplied for every CBit that is in mmapiCBitList, which in turn will update the CBit state variable
};

class TesterRelayDriver : public RelayDriver{
// Treating the tester as just another relay driver, like a chip on the test fixture, helps create a more consistent library of relay functions.
private:
	std::set <int> msetiCBitList;	// List of cbits that are controlled by the tester.  
	char	mcCBitBank;
public:
	TesterRelayDriver() {;};    // Map container requires a default constructor with no parameters
	TesterRelayDriver(std::string sDesignator, std::vector<int> viCBitList, char cBitBank = ' ');	// Typical constructor.
	virtual  int				ApplyPending();			// Writes data from tester memory to the relay driver.
	virtual std::stringstream	VerifyCBitsInMemory();	// Read relay driver hardware and update memory in case they get out of sync.
														//   Automatically does etsprintf, and returns a stream so you can put into a file.
};


class PCA9671RelayDriver : public RelayDriver {
// Relay driver for PCA9671, which is used on the load board and recommended for contactor board when additional cbits are needed.
private:
	unsigned int muiChipAddress;	// The device address that is used when communicating with the chip via i2C.
	unsigned int miCBitList[16]; // List of all CBits that are controlled by a specific chip.

public:

	PCA9671RelayDriver() {;};    // Map container requires a default constructor with no parameters
	PCA9671RelayDriver(std::string sDesignator, std::vector<int> viCBitList, unsigned int address = 0);

	virtual int					ApplyPending();	// Writes data from tester memory to the relay driver.
	virtual unsigned int		GetAddress();	// Returns the address of the relay driver.  Not sure if this function will be used.
	virtual std::stringstream	VerifyCBitsInMemory();	// Read relay driver hardware. Automatically does etsprintf, and returns a stream so you can put into a file.
};

class MaximCBitGroupRelayDriver : public RelayDriver {
// Virtual relay driver for a group of cbits.  This function will in turn call the relay drivers for the specific cbits that are part of the CBit group.
	// Driver designator should be the same as the corresponding CBit designator.
	int miGroupCBitNumber;		// CBit number assigned to the this group.  This aligns with a similar parameter in the ETS provided msgroup command.
	std::set<int> msetiCBitList;	// List of cbits that belong to the group.  This may be other groups, tester cbits, or cbits from relay drivers on test fixture.
	std::string mAllGroupCBits;		// A list of all CBits that are part of the group
	std::string mTesterGroupCBits;	// A subset of mAllGroupCBits, listing only CBits that are controlled directly be tester cbits.

public:
	MaximCBitGroupRelayDriver(std::string sDesignator = "UNKNOWN", int iCBitNumber=-1);// Creates a new relay group and adds it to mapRelayDriver.
	MaximCBitGroupRelayDriver(std::string sDesignator, std::vector<int> viCBitList, int iCBitNumber); // Preferred constructor because it includes group resources as a std::vector
	MaximCBitGroupRelayDriver(std::string sDesignator, std::string cBitList, int iCBitNumber); // Don't use.  Considering deleting.  Only keeping because much work went into the function and it might be needed in the future.
	void 	MaximCBitGroupRelayDriverCommon(std::string sDesignator = "UNKNOWN", int iCBitNumber = -1);// Code that is common to each of the constructors

	void						PrepareToCloseRelayList();		// Updates cbits that are part of the group to go to a closed state the next time pending actions are applied.
	void						PrepareToOpenRelayList();		// Updates cbits that are part of the group to go to a open state the next time pending actions are applied.
	virtual void				SetPendingAction(bool state);	// Updates miPendingState for the appropriate relay driver for each cbit driver data needs to change.
	virtual std::stringstream	VerifyCBitsInMemory();			// Read relay driver hardware. Automatically does etsprintf, and returns a stream so you can put into a file.
	virtual int					GetState();						// Required for getting the state of cbits in a group driver.  If active CBits in the group do not match, then -1 will be returned.

};


class CBitProperties {

	friend class AllCbits;

private:
	unsigned int	muiCBitNumber;	// Integer designator of the mapCBits.  For example CBIT1 has a value of 1
	std::string		msDesignator;	// String designator of the cBit.  By default this will be "CBIT" & muiCBitNumber.  Ideally it will match the designators from your schematic.
	std::string		msRelayDriver;	// Relay driver designator so we can link to the exact relay driver chip.  
	std::string		msRelayType;		// Indicates the type of relay associated with the cbit, so open/close times can be looked up.  Name should match Maxim inventory number for the component.

	std::set<int>	mSite;			// A list of all sites that the CBit is associated with
	eCBitLogic		mCBitLogic;		// Tracks whether cbit low causes the relay to open or to close.
	int				miState;			// Should contain the current state of the cBit that is observed at the test fixture.  
	int				miPendingState;	// Contains the state that will be applied after the "ApplyPending" command is executed.
	RelayDriver     *mRelayDriver;


 public:
	void			DoNotUseSetState(int bitValue); // This function should be used with extreme caution.  It changes the cbit in memory but has no provisions to actually change the 
													//   hardware to match.  Ideally it would have been inaccessible to the user.

	CBitProperties (int cBitNumber, std::string sRelayDriver, Maxim::CBits::Extended::RelayDriver *relayDriver);
		// Used by the relay driver constructors to create a CBit that will point to the Relay Driver
	CBitProperties (int cBitNumber=-1, std::string sRelayDriver="UNKNOWN", std::string relayType = "DEFAULT", int site=-1,  std::string designator="DEFAULT", 
						eCBitLogic logic=CBitLogic0IsRelayOpen, int state=-1);
		// Allows a single integer to be passed as a site
//	CBitProperties (int cBitNumber, std::string sRelayDriver, std::string sRelayType, std::set<int> site,  std::string designator="DEFAULT", 
//						eCBitLogic logic=CBitLogic0IsRelayOpen, int state=-1);
		// Allows a set of integers to be passed as a site for cbits that operate on multiple sites.
	void CBitPropertiesCommon (int cBitNumber, std::string sRelayDriver, std::string sRelayType, std::set<int> site,  std::string designator="DEFAULT", 
						eCBitLogic logic=CBitLogic0IsRelayOpen, int state=-1);
	// Allows a common set of code to be called by multiple versions of the constructor

	void CBitSiteCleanUp();				// Changes any -1 values to all site for all CBits.  Only should be done once per program load.
	unsigned int	GetCBitNumber();	
	std::string		GetCBitDesignator();
	std::string		GetRelayDriver();
	RelayDriver*	GetRelayDriverPointer() {return mRelayDriver;};
	std::string		GetRelayType();
	eCBitLogic		GetCBitLogic();
	int				GetState();
	int				GetPendingState();
	unsigned long	GetWaitUSOpen();		// Returns relay open time based on msRelayType.
	unsigned long	GetWaitUSClose();		// Returns relay close time based on msRelayType.

	int				IsCBitActive();				// Checks to see if the cBit is still active

	void			SetRelayType(std::string relayType);
	void			SetDesignator(std::string cBitDesignator) {msDesignator = cBitDesignator;}
	void			SetSite(int iSite){if(mSite.count(-1) == 1) mSite.erase(mSite.find(-1)); mSite.insert(iSite);}
	void			SetSite(std::set<int> site){mSite = site;}
	void			SetCBitLogic(eCBitLogic eLogic) { this->mCBitLogic = eLogic;}
	void			PendingApplied();		// Updates miState = miPendingState after data from miPendingState has been written to the appropriate relay driver.
	void			PrepareToCloseRelay();	// Sets miPendingState to the value which will close the relay.
	void			PrepareToOpenRelay();	// Sets miPendingState to the value which will open the relay.
	void			PrepareToSetCBit(int bitValue);	// Sets miPendingState to the value which will set CBit to the state indicated by bitValue.
	
}; // class CBitProperties

class MaximCBits  {
	friend class CBitProperties;

private:
	unsigned long mulWhenRelaysWillSettle;	// Utilizes ltime(7) to keep track of when all relays will finish settling based on specifications in mapRelayTypes.
	unsigned long mulTotalRelayWaitTime;		// Keeps track of how much time was spent waiting in the WaitForRelaysToSettle function.
	bool	mbVintageMode;
	std::set<Maxim::CBits::Extended::RelayDriver*> setRelayDriversWithPendingActions;

public:

	std::map<int, CBitProperties > mapCBits;    // CBit map based on CBit number which is the standard way to open/close relays on ETS-88
	std::map<std::string, CBitProperties*> mapCBitDesignators; // CBit map based on text designator.
	std::map<std::string, int> mapCBitStates;				   /// Map to the CBit States, which is convenient to use when debugging.


	MaximCBits();	// Default constructor.  Will initialize as much as possible for ETS and load board based cbits.

	void AddPendingRelayDriver(Maxim::CBits::Extended::RelayDriver* relayDriver) { setRelayDriversWithPendingActions.insert(relayDriver); }
	bool IsVintageMode() {return mbVintageMode;};
	bool SetVintageMode(bool bMode) {mbVintageMode = bMode;};
	int ApplyPending();		// Checks each relay driver to see if there are pending actions and then applies if necessary, while avoiding the writing of data
										//   if no data in the driver is changing.
	unsigned int Close(std::set<int>);	// Closes the CBits passed in
	void CloseAllRelays();				// Close all relays
	int DefineCBit(unsigned int uiCBitNumber, std::string sDesignator, std::string sRelayDriver); // Taking a more streamlined approach without all of these parameters: , std::string sRelayType, int site,  eCBitLogic eLogic, int iState);
		// Used to set up all the critical information related to a CBit
	unsigned int Open(std::set<int>);	// Opens the CBits passed in
	void OpenAllRelays();				// Open all relays
	void ResetRelayWaitTime();			// Resets mulWhenRelaysWillSettle to 0.  This needs to be executed at the beginning of each device.
	void SetAllCBits(int cBitState);	// Sets all cbits to the indicated state
	void UpdateRelaySettleTimeStamp(unsigned long usToSettle);	// Adds uSToSettle to the current reading of ltime(7) and then updates mulWhenRelaysWillSettle.
	void WaitForRelaysToSettle();		// Will wait for all relays to settle based on when they were closed and the specifications provided in relayType.

};

// Set up Maxim wrappers for all ETS CBIT functions
	// Put wrappers around the open and close functions allowing multiple input methods
	int Maximcbitclose( int iX0, int iX1=-1, int iX2=-1, int iX3=-1, int iX4=-1, int iX5=-1, int iX6=-1, int iX7=-1, int iX8=-1, int iX9=-1, int iX10=-1, int iX11=-1, int iX12=-1, int iX13=-1, int iX14=-1, int iX15=-1 );
	int Maximcbitclose( std::string sCBitList);
	int Maximcbitclose( std::set<int> cBitList);
	int Maximcbitclose( std::vector<int> cBitList0=std::vector<int>(), std::vector<int> cBitList1=std::vector<int>(), std::vector<int> cBitList2=std::vector<int>(), std::vector<int> cBitList3=std::vector<int>(), 
			std::vector<int> cBitList4=std::vector<int>(), std::vector<int> cBitList5=std::vector<int>(), std::vector<int> cBitList6=std::vector<int>(), std::vector<int> cBitList7=std::vector<int>() );
	int Maximcbitopen( int iX0, int iX1=-1, int iX2=-1, int iX3=-1, int iX4=-1, int iX5=-1, int iX6=-1, int iX7=-1, int iX8=-1, int iX9=-1, int iX10=-1, int iX11=-1, int iX12=-1, int iX13=-1, int iX14=-1, int iX15=-1 );
	int Maximcbitopen( std::string sCBitList);
	int Maximcbitopen( std::set<int> cBitList);
	int Maximcbitopen( std::vector<int> cBitList0=std::vector<int>(), std::vector<int> cBitList1=std::vector<int>(), std::vector<int> cBitList2=std::vector<int>(), std::vector<int> cBitList3=std::vector<int>(), 
			std::vector<int> cBitList4=std::vector<int>(), std::vector<int> cBitList5=std::vector<int>(), std::vector<int> cBitList6=std::vector<int>(), std::vector<int> cBitList7=std::vector<int>() );


	// Next functions control 16 bits at a time.  They are used to maintain compatibility with the cbita and cbitb functions.  Not sure if they will get used much.
	int Maximcbitx_set( int iCBitWord, int iRegOffset);
	int Maximcbitx_close( int iCBitWord, int iRegOffset);
	int Maximcbitx_open( int iCBitWord, int iRegOffset);

	int Maximcbita_close( int iCBitWord);
	int Maximcbita_open( int iCBitWord);
	int Maximcbita_set( int iCBitWord);

	int Maximcbitb_close( int iCBitWord);
	int Maximcbitb_open( int iCBitWord);
	int Maximcbitb_set( int iCBitWord);

	int Maximcbitc_close( int iCBitWord);
	int Maximcbitc_open( int iCBitWord);
	int Maximcbitc_set( int iCBitWord);

	int Maximcbitd_close( int iCBitWord);
	int Maximcbitd_open( int iCBitWord);
	int Maximcbitd_set( int iCBitWord);

		}//namespace Extended
	} // namespace CBits


} //namespace Maxim

namespace Maxim
{
	namespace CBits
	{
		/************************************************************************************************************************************************************For*Doxygen**//**
		@brief	It is not expected that functions in the Extended namespace will be used very often by engineers, but they are available if needed.
						in some cases they are lower level functions used by the library, but not directly called by the test engineer.

		**************************************************************************************************************************************************************/
		namespace Extended
		{
			// Set up general functions
			void StringRangeToList(std::string &input);   
			std::set <int> StringToCBitSet(std::string sCBitList);
			std::vector<std::string> CSVStringToVector(std::string csvString);  // Splits a CSV string into tokens and returns in a vector

				// Set up global variables.
			extern std::map <std::string, Maxim::CBits::Extended::RelayProperties> mapRelayTypes;

			extern std::map <std::string, Maxim::CBits::Extended::RelayDriver*> mapRelayDriver; // Base class for all relay drivers

			extern Maxim::CBits::Extended::MaximCBits maximCBits; 

			void SetCBitLogic(int iCBit, eCBitLogic eLogic);
			void SetCBitLogic(std::vector<int> viCBit, eCBitLogic eLogic);
		} //Extended
	} //namespace CBits
} //namespace Maxim




#endif

