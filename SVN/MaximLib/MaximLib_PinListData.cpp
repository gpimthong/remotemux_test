//DO NOT EDIT THIS FILE
/*** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-
*                                                                            
*	Source title:		Maximlib_PinListData.CPP                                                                            		  
*	URL:				$URL: https://svn.maxim-ic.com/svn/ets/test_programs/AP89/AP89_FT/Trunk/MaximLib/MaximLib_PinListData.cpp $
*   Last Modified by:	$LastChangedBy: govit.pimthong $                                       
*	Date:				$Date: 2017-03-09 12:55:55 +0700 (Thu, 09 Mar 2017) $                                                
*   Current Rev:		$Revision: 61735 $
*                                                                            
*	Description:  
*		Maxim library file for PinListData
*		Maxim library written and maintained by:								 
*			Patrick Hayes (Patrick.Hayes@MaximIntegrated.com)	                 
*			Mark Bruening (Mark.Bruening@MaximIntegrated.com)                                                                            
*
*   Revision History
*		See Maximlib.h file.
*                                                                            
**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****/
//DO NOT EDIT THIS FILE


	
/************************************************************************************************************************************************************For*Doxygen**//**
////////////////////PinListData Class Definition                                                         
**************************************************************************************************************************************************************/
	PinListData::PinListData()  //default constructor
	{
		RESULTS_STR results;
		init_STR(results);
		piNumPins=1;
		vecPinData = vector<RESULTS_STR> (giNumSites, results);
	}

	PinListData::PinListData(const PinListData &pldCopy)	//Copy constructor
	{
		piNumPins=pldCopy.piNumPins;
		vecPinData= pldCopy.vecPinData;

	}

		//Cast SiteBool to PinListData
	PinListData::PinListData(const SiteBool& sbCopy)
	{
		RESULTS_STR results;
		init_STR(results);
		piNumPins=1;
		vecPinData = vector<RESULTS_STR> (giNumSites, results);

		for (int iSite=0; iSite<giNumSites;iSite++)
		{
			vecPinData[iSite].value=sbCopy[iSite];
			if (msSiteStat(iSite))
			{
				vecPinData[iSite].site=iSite;
				vecPinData[iSite].resource=PLD_UNKNOWN_RESOURCE;
			}
		}
	}
	
		//Cast SiteDouble to PinListData
	PinListData::PinListData(const SiteDouble& sdCopy)
	{

		RESULTS_STR results;
		init_STR(results);
		piNumPins=1;
		vecPinData = vector<RESULTS_STR> (giNumSites, results);

		for (int iSite=0; iSite<giNumSites;iSite++)
		{
			vecPinData[iSite].value=sdCopy[iSite];
			if (msSiteStat(iSite))
			{
				vecPinData[iSite].site=iSite;
				vecPinData[iSite].resource=PLD_UNKNOWN_RESOURCE;
			}
		}
	}
	
	//Cast SiteInt to PinListData
	PinListData::PinListData(const SiteInt& siCopy)
	{

		RESULTS_STR results;
		init_STR(results);
		piNumPins=1;
		vecPinData = vector<RESULTS_STR> (giNumSites, results);

		for (int iSite=0; iSite<giNumSites;iSite++)
		{
			vecPinData[iSite].value=siCopy[iSite];
			if (msSiteStat(iSite))
			{
				vecPinData[iSite].site=iSite;
				vecPinData[iSite].resource=PLD_UNKNOWN_RESOURCE;
			}
		}
	}

	//Cast Int to PinListData
	PinListData::PinListData(const int& iVal)
	{
		RESULTS_STR results;
		init_STR(results);
		results.value=iVal;
		piNumPins=1;
		vecPinData = vector<RESULTS_STR> (giNumSites, results);
		for (int iSite=0; iSite<giNumSites;iSite++)
		{
			if (msSiteStat(iSite))
			{
				vecPinData[iSite].site=iSite;
				vecPinData[iSite].resource=PLD_UNKNOWN_RESOURCE;
			}
		}
	}

	//Cast Double to PinListData
	PinListData::PinListData(const double& dVal)
	{
		RESULTS_STR results;
		init_STR(results);
		results.value=dVal;
		piNumPins=1;
		vecPinData = vector<RESULTS_STR> (giNumSites, results);
		for (int iSite=0; iSite<giNumSites;iSite++)
		{
			if (msSiteStat(iSite))
			{
				vecPinData[iSite].site=iSite;
				vecPinData[iSite].resource=PLD_UNKNOWN_RESOURCE;
			}
		}
	}



	PinListData::PinListData(GME_INT pinGroup)
	{	
		RESULTS_STR results;
		init_STR(results);
		piNumPins=pinGroup.Size();
		vecPinData = vector<RESULTS_STR> (giNumSites*piNumPins, results);
	}


	

	PinListData::PinListData(RESULTS_STR* results, int num_pins, int iNumValid)
	{
		size_t i;
		piNumPins=num_pins;
		vecPinData = vector<RESULTS_STR>(results,results + num_pins*giNumSites);	//Create the vector with the data in results.  Size it to contain all sites for each pin.
		for (i = iNumValid; i < vecPinData.size(); i++)	//Eliminate the data that was not passed in (groupgetresults returns garbage data if any extra is requested.)
		{
			init_STR(vecPinData[i]);
		}
		//Modify so the RESULTS_STR sites are always placed in the correct order
		*this = Fix_RESULTS_STR_Site_Order(*this);
	}
/*
	PinListData::operator double() const
	{
		if (vecPinData.size()>0)
			return vecPinData[0].value;
		else return 0;
	}
*/
	//PinListData::operator RESULTS_STR*() const
	RESULTS_STR* PinListData::ResultsStructPtr() const
	{
		RESULTS_STR *Results;
		//int ResultsSize = (int) iGetVecSize();
		int ResultsSize = (int) vecPinData.size();
		Results=new RESULTS_STR[ResultsSize];
		for (int i = 0; i < ResultsSize; i++)
		{
			Results[i] = vecPinData[i];
		}
		return Results;
	}
	PinListData & PinListData::operator=(const PinListData pld)
	{
		if (this != &pld) 
		{	
			vecPinData=pld.vecPinData;
			piNumPins=pld.piNumPins;
		}	
		return *this;
	}

	/************************************************************************************************************************************************************For*Doxygen**//**
	Merge two PinListData classes, keeping the measured results from each. 	If both PLD's have valid results for 
		corresponding elements, then an error message is generated and no merge occurs because there is no way
		to know how the merge should occur.

	@param	[right] A PLD class
	
	@return	The merged PLD
	
	@remark		Usage: pld1 = pld2 & pld3;	//pld1 is assigned the merged results of pld2 and pld3.
	**************************************************************************************************************************************************************/
	PinListData PinListData::operator&(const PinListData right)
	{	
		PinListData Result;
		bool bUseLeft;
		size_t i;
		//Make a copy of the largest PLD to get the proper size.
		if ((right.vecPinData.size()) > (this->iGetVecSize()))
		{
			Result = right;
			bUseLeft = true;
		}
		else
		{
			Result = *this;
			bUseLeft = false;
		}
	
		//Determine which RESULT_STR to use for each element in the PLDs
		i = 0;
		while ( i<right.vecPinData.size() && i<this->iGetVecSize())
		{
			// If both vectors have valid values for the ith element then generate an error message because
			//   there is no way to know which value should be retained.
			if((this->vecPinData[i].resource!=PLD_INVALID_RESOURCE)&&(right.vecPinData[i].resource!=PLD_INVALID_RESOURCE))
			{
				std::stringstream ssErrorMessage;

				ssErrorMessage << "PinListData operator& received two potentially valid values at position " << i << std::endl;
				ssErrorMessage << "This could happen if you used pldResult for a prior test and then perform" << std::endl;
				ssErrorMessage << "pldResult = pldResult & apu12mv( ) or something similar" << std::endl;
				ssErrorMessage << "If you are reusing a variable, perform pldResult = PinListData(); before each new test";

				Maxim::System::Message.Deliver(ssErrorMessage);
				return Result;
			}
			if (bUseLeft) 
			{
				pResult(Result.vecPinData[i],  this->vecPinData[i], true);
			}
			else
			{
				pResult(Result.vecPinData[i],  right.vecPinData[i], true);
			}
			i++;
		}
		return Result;
	}

	/************************************************************************************************************************************************************For*Doxygen**//**
	Merge a PinListData class into an existing PLD, keeping the measured results from each. 	If both PLD's have valid results for 
		corresponding elements, then an error message is generated and no merge occurs because there is no way
		to know how the merge should occur.

	@param	[right] A PLD class
	
	@return	The merged PLD
	
	@remark		Usage: pld1 &= pld2;	//pld1 is assigned the merged results of pld1 and pld2.  See PinListdata::operator& for more information
	**************************************************************************************************************************************************************/
	PinListData PinListData::operator&=(const PinListData right)
	{
		PinListData Result;

		Result = *this & right;
		return Result;
	}


	PinListData PinListData::operator+(const PinListData& right)
	{
		PinListData Result(*this);

		if (vecPinData.size() != right.vecPinData.size())
		{
			etsprintf("Error!  Trying to add two PinListData values of different sizes.\n");
		}
		else
		{
			for (size_t i=0; i<Result.vecPinData.size();i++)
			{
				Result.vecPinData[i].value=vecPinData[i].value+right.vecPinData[i].value;
				pResult(Result.vecPinData[i],right.vecPinData[i]);
			}
		}
		return Result;
	}
	PinListData PinListData::operator-(const PinListData& right)
	{
		PinListData Result(*this);

		if (vecPinData.size() != right.vecPinData.size())
		{
			etsprintf("Error!  Trying to subtract two PinListData values of different sizes.\n");
		}
		else
		{
			for (size_t i=0; i<Result.vecPinData.size();i++)
			{
				Result.vecPinData[i].value=vecPinData[i].value-right.vecPinData[i].value;
				pResult(Result.vecPinData[i],right.vecPinData[i]);
			}
		}
		return Result;
	}

	PinListData PinListData::operator*(const PinListData& right)
	{
		PinListData Result(*this);

		if (vecPinData.size() != right.vecPinData.size())
		{
			etsprintf("Error!  Trying to multiply two PinListData values of different sizes.\n");
		}
		else
		{
			for (size_t i=0; i<Result.vecPinData.size();i++)
			{
				Result.vecPinData[i].value=vecPinData[i].value*right.vecPinData[i].value;
				pResult(Result.vecPinData[i],right.vecPinData[i]);
			}
		}
		return Result;
	}
	PinListData PinListData::operator/(const PinListData& right)
	{
		PinListData Result(*this);

		if (vecPinData.size() != right.vecPinData.size())
		{
			etsprintf("Error!  Trying to divide two PinListData values of different sizes.\n");
		}
		else
		{
			for (size_t i=0; i<Result.vecPinData.size();i++)
			{
				if (right.vecPinData[i].value != 0)
					Result.vecPinData[i].value=vecPinData[i].value/right.vecPinData[i].value;
				else
				{
					if (right.vecPinData[i].site!=-2 && vecPinData[i].site!=-2) //if either site is inactive, suppress error
						etsprintf("Error!  Trying to divide by zero.\n");
					Result.vecPinData[i].value = _HUGE;	//+infinity
				}
				pResult(Result.vecPinData[i],right.vecPinData[i]);
			}
		}
		return Result;
	}
	PinListData PinListData::operator+(const double& right)
	{
		PinListData pldCopy(*this);
		for (size_t i=0; i<vecPinData.size();i++)
		{
			pldCopy.vecPinData[i].value=vecPinData[i].value+right;
		}
		return pldCopy;
	}
	PinListData PinListData::operator-(const double& right)
	{
		PinListData pldCopy(*this);
		for (size_t i=0; i<vecPinData.size();i++)
		{
			pldCopy.vecPinData[i].value=vecPinData[i].value-right;
		}
		return pldCopy;
	}
	PinListData PinListData::operator*(const double& right)
	{
		PinListData pldCopy(*this);
		for (size_t i=0; i<vecPinData.size();i++)
		{
			pldCopy.vecPinData[i].value=vecPinData[i].value*right;
		}
		return pldCopy;
	}
	PinListData PinListData::operator/(const double& right)
	{
		PinListData pldCopy(*this);
		for (size_t i=0; i<vecPinData.size();i++)
		{
			if (right != 0)
				pldCopy.vecPinData[i].value=vecPinData[i].value/right;
			else
			{
				if (vecPinData[i].site!=-2) //if either site is inactive, suppress error
					etsprintf("Error!  Trying to divide by zero.\n");
				pldCopy.vecPinData[i].value = _HUGE;	//+infinity
			}
		}
		return pldCopy;
	}
	PinListData PinListData::operator+(const int& right)
	{
		return (*this)+double(right);
	}
	PinListData PinListData::operator-(const int& right)
	{
		return (*this)-double(right);
	}
	PinListData PinListData::operator*(const int& right)
	{	
		return (*this)*double(right);
	}
	PinListData PinListData::operator/(const int& right)
	{
		return (*this)/double(right);
	}
	
	PinListData PinListData::operator+(const ULONG& right)
	{
		return (*this)+double(right);
	}
	PinListData PinListData::operator-(const ULONG& right)
	{
		return (*this)-double(right);
	}
	PinListData PinListData::operator*(const ULONG& right)
	{	
		return (*this)*double(right);
	}
	PinListData PinListData::operator/(const ULONG& right)
	{
		return (*this)/double(right);
	}
//Other Math Functions
	PinListData operator + ( const SiteDouble & sdLeft, const PinListData& pldRight)
	{
		return PinListData(sdLeft) + pldRight;
	}
	PinListData operator - ( const SiteDouble & sdLeft, const PinListData& pldRight)
	{
		return PinListData(sdLeft) - pldRight;
	}
	PinListData operator / ( const SiteDouble & sdLeft, const PinListData& pldRight)
	{
		return PinListData(sdLeft) / pldRight;
	}
	PinListData operator * ( const SiteDouble & sdLeft, const PinListData& pldRight)
	{
		return PinListData(sdLeft) * pldRight;
	}
	PinListData operator + ( const SiteInt & siLeft, const PinListData& pldRight)
	{
		return PinListData(siLeft) + pldRight;
	}
	PinListData operator - ( const SiteInt & siLeft, const PinListData& pldRight)
	{
		return PinListData(siLeft) - pldRight;
	}
	PinListData operator / ( const SiteInt & siLeft, const PinListData& pldRight)
	{
		return PinListData(siLeft) / pldRight;
	}
	PinListData operator * ( const SiteInt & siLeft, const PinListData& pldRight)
	{
		return PinListData(siLeft) * pldRight;
	}
	
	PinListData operator + ( const double & dLeft, const PinListData& pldRight)
	{
		return PinListData(pldRight) + dLeft;
	}
	PinListData operator * ( const double & dLeft, const PinListData& pldRight)
	{
		return PinListData(pldRight) * dLeft;
	}

	PinListData operator - ( const double & dLeft, const PinListData& pldRight)
	{
		PinListData pldCopy(pldRight);
		for (unsigned int i=0; i<pldRight.iGetVecSize();i++)
		{
				pldCopy[i]=dLeft-pldRight[i];
		}
		return pldCopy;
	}
	PinListData operator / ( const double & dLeft, const PinListData& pldRight)
	{
		PinListData pldCopy(pldRight);
		for (unsigned int i=0; i<pldRight.iGetVecSize();i++)
		{
			if (pldRight[i] != 0)
				pldCopy[i]=dLeft/pldRight[i];
			else
			{
				if (pldCopy.ResultsStructPtr()[i].site!=-2) //if either site is inactive, suppress error
					etsprintf("Error!  Trying to divide by zero.\n");
				pldCopy[i] = _HUGE;	//+infinity
			}
		}
		return pldCopy;
	}
	
	PinListData operator + ( const int & iLeft, const PinListData& pldRight)
	{
		return double(iLeft) + pldRight;
	}
	PinListData operator - ( const int & iLeft, const PinListData& pldRight)
	{
		return double(iLeft) - pldRight;
	}
	PinListData operator / ( const int & iLeft, const PinListData& pldRight)
	{
		return double(iLeft) / pldRight;
	}
	PinListData operator * ( const int & iLeft, const PinListData& pldRight)
	{
		return double(iLeft) * pldRight;
	}
	const double& PinListData::operator[] (const unsigned int i) const
	{
		if (i >= vecPinData.size())
		{
			etsprintf("Error!  Site subscript out of range in PinListData::operator[]!.\n");
			return HUGE;
		}
		return vecPinData[i].value;
	}
	double& PinListData::operator[](unsigned int i)
	{
		//TODO need to set the pin's RESULTS_STR.site and .resource to valid values if a value is being set by the user.  Example: pldResults[2] = 4;
		//This operator also may be used to simply retrieve the value.  Example double dRes = pldResults[2];  In this case, the site value should not be modified.
		//Will there be any reason to use example? dRes = pldResults[2];  Worst case it datalogs a test and fails.
		//For now, the operator returns a constant reference to prevent users from setting the value.  Perhaps setting the value should be performed with a separate function.
		//if (vecPinData[i].site == -2)	//if initialized to -2 (= resource is turned off)
		//	vecPinData[i].site = -1;		//-1 = not assigned to a site	
		if (i >= vecPinData.size())
		{
			etsprintf("Error!  Site subscript out of range in PinListData::operator[]!.\n");
			return HUGE;
		}
		return vecPinData[i].value;
	}


	double& PinListData::operator() (const unsigned int Pin, const unsigned int Site)
	{
		//TODO (see note in PinListData::operator[])
		//if (vecPinData[Pin].site == -2)	//if initialized to -2 (= resource is turned off)
		//	vecPinData[Pin].site = -1;		//-1 = not assigned to a site	
		if ((Pin * giNumSites) + Site >= vecPinData.size())
		{
			etsprintf("Error!  Site subscript out of range in PinListData::operator()!.\n");
			return HUGE;
		}
		return vecPinData[(Pin * giNumSites) + Site].value; //Assumes Group Ordering in the Pin Map Editor options 
															//is set to the second option (PinA site1, PinA site2)
	}
	
	PinListData abs( PinListData pldVal)
	{
		PinListData pldTemp(pldVal);
		for (size_t i =0; i < pldVal.iGetVecSize();i++)
			pldTemp[(int)i]=abs(pldVal[(int)i]);
		return pldTemp;
	}
	
	PinListData log10( PinListData pldVal)
	{
		PinListData pldTemp(pldVal);
		for (size_t i =0; i < pldVal.iGetVecSize();i++)
			pldTemp[(int)i]=log10(pldVal[(int)i]);
		return pldTemp;
	}
	PinListData log( PinListData pldVal)
	{
		PinListData pldTemp(pldVal);
		for (size_t i =0; i < pldVal.iGetVecSize();i++)
			pldTemp[(int)i]=log(pldVal[(int)i]);
		return pldTemp;
	}
	
	const int PinListData::iGetNumPins() const
	{
		return piNumPins;
	}
	const size_t PinListData::iGetVecSize() const
	{
		return vecPinData.size();
	}
	
	void PinListData::pResult(RESULTS_STR& left, const RESULTS_STR& right, bool bCopyValue)
	{

		//resource:   The isocomm position or pin number or the resource.
		//	Valid values are:
		//				0 - 63    for isocomm positions
		//				0 - 95    for pin numbers

		//site: The site the to which the resource is assigned.
		//	Valid values are:
		//				0 - 15    for a valid site
		//				-1        not assigned to a site
		//				-2        resource is turned off

		if (bCopyValue) 	
		{
			//if both are user defined, TE's responsibility.
			//if right is invalid, then assume left is correct.
			if ((left.resource==PLD_INVALID_RESOURCE&&right.resource==PLD_INVALID_RESOURCE)||(right.resource==PLD_INVALID_RESOURCE))
			{
				return;		//Bail out: Only need to copy values when the right resource is valid. 
			}
		}
			
		//if left is invalid resource, use right 
		if (left.resource==PLD_INVALID_RESOURCE)
		{	
			left.resource=right.resource;
			if (bCopyValue)			
			{
				left.site = right.site;
				left.value = right.value;
			}
			return;
		}
		//Both are valid resources
		//if both sites are greater than -1 but don't match, return error
		if (left.site>-1 && right.site>-1)
		{
			//both sites valid
			if (left.site !=right.site)
				etsprintf("Error!  Trying to operator on two RESULTS_STR with different sites.  Results are unpredictable");
			return;
		}
		//if one is -2 then set both to -2)  
		if (left.site==-2||right.site==-2) 
		{
				left.site=-2;
				if (bCopyValue)
					left.value = right.value;
				return;
		}

		//Sites are valid or -1, if left is -1 set to right.
		if (left.site==-1)
		{
			left.site=right.site;
			if (bCopyValue)
				left.value = right.value;
		}

	}


	/************************************************************************************************************************************************************For*Doxygen**//**
	The groupgetresults function returns the sites out of order for pins declared as No Site in the Pin Map.  This function corrects the site order.

	@param	[pldInput] A PLD created directly from a RESULTS_STR array filled in by groupgetresults
	
	@return		The corrected PLD
	@remarks
			- Results that are a mix of non-assigned (-1) sites and assigned sites (>=0) are not supported.
			- Results from a site that is turned off (-2) are not saved.
	**************************************************************************************************************************************************************/
	PinListData PinListData::Fix_RESULTS_STR_Site_Order(PinListData pldInput)
	{
		SiteInt siTotalCount, siFilledCount;
		RESULTS_STR rsTemp;
		bool bFoundValidSite = false, bFoundNonAssignedSite = false;
		int  iPinOffset, iCopyTo, iCopyFrom;
		size_t i;

		//TODO make this more efficient.  For now, pldFixed is a copy of pldInput because pldFixed needs to be the same size, then clear the results
		PinListData pldFixed(pldInput);
		for (i=0; i<pldFixed.iGetVecSize();i++)
		{		
			init_STR(pldFixed.vecPinData[i]);
		}

		//First, determine if there are any duplicated valid site numbers.  This can happen if multiple "NO Site" pins were assigned to the same site in the group.
		for (i=0; i<pldInput.iGetVecSize();i++)
		{
			rsTemp = pldInput.vecPinData[i];
			if (pldInput.vecPinData[i].site >= 0) //If valid site
			{
				siTotalCount[rsTemp.site]++;
				bFoundValidSite = true;
			}
			else if (pldInput.vecPinData[i].site == -1) //Found a non-assigned site
			{	
				bFoundNonAssignedSite = true;
			}
		}
		if (bFoundValidSite && bFoundNonAssignedSite)
		{
			etsprintf("Error!  RESULT_STR results contained pins assigned to a site and pins not assigned to a site.  If any pin in the group is assigned a site, all pins in the group must have a site.");
			return pldInput;	//The datalog will probably not be correct.
		}

		//Now sort the array by site.
		//RESULTS_STR array can have multiple pins and multiple sites.
		for (i=0; i<pldInput.iGetVecSize();i++)
		{
			if (pldInput.vecPinData[i].site >= 0) //If valid site
			{
				iPinOffset = (giNumSites * (siFilledCount[pldInput.vecPinData[i].site]++));	//Calculate the pin offset if we find two results labeled with the same site.
				iCopyTo = pldInput.vecPinData[i].site + iPinOffset;	//Copy to the correct site and pin location.
				iCopyFrom = (int)i;
				pldFixed.vecPinData[iCopyTo] = pldInput.vecPinData[iCopyFrom];	//Copy site to the correct position
			}	
			else if (pldInput.vecPinData[i].site == -1) //Found a non-assigned site
			{
				pldFixed.vecPinData[i] = pldInput.vecPinData[i];		//Copy to the same position.
			}
		}
		return pldFixed;
	}


	void PinListData::init_STR(RESULTS_STR& res)
	{
		res.site = -2;		//Initialize to -2 = resource is turned off
		res.value = _HUGE;;		//initialize value to 0 incase sites are disabled.
		res.resource = PLD_INVALID_RESOURCE;	//Initialize to an invalid resource number
	}

	PinListData Maximaverage (char *cDataName, int iStart, int iStop)
	{
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();
#endif
		{
			average (cDataName, iStart, iStop);
			return pld_groupgetresults(giNumSites * 20); //20 is the Number of pins and we are overestimating since we don't know in advance
		}
	}

	PinListData Maximdspaverage (char *cDataName, int iStart, int iStop)
	{
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();
#endif
		{
			dspaverage (cDataName, iStart, iStop);
			return pld_groupgetresults(giNumSites * 20); //20 is the Number of pins and we are overestimating since we don't know in advance
		}
	}

	PinListData Maximpeak( char *cDataName, int iStart, int iStop, peaktype_t pHiOrLo)
	{
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();
#endif
		{
			peak( cDataName, iStart, iStop, pHiOrLo);
			return pld_groupgetresults(giNumSites * 20); //20 is the Number of pins and we are overestimating since we don't know in advance
		}

	}

	PinListData Maximdsppeak (char *cDataName, int iStart, int iStop, peaktype_t pHiOrLo)
	{
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();
#endif
		{
			dsppeak( cDataName, iStart, iStop, pHiOrLo);
			return pld_groupgetresults(giNumSites * 20); //20 is the Number of pins and we are overestimating since we don't know in advance
		}
	}

	PinListData Maximwhereat (char *cDataName, int iStart, int iStop, double dValue)
	{
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();
#endif
		{
			whereat (cDataName, iStart, iStop, dValue);
			return pld_groupgetresults(giNumSites * 20); //20 is the Number of pins and we are overestimating since we don't know in advance
		}
	}

	PinListData Maximdspwhereat (char *cDataName, int iStart, int iStop, double dValue)
	{
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();
#endif
		{
			dspwhereat (cDataName, iStart, iStop, dValue);
			return pld_groupgetresults(giNumSites * 20); //20 is the Number of pins and we are overestimating since we don't know in advance
		}
	}
