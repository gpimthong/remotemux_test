//DO NOT EDIT THIS FILE
/*** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-
*                                                                            
*	Source title:		Maximlib_SiteVar.cpp                                                                           		  
*	URL:				$URL: https://svn.maxim-ic.com/svn/ets/test_programs/AP89/AP89_FT/Trunk/MaximLib/MaximLib_SiteVar.cpp $
*   Last Modified by:	$LastChangedBy: govit.pimthong $                                       
*	Date:				$Date: 2017-03-09 12:55:55 +0700 (Thu, 09 Mar 2017) $                                                
*   Current Rev:		$Revision: 61735 $
*                                                                            
*	Description:
*		Maxim library cpp file for Class SiteBool, SiteInt, SiteDouble
*		Maxim library written and maintained by:								 
*			Patrick Hayes (Patrick.Hayes@MaximIntegrated.com)	                 
*			Mark Bruening (Mark.Bruening@MaximIntegrated.com)                                                                            
*
*   Revision History                                                    
*                                                                            
**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****/
//DO NOT EDIT THIS FILE

/**********************************************************************************************************************************************For*Doxygen**//**
@file	Maximlib_SiteVar.cpp
@brief	Maxim library cpp file for Class SiteBool, SiteInt, SiteDouble
**************************************************************************************************************************************************************/


/*** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-
//////////////////// SiteBool Class Definition                                                         
**************************************************************************************************************************************************************/
	//Note: Using the BOOL (int) type instead of the bool type because vector<bool> does not meet C++ Standard Library container requirements.
	// See http://en.wikipedia.org/wiki/Vector_%28C%2B%2B%29#vector.3Cbool.3E_specialization
	//This means that FALSE = 0 and TRUE = any value except zero.
	//  So to be safe the BOOL element should never be compared with TRUE.  (Do not use if (vecBool[site] == TRUE) as this may produce unexpected results.)
	//  These limitations lead to some non-straight-forward logic below.

	//Eagle used the BOOL type as a return for some functions, so using BOOL type for the SiteBool also prevents the compiler from displaying conversion warnings.
	//TODO: investigate if it is better to use the bool type.  See https://groups.google.com/group/comp.lang.c++.moderated/browse_thread/thread/b8d6dd59dfb295c0/e23e0f606d64550a?hl=ru

	SiteBool::SiteBool()	//Default constructor.  Initialize to FALSE
	{
		vecBool = vector<BOOL> (giNumSites, FALSE);	//Initialize to FALSE
	}

	SiteBool::SiteBool(const BOOL bValue)	//construct a vector from a BOOL
	{
		if (bValue) 
			vecBool = vector<BOOL> (giNumSites, TRUE);	//Initialize to bValue (only allow TRUE ( = 1)) to enable safe (bVal == TRUE) comparison.
		else
			vecBool = vector<BOOL> (giNumSites, FALSE);	//Initialize to bValue
	}
	SiteBool::SiteBool(const SiteBool &sbCopy)	//Copy constructor
	{
		vecBool= sbCopy.vecBool;
	}

	SiteBool::~SiteBool()
	{

	}			
	

	SiteBool & SiteBool::operator=(const SiteBool sbVal)		//copy another SiteBool
	{
		if (this != &sbVal) 
		{	
			vecBool=sbVal.vecBool;
		}	
		return *this;
	}

	void SiteBool::operator=(const BOOL bValue)	//Set SiteBool to a constant value
	{	
		//TODO make this more proper and use vecBool.begin()
		for (size_t iSite = 0 ; iSite < vecBool.size(); iSite++)
		{
			vecBool[iSite] = bValue;
		}
	}
	
	BOOL & SiteBool::operator[](const unsigned iSite)	
	{
		if (vecBool.size() <= iSite)
		{
			etsprintf("Error!  Site subscript out of range in SiteBool::operator[]!.\n");
			return vecBool[0];	//still need to return something
		}
		else
		{
			return vecBool[iSite];
		}
	}

	const bool SiteBool::operator[] (const unsigned iSite) const 
	{
		bool bvalue;
		if (vecBool.size() <= iSite)
		{
			bvalue = false;
			etsprintf("Error!  Site subscript out of range in SiteBool::operator[]!.\n");
		}
		else
		{
			if (vecBool[iSite]) 
				bvalue = true;	
			else
				bvalue = false;
		}
		return bvalue;
	}


	bool SiteBool::operator==(const SiteBool& right) const
	{
		bool bEqual = true;
		for (size_t i=0; i<vecBool.size(); i++)
		{
			//if (vecBool[i] != right.vecBool[i])	//Since this is using an int (BOOL) type, cannot make a direct comparison			
			if ((vecBool[i] && right.vecBool[i] == FALSE) || (vecBool[i] == FALSE) && (right.vecBool[i]))	//if one is TRUE and the other is FALSE
				bEqual = false;		//Return FALSE if any site does not match
		}
		return bEqual;
	}

	bool SiteBool::operator!=(const SiteBool& right) const
	{
		if (*this == right)	//reuse operator==
			return false;
		else
			return true;
	}

	SiteBool SiteBool::operator~()	//Invert
	{
		for (size_t i=0; i<vecBool.size(); i++)
		{
			if (vecBool[i])	//if TRUE
				vecBool[i] = FALSE;
			else
				vecBool[i] = TRUE;
		}
		return *this;
	}

	SiteBool SiteBool::operator&(const SiteBool& right)	//Logical AND
	{
		SiteBool sbResult(*this);
		for (size_t i=0; i<sbResult.vecBool.size(); i++)
		{	
			if (vecBool[i] && right.vecBool[i])
				sbResult.vecBool[i] = TRUE;
			else
				sbResult.vecBool[i] = FALSE;
		}
		return sbResult;
	}

	SiteBool SiteBool::operator|(const SiteBool& right)	//Logical OR
	{
		SiteBool sbResult(*this);
		for (size_t i=0; i<sbResult.vecBool.size(); i++)
		{	
			if (vecBool[i] || right.vecBool[i])
				sbResult.vecBool[i] = TRUE;
			else
				sbResult.vecBool[i] = FALSE;
		}
		return sbResult;
	}
	
	SiteBool SiteBool::operator^(const SiteBool& right)	//Logical XOR
	{
		SiteBool sbResult(*this);
		for (size_t i=0; i<sbResult.vecBool.size(); i++)
		{	
			if (vecBool[i] && (right.vecBool[i] == FALSE))
				sbResult.vecBool[i] = TRUE;
			else if (vecBool[i] == FALSE && (right.vecBool[i]))
				sbResult.vecBool[i] = TRUE;
			else
				sbResult.vecBool[i] = FALSE;
		}
		return sbResult;
	}



	BOOL SiteBool::All(const BOOL bCheck)	//Returns true if all sites match bCheck
	{
		SiteBool sbCheck(bCheck);
		return (*this == sbCheck);
/*
		BOOL bMatch = TRUE;
		for (int i=0; i<vecBool.size(); i++)	
		{
			if (vecBool[i] != bCheck)	//TODO
				bMatch = FALSE;
		}
		return bMatch;
*/
	}
	BOOL SiteBool::Any(const BOOL bCheck)	//Returns true if any sites match bCheck
	{
		BOOL bMatch = FALSE;
		for (size_t i=0; i<vecBool.size(); i++)
		{
			if (vecBool[i] && bCheck)	//If both are TRUE
				bMatch = TRUE;
			else if (vecBool[i] == FALSE && bCheck == FALSE)	//If both are FALSE
				bMatch = TRUE;
		}
		return bMatch;
	}


	unsigned int SiteBool::size() const	//Size of SiteBool (Number of Sites)
	{
		return (unsigned int) vecBool.size();
	}

	void SiteBool::resize(int size)	//Size of SiteBool (Number of Sites)
	{
		vecBool.resize(size);
	}

/************************************************************************************************************************************************************For*Doxygen**//**
//////////////////// SiteDouble Class Definition                                                         
**************************************************************************************************************************************************************/
	SiteDouble::SiteDouble()	//Default constructor.  Initialize to 0
	{
		vecD = vector<double> (giNumSites, 0);	//Initialize to 0
	}

	SiteDouble::SiteDouble(const double iValue)	//construct a vector from a double
	{
		vecD = vector<double> (giNumSites, iValue);	//Initialize to iValue
	}

	SiteDouble::SiteDouble(const SiteDouble &sdCopy)	//Copy constructor
	{
		vecD= sdCopy.vecD;
	}

	SiteDouble::SiteDouble(const SiteInt siVal) //cast SiteInt to SiteDouble
	{
		vecD=vector<double> (giNumSites,0);	
		for (unsigned int i=0; i < siVal.size(); i++)
		{
			vecD[i] = siVal[i];
		}
	
	}

	SiteDouble::~SiteDouble()
	{
	}			
	

	SiteDouble & SiteDouble::operator=(const SiteDouble sdVal)		//copy another SiteDouble
	{
		if (this != &sdVal) 
		{
			vecD=sdVal.vecD;
		}	
		return *this;
	}



	double & SiteDouble::operator[](const unsigned iSite)
	{
		if (vecD.size() <= iSite)
		{
			etsprintf("Error!  Site subscript out of range in SiteDouble::operator[]!.\n");
			return vecD[0];	//still need to return a reference to something
		}
		else
		{
			return vecD[iSite];
		}
	}

	const double SiteDouble::operator[] (const unsigned iSite) const 
	{
		if (vecD.size() <= iSite)
		{
			etsprintf("Error!  Site subscript out of range in SiteDouble<T>::operator[]!.\n");
			double dVar;
			Set_Error_Value(dVar);
			return dVar;	//still need to return something
		}
		else
		{
			return vecD[iSite];
		}
	}



	SiteDouble SiteDouble::operator+(const SiteDouble& right) const
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			sdResult[i] = vecD[i] + right[i];
		}
		return sdResult;
	}
	SiteDouble SiteDouble::operator-(const SiteDouble& right) const
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			sdResult[i] = vecD[i] - right[i];
		}
		return sdResult;

	}
	SiteDouble SiteDouble::operator*(const SiteDouble& right) const
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			sdResult[i] = vecD[i] * right[i];
		}
		return sdResult;
	}
	SiteDouble SiteDouble::operator/(const SiteDouble& right) const
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			if (right[i] != 0)
				sdResult[i] = vecD[i] / right[i];
			else
			{
				if (msSiteStat(i))
					etsprintf("Error!  Trying to divide by zero.\n");				
				Set_Error_Value(sdResult[i]);
			}			
		}
		return sdResult;
	}

		SiteDouble SiteDouble::operator+(const SiteInt& right) const
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			sdResult[i] = vecD[i] + right[i];
		}
		return sdResult;
	}
	SiteDouble SiteDouble::operator-(const SiteInt& right) const
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			sdResult[i] = vecD[i] - right[i];
		}
		return sdResult;

	}
	SiteDouble SiteDouble::operator*(const SiteInt& right) const
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			sdResult[i] = vecD[i] * right[i];
		}
		return sdResult;
	}
	SiteDouble SiteDouble::operator/(const SiteInt& right) const
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			if (right[i] != 0)
				sdResult[i] = vecD[i] / right[i];
			else
			{
				if (msSiteStat(i))
					etsprintf("Error!  Trying to divide by zero.\n");				
				Set_Error_Value(sdResult[i]);
			}			
		}
		return sdResult;
	}

	SiteDouble SiteDouble::operator+(const int& right) const
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			sdResult[i] = vecD[i] + right;
		}
		return sdResult;
	}
	SiteDouble SiteDouble::operator-(const int& right) const
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			sdResult[i] = vecD[i] - right;
		}
		return sdResult;

	}
	SiteDouble SiteDouble::operator*(const int& right) const
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			sdResult[i] = vecD[i] * right;
		}
		return sdResult;
	}
	SiteDouble SiteDouble::operator/(const int& right) const
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			if (right != 0)
				sdResult[i] = vecD[i] / right;
			else
			{
				if (msSiteStat(i))
					etsprintf("Error!  Trying to divide by zero.\n");				
				Set_Error_Value(sdResult[i]);
			}			
		}
		return sdResult;
	}
	SiteDouble SiteDouble::operator+(const double& right) const
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			sdResult[i] = vecD[i] + right;
		}
		return sdResult;
	}
	SiteDouble SiteDouble::operator-(const double& right) const
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			sdResult[i] = vecD[i] - right;
		}
		return sdResult;

	}
	SiteDouble SiteDouble::operator*(const double& right) const
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			sdResult[i] = vecD[i] * right;
		}
		return sdResult;
	}
	SiteDouble SiteDouble::operator/(const double& right) const
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			if (right != 0)
				sdResult[i] = vecD[i] / right;
			else
			{
				if (msSiteStat(i))
					etsprintf("Error!  Trying to divide by zero.\n");				
				Set_Error_Value(sdResult[i]);
			}			
		}
		return sdResult;
	}

	SiteDouble SiteDouble::operator+=(const SiteDouble& right)
	{
		for (unsigned int i=0; i<size(); i++)
		{
			vecD[i] = vecD[i] + right[i];
		}
		return *this;
	}
	SiteDouble SiteDouble::operator-=(const SiteDouble& right)
	{
		for (unsigned int i=0; i<size(); i++)
		{
			vecD[i] = vecD[i] - right[i];
		}
		return *this;
	}
	SiteDouble SiteDouble::operator*=(const SiteDouble& right)
	{
		for (unsigned int i=0; i<size(); i++)
		{
			vecD[i] = vecD[i] * right[i];
		}
		return *this;
	}
	SiteDouble SiteDouble::operator/=(const SiteDouble& right)
	{
		for (unsigned int i=0; i<size(); i++)
		{
			if (right[i] != 0)
				vecD[i] = vecD[i] / right[i];
			else
			{
				if (msSiteStat(i))
					etsprintf("Error!  Trying to divide by zero.\n");				
				Set_Error_Value(vecD[i]);
			}			
		}
		return *this;
	}		

	unsigned int SiteDouble::size() const	//Size of SiteDouble (Number of Sites)
	{
		return (unsigned int) vecD.size();
	}

	void SiteDouble::resize(int size) 	//Size of SiteDouble (Number of Sites)
	{
		 vecD.resize(size);
	}

	bool SiteDouble::AreAllSitesEqual()
	{
		bool bAllSitesEqual = TRUE;

		// If vecD contains 1 or more values, check to see if all values are equal to the first, meaning they are all equal to each other.
		if (vecD.size()) for(unsigned int i=1; i<vecD.size(); i++) bAllSitesEqual &= (vecD[0] == vecD[i]);
		
		return bAllSitesEqual;
	}

	SiteDouble operator+(const SiteInt& left,const SiteDouble& right)
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			sdResult[i] = left[i] + right[i];
		}
		return sdResult;
	}

	SiteDouble operator-(const SiteInt& left,const SiteDouble& right)
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			sdResult[i] = left[i] - right[i];
		}
		return sdResult;
	}

	SiteDouble operator*(const SiteInt& left, const SiteDouble& right)
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			sdResult[i] = left[i] * right[i];
		}
		return sdResult;
	}

	SiteDouble operator/(const SiteInt& left,const SiteDouble& right) 
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			if (right[i] != 0)
				sdResult[i] = left[i] / right[i];
			else
			{
				if (msSiteStat(i))
					etsprintf("Error!  Trying to divide by zero.\n");				
				Set_Error_Value(sdResult[i]);
			}			
		}
		return sdResult;
	}

	SiteDouble operator+(const int& left,const SiteDouble& right)
	{
		return double(left)+right;
	}

	SiteDouble operator-(const int& left,const SiteDouble& right)
	{
		return double(left)-right;
	}

	SiteDouble operator*(const int& left, const SiteDouble& right)
	{
		return double(left)*right;
	}

	SiteDouble operator/(const int& left,const SiteDouble& right) 
	{
		return double(left)/right;
	}
	SiteDouble operator+(const double& left,const SiteDouble& right)
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			sdResult[i] = left + right[i];
		}
		return sdResult;
	}

	SiteDouble operator-(const double& left,const SiteDouble& right)
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			sdResult[i] = left - right[i];
		}
		return sdResult;
	}

	SiteDouble operator*(const double& left, const SiteDouble& right)
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			sdResult[i] = left * right[i];
		}
		return sdResult;
	}

	SiteDouble operator/(const double& left,const SiteDouble& right) 
	{
		SiteDouble sdResult;
		for (unsigned int i=0; i<sdResult.size(); i++)
		{
			if (right[i] != 0)
				sdResult[i] = left / right[i];
			else
			{
				if (msSiteStat(i))
					etsprintf("Error!  Trying to divide by zero.\n");				
				Set_Error_Value(sdResult[i]);
			}			
		}
		return sdResult;
	}


/************************************************************************************************************************************************************For*Doxygen**//**
//////////////////// SiteInt Class Definition                                                         
**************************************************************************************************************************************************************/
	SiteInt::SiteInt()	//Default constructor.  Initialize to 0
	{
		vecI = vector<int> (giNumSites, 0);	//Initialize to 0
	}

	SiteInt::SiteInt(const int iValue)	//construct a vector from an int
	{
		vecI = vector<int> (giNumSites, iValue);	//Initialize to iValue
	}

	SiteInt::SiteInt(const SiteInt &siCopy)	//Copy constructor
	{
		vecI= siCopy.vecI;
	}

	SiteInt::~SiteInt()
	{
	}			
	

	SiteInt & SiteInt::operator=(const SiteInt siVal)		//copy another SiteInt
	{
		if (this != &siVal) 
		{	
			vecI=siVal.vecI;
		}	
		return *this;
	}


	int & SiteInt::operator[](const unsigned iSite)
	{
		if (vecI.size() <= iSite)
		{
			etsprintf("Error!  Site subscript out of range in SiteInt::operator[]!.\n");
			return vecI[0];	//still need to return a reference to something
		}
		else
		{
			return vecI[iSite];
		}
	}

	const int SiteInt::operator[] (const unsigned iSite) const 
	{
		if (vecI.size() <= iSite)
		{
			etsprintf("Error!  Site subscript out of range in SiteInt<T>::operator[]!.\n");
			int iVar;
			Set_Error_Value(iVar);
			return iVar;	//still need to return something
		}
		else
		{
			return vecI[iSite];
		}
	}



	SiteInt SiteInt::operator+(const SiteInt& right) const
	{
		SiteInt siResult;
		for (unsigned int i=0; i<siResult.size(); i++)
		{
			siResult[i] = vecI[i] + right[i];
		}
		return siResult;
	}

	SiteInt SiteInt::operator-(const SiteInt& right) const
	{
		SiteInt siResult;
		for (unsigned int i=0; i<siResult.size(); i++)
		{
			siResult[i] = vecI[i] - right[i];
		}
		return siResult;
	}
	SiteInt SiteInt::operator*(const SiteInt& right) const
	{
		SiteInt siResult;
		for (unsigned int i=0; i<siResult.size(); i++)
		{
			siResult[i] = vecI[i] * right[i];
		}
		return siResult;
	}
	

	SiteInt SiteInt::operator/(const SiteInt& right) const
	{
		SiteInt siResult;
		for (unsigned int i=0; i<siResult.size(); i++)
		{
			if (right[i] != 0)
				siResult[i] = vecI[i] / right[i];
			else
			{
				if (msSiteStat(i))
					etsprintf("Error!  Trying to divide by zero.\n");				
				Set_Error_Value(siResult[i]);
			}			
		}
		return siResult;
	}

	SiteInt SiteInt::operator+(const int& right) const
	{
		SiteInt siResult;
		for (unsigned int i=0; i<siResult.size(); i++)
		{
			siResult[i] = vecI[i] + right;
		}
		return siResult;
	}

	SiteInt SiteInt::operator-(const int& right) const
	{
		SiteInt siResult;
		for (unsigned int i=0; i<siResult.size(); i++)
		{
			siResult[i] = vecI[i] - right;
		}
		return siResult;
	}
	SiteInt SiteInt::operator*(const int& right) const
	{
		SiteInt siResult;
		for (unsigned int i=0; i<siResult.size(); i++)
		{
			siResult[i] = vecI[i] * right;
		}
		return siResult;
	}
	

	SiteInt SiteInt::operator/(const int& right) const
	{
		SiteInt siResult;
		for (unsigned int i=0; i<siResult.size(); i++)
		{
			if (right != 0)
				siResult[i] = vecI[i] / right;
			else
			{
				if (msSiteStat(i))
					etsprintf("Error!  Trying to divide by zero.\n");				
				Set_Error_Value(siResult[i]);
			}			
		}
		return siResult;
	}
	unsigned int SiteInt::size() const	//Size of SiteInt (Number of Sites)
	{
		return (unsigned int) vecI.size();
	}

	void SiteInt::resize(int size) 	//Size of SiteInt (Number of Sites)
	{
		 vecI.resize(size);
	}

	SiteInt operator+(const int& left,const SiteInt& right)
	{
		SiteInt siResult;
		for (unsigned int i=0; i<siResult.size(); i++)
		{
			siResult[i] = left + right[i];
		}
		return siResult;
	}

	SiteInt operator-(const int& left,const SiteInt& right)
	{
		SiteInt siResult;
		for (unsigned int i=0; i<siResult.size(); i++)
		{
			siResult[i] = left - right[i];
		}
		return siResult;
	}

	SiteInt operator*(const int& left, const SiteInt& right)
	{
		SiteInt siResult;
		for (unsigned int i=0; i<siResult.size(); i++)
		{
			siResult[i] = left * right[i];
		}
		return siResult;
	}

	SiteInt operator/(const int& left,const SiteInt& right) 
	{
		SiteInt siResult;
		for (unsigned int i=0; i<siResult.size(); i++)
		{
			if (right[i] != 0)
				siResult[i] = left / right[i];
			else
			{
				if (msSiteStat(i))
					etsprintf("Error!  Trying to divide by zero.\n");				
				Set_Error_Value(siResult[i]);
			}			
		}
		return siResult;
	}
	/************************************************************************************************************************************************************For*Doxygen**//**
	Return the absolute value of all site values in the SiteDouble
	
	@param	[sdVal] A SiteDouble class
	
	@return	The absolute value of each site's value

	@remark		Usage example:
	@code		
		svRes = abs(svNum);	//svRes is assigned the absolute value of svNum.
	@endcode
	**************************************************************************************************************************************************************/
	SiteDouble abs(const SiteDouble sdVal)
	{
		SiteDouble sdTemp(sdVal);
		for (unsigned int i = 0; i < sdVal.size(); i++)
			sdTemp[i]=abs(sdTemp[i]);
		return sdTemp;
	}
	/************************************************************************************************************************************************************For*Doxygen**//**
	Return the log value of all site values in the SiteDouble
	
	@param	[sdVal] A SiteDouble class

	@return		The log value of each site's value
	
	@remarks	Usage:
	@code
		svRes = log(svNum);	//svRes is assigned the log value of svNum.
	@endcode
	**************************************************************************************************************************************************************/
	
	SiteDouble log(const SiteDouble sdVal)
	{
		SiteDouble sdTemp(sdVal);
		for (unsigned int i = 0; i < sdVal.size(); i++)
			sdTemp[i]=log(sdTemp[i]);
		return sdTemp;
	}	
	/************************************************************************************************************************************************************For*Doxygen**//**
	Return the log10 value of all site values in the SiteDouble

	@param	[sdVal] A SiteDouble class
	
	@return		The log10 value of each site's value
	
	@remarks	Usage:
	@code
		svRes = log10(svNum);	//svRes is assigned the log value of svNum.
	@endcode
	**************************************************************************************************************************************************************/
	SiteDouble log10(const SiteDouble sdVal)
	{
		SiteDouble sdTemp(sdVal);
		for (unsigned int i = 0; i < sdVal.size(); i++)
			sdTemp[i]=log10(sdTemp[i]);
		return sdTemp;
	}	