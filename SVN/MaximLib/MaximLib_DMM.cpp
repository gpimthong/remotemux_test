//DO NOT EDIT THIS FILE
/*** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-
*                                                                            
*	Source title:		MaximLib_DMM.CPP                                                                            		  
*	URL:				$URL: https://svn.maxim-ic.com/svn/ets/test_programs/AP89/AP89_FT/Trunk/MaximLib/MaximLib_DMM.cpp $
*	Last Modified by:	$LastChangedBy: govit.pimthong $                                       
*	Date:				$Date: 2017-03-09 12:55:55 +0700 (Thu, 09 Mar 2017) $                                                
*	Current Rev:		$Revision: 61735 $
*                                                                            
*	Description:  
*		Maxim library file for digital multi-meter (external HP Meter) functions
*		Maxim library maintained by:
*			Mark Bruening (Mark.Bruening@MaximIntegrated.com)
*			Patrick Hayes (Patrick.Hayes@MaximIntegrated.com)
*
*	Revision History
*		See MaximLib_DMM.h file.
*                                                                            
**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****/
//DO NOT EDIT THIS FILE

/**********************************************************************************************************************************************For*Doxygen**//**
@file	MaximLib_DMM.cpp
@brief	Maxim library file for digital multi-meter (external HP Meter) functions  
**************************************************************************************************************************************************************/

using namespace std;

bool gb_DMM_CONFIG_DONE = false;	//Global to make sure DMM_Config is called before calling DMM_Meas or DMM_Meas_Avg
int gi_DMM_ADDRESS;					//Global storing the GPIB address of the meter connected to this sector.  Called in Init

const int gconiDMM_ADDRESS_SECTOR1A = 22;	//External meter GPIB address for meter connected to Sector 1A
const int gconiDMM_ADDRESS_SECTOR1B = 23;	//External meter GPIB address for meter connected to Sector 1B

const double gcondMeterError = HUGE; 

namespace Maxim
{
	namespace Meter
	{

		//DMM functions below:
	
		/************************************************************************************************************************************************************For*Doxygen**//**
		Configure the meter

		@param	[DMM_MEAS] Measurement type (DC/AC voltage or current.  Two or four wire resistance.  Frequency.) See DMM_MEASTYPE. 
		@param	[DMM_RANGE] Measurement Range.  Select the lowest range possible for best accuracy.  
		@param	[DMM_RESOLUTION] Number of Power Line Cycles for DCV and resistance measurements.
		@param	[DMM_APERTURE] (Optional, default = DMM_APE_NA) Aperture time for ACV,ACI and Freq measurements, in Seconds.
		@param	[DMM_ACFILTER] (Optional, default = DMM_FILT_NA) High pass filter for ACV,ACI and Freq measurements.
		@param	[DMM_INPUTIMPEDANCE] (Optional, default = DMM_INPUT_NA) Applies to DCV measurements only.  10G impedance applies to 100mV, 1V and 10V range only. 
		@param	[DMM_TRIGGER] (Optional, default = DMM_TRIG_NA) Set meter to internal or external measurement trigger.

		@returns	True if the configuration was accepted.  false if invalid configuration parameters were given.

		@remarks
				See meter manual.  	See .h file for enumerated type definitions.  
				DMM::GetGPIBAddress or DMM:Init() must have been called at least once before calling this function.  
				Meter terminal switch must be set to rear connections or there will be an error. 
		**************************************************************************************************************************************************************/
		// Basic config (measurement type, number of samples, range) ******************************************************************
		bool DMM::Config(DMM_MEASTYPE DMM_MEAS, 
			DMM_RANGETYPE DMM_RANGE, 
			DMM_RESOLUTIONTYPE DMM_RESOLUTION, 
			DMM_APERTURETYPE DMM_APERTURE,  
			DMM_ACFILTERTYPE DMM_ACFILTER,
			DMM_INPUTIMPEDANCETYPE DMM_INPUTIMPEDANCE,
			DMM_TRIGGERTYPE DMM_TRIGGER) 
		{  

			int status;
			bool config_passed = true;		//Set config_passed=true at beginning, only set to false anywhere in function.  At end, return config_passed.
			char buffer[256]="";
			char *ptr=&buffer[0];
			DMM_TERMINALTYPE DMM_terminals;

			//First, check that DMM is set to rear terminals.
			DMM_terminals = DMM::TerminalCheck();
			if (DMM_terminals==DMM_CONN_FRONT) {config_passed = false;return (config_passed);} //popup warning already occurs in DMM_TerminalCheck

			//Configure Measurement type:
			switch (DMM_MEAS){
			case DMM_DCV:
				strcpy_s(buffer,"CONF:VOLT:DC ");
				break;
			case DMM_DCI:
				strcpy_s(buffer,"CONF:CURR:DC ");
				break;
			case DMM_ACV:
				strcpy_s(buffer,"CONF:VOLT:AC ");
				break;
			case DMM_ACI:
				strcpy_s(buffer,"CONF:CURR:AC ");
				break;
			case DMM_RES2W:
				strcpy_s(buffer,"CONF:RES ");
				break;
			case DMM_RES4W:
				strcpy_s(buffer,"CONF:FRES ");  //Four-wire resistance
				break;
			case DMM_FREQ:
				strcpy_s(buffer,"CONF:FREQ ");
				break;
			default:
				config_passed = false;
				etsMessageBox("External meter invalid measurement type selected.",MB_OK|MB_ICONSTOP);
				return (config_passed);
			}
			//Configure Range:
			switch (DMM_RANGE){
			case DMM_RANGE_AUTO:
				strcat_s (buffer,"DEF,");
				break;
			case DMM_RANGE_100MV:  //For DC and AC voltage measurements.
				if ((DMM_MEAS==DMM_DCV)||(DMM_MEAS==DMM_ACV)) strcat_s (buffer,"100E-3,");
				else {config_passed = false;etsMessageBox("External meter measurement type/range mismatch.",MB_OK|MB_ICONSTOP);return (config_passed);}
				break;
			case DMM_RANGE_1V:	//For DC and AC voltage measurements.
				if ((DMM_MEAS==DMM_DCV)||(DMM_MEAS==DMM_ACV)) strcat_s (buffer,"1,");
				else {config_passed = false;etsMessageBox("External meter measurement type/range mismatch.",MB_OK|MB_ICONSTOP);return (config_passed);}
				break;
			case DMM_RANGE_10V:	//For DC and AC voltage measurements.
				if ((DMM_MEAS==DMM_DCV)||(DMM_MEAS==DMM_ACV)) strcat_s (buffer,"10,");
				else {config_passed = false;etsMessageBox("External meter measurement type/range mismatch.",MB_OK|MB_ICONSTOP);return (config_passed);}
				break;
			case DMM_RANGE_100V:	//For DC and AC voltage measurements.
				if ((DMM_MEAS==DMM_DCV)||(DMM_MEAS==DMM_ACV)) strcat_s (buffer,"100,");
				else {config_passed = false;etsMessageBox("External meter measurement type/range mismatch.",MB_OK|MB_ICONSTOP);return (config_passed);}
				break;
			case DMM_RANGE_1KV:  //For DC and AC voltage measurements.  Actual max range for ACV is 750V (RMS), but is 1000V in DMM setting. (peak AC to RMS conversion)
				if ((DMM_MEAS==DMM_DCV)||(DMM_MEAS==DMM_ACV)) strcat_s (buffer,"1E3,");
				else {config_passed = false;etsMessageBox("External meter measurement type/range mismatch.",MB_OK|MB_ICONSTOP);return (config_passed);}
				break;
			case DMM_RANGE_10MA:  //10mA range is for DCI measurements only.
				if (DMM_MEAS==DMM_DCI) strcat_s (buffer,"10E-3,");
				else {config_passed = false;etsMessageBox("External meter 10mA range for DC measurements only.",MB_OK|MB_ICONSTOP);return (config_passed);}
				break;
			case DMM_RANGE_100MA:  //100mA range is for DCI measurements only.
				if (DMM_MEAS==DMM_DCI)strcat_s (buffer,"100E-3,");
				else {config_passed = false;etsMessageBox("External meter 100mA range for DC measurements only.",MB_OK|MB_ICONSTOP);return (config_passed);}
				break;
			case DMM_RANGE_1A:	//For DCI or ACI measurements.
				if ((DMM_MEAS==DMM_DCI)||(DMM_MEAS==DMM_ACI)) strcat_s (buffer,"1,");
				else {config_passed = false;etsMessageBox("External meter measurement type/range mismatch.",MB_OK|MB_ICONSTOP);return (config_passed);}
				break;	
			case DMM_RANGE_3A:	//For DCI or ACI measurements
				if ((DMM_MEAS==DMM_DCI)||(DMM_MEAS==DMM_ACI)) strcat_s (buffer,"3,");
				else {config_passed = false;etsMessageBox("External meter measurement type/range mismatch.",MB_OK|MB_ICONSTOP);return (config_passed);}
				break;
			case DMM_RANGE_100:	//For RES2W and RES4W measurements
				if ((DMM_MEAS==DMM_RES2W)||(DMM_MEAS==DMM_RES4W)) strcat_s (buffer,"100,");
				else {config_passed = false;etsMessageBox("External meter measurement type/range mismatch.",MB_OK|MB_ICONSTOP);return (config_passed);}
				break;
			case DMM_RANGE_1K:	//For RES2W and RES4W measurements
				if ((DMM_MEAS==DMM_RES2W)||(DMM_MEAS==DMM_RES4W)) strcat_s (buffer,"1E3,");
				else {config_passed = false;etsMessageBox("External meter measurement type/range mismatch.",MB_OK|MB_ICONSTOP);return (config_passed);}
				break;
			case DMM_RANGE_100K:	//For RES2W and RES4W measurements
				if ((DMM_MEAS==DMM_RES2W)||(DMM_MEAS==DMM_RES4W)) strcat_s (buffer,"100E3,");
				else {config_passed = false;etsMessageBox("External meter measurement type/range mismatch.",MB_OK|MB_ICONSTOP);return (config_passed);}
				break;
			case DMM_RANGE_1M:
				if ((DMM_MEAS==DMM_RES2W)||(DMM_MEAS==DMM_RES4W)) strcat_s (buffer,"1E6,");
				else {config_passed = false;etsMessageBox("External meter measurement type/range mismatch.",MB_OK|MB_ICONSTOP);return (config_passed);}
				break;
			case DMM_RANGE_10M:	//For RES2W and RES4W measurements
				if ((DMM_MEAS==DMM_RES2W)||(DMM_MEAS==DMM_RES4W)) strcat_s (buffer,"10E6,");
				else {config_passed = false;etsMessageBox("External meter measurement type/range mismatch.",MB_OK|MB_ICONSTOP);return (config_passed);}
				break;
			case DMM_RANGE_100M:	//For RES2W and RES4W measurements
				if ((DMM_MEAS==DMM_RES2W)||(DMM_MEAS==DMM_RES4W)) strcat_s (buffer,"100E6,");
				else {config_passed = false;etsMessageBox("External meter measurement type/range mismatch.",MB_OK|MB_ICONSTOP);return (config_passed);}
				break;
			case DMM_RANGE_FREQ_ALL:		//For Freq measurements
				if (DMM_MEAS==DMM_FREQ) strcat_s (buffer,"DEF,"); //All frequency measurements are taken on the same range for all inputs between 3Hz and 300KHz.
				else {config_passed = false;etsMessageBox("External meter measurement type/range mismatch.",MB_OK|MB_ICONSTOP);return (config_passed);}
				break;
			default:
				config_passed = false;
				etsMessageBox("External meter invalid range selected.",MB_OK|MB_ICONSTOP);
				return (config_passed);
			}
			//Configure resolution - 
			//Resolution choices are as follows:
			//	0.0001xFull-Scale		0.02NPLC
			//  0.00001xFull-Scale		0.2NPLC
			//  0.000003xFull-Scale		1NPLC
			//  0.000001xFull-Scale	10NPLC (default)
			//  0.0000003xFull-Scale	100NPLC
			//  Frequency measurements are all auto_range/auto resolution.
			switch (DMM_RESOLUTION){
			case DMM_RES_AUTO:
				strcat_s (buffer,"DEF");
				break;
			case DMM_RES_20MPLC:  //	0.0001xFull-Scale		0.02NPLC
				//ACV, ACI & Freq measurements are done at fixed resolution.  PLC resolution control is for DCV, DCI and Resistance measurements only.
				if ((DMM_MEAS==DMM_DCV)||(DMM_MEAS==DMM_RES2W)||(DMM_MEAS==DMM_RES4W)) ;//config_passed = config_passed;
				else {config_passed = false;etsMessageBox("External meter measurement type/resolution mismatch.",MB_OK|MB_ICONSTOP);return (config_passed);}
				if (DMM_RANGE==DMM_RANGE_AUTO)		strcat_s (buffer,"DEF");	//Check your math

				if (DMM_RANGE==DMM_RANGE_100MV)		strcat_s (buffer,"10E-6");	//100mV	x	0.0001=10uV
				if (DMM_RANGE==DMM_RANGE_1V)		strcat_s (buffer,"100E-6");	//   1V	x	0.0001=100uV
				if (DMM_RANGE==DMM_RANGE_10V)		strcat_s (buffer,"1E-3");	//	10V x	0.0001=1mV
				if (DMM_RANGE==DMM_RANGE_100V)		strcat_s (buffer,"10E-3");	// 100V	x	0.0001=10mV 	
				if (DMM_RANGE==DMM_RANGE_1KV)		strcat_s (buffer,"100E-3");	//1000V x	0.0001=100mV

				if (DMM_RANGE==DMM_RANGE_10MA)		strcat_s (buffer,"1u");		// 10mA	x	0.0001=1uA
				if (DMM_RANGE==DMM_RANGE_1A)		strcat_s (buffer,"100E-6");	//	 1A	x	0.0001=100uA
				if (DMM_RANGE==DMM_RANGE_3A)		strcat_s (buffer,"300E-6");	//	 3A	x	0.0001=300uA

				if (DMM_RANGE==DMM_RANGE_100)		strcat_s (buffer,"10E-3");	//	100 x	0.0001=10m Ohm
				if (DMM_RANGE==DMM_RANGE_1K)		strcat_s (buffer,"100E-3");	//	 1K	x	0.0001=100m Ohm
				if (DMM_RANGE==DMM_RANGE_100K)		strcat_s (buffer,"10");		// 100K	x	0.0001=10 Ohm
				if (DMM_RANGE==DMM_RANGE_1M)		strcat_s (buffer,"100");	//   1M	x	0.0001=100 Ohm
				if (DMM_RANGE==DMM_RANGE_10M)		strcat_s (buffer,"1E3");	//	10M	x	0.0001=1K Ohm
				if (DMM_RANGE==DMM_RANGE_100M)		strcat_s (buffer,"10E3");	// 100M	x	0.0001=10K Ohm
				break;

			case DMM_RES_200MPLC:  //  0.00001xFull-Scale		0.2NPLC
				//ACV, ACI & Freq measurements are done at fixed resolution.  PLC resolution control is for DCV, DCI and resistance measurements only.
				if ((DMM_MEAS==DMM_DCV)||(DMM_MEAS==DMM_RES2W)||(DMM_MEAS==DMM_RES4W)) ;//config_passed = config_passed;
				else {config_passed = false;etsMessageBox("External meter measurement type/resolution mismatch.",MB_OK|MB_ICONSTOP);return (config_passed);}			
				if (DMM_RANGE==DMM_RANGE_AUTO)		strcat_s (buffer,"DEF");	//Check your math

				if (DMM_RANGE==DMM_RANGE_100MV)		strcat_s (buffer,"1E-6");	//100mV	x	0.00001=1uV
				if (DMM_RANGE==DMM_RANGE_1V)		strcat_s (buffer,"10E-6");	//   1V	x	0.00001=10uV
				if (DMM_RANGE==DMM_RANGE_10V)		strcat_s (buffer,"100E-6");	//	10V x	0.00001=100uV
				if (DMM_RANGE==DMM_RANGE_100V)		strcat_s (buffer,"1E-3");	// 100V	x	0.00001=1mV
				if (DMM_RANGE==DMM_RANGE_1KV)		strcat_s (buffer,"10E-3");	//1000V x	0.00001=10mV

				if (DMM_RANGE==DMM_RANGE_10MA)		strcat_s (buffer,"100E-9");	// 10mA	x	0.00001=100nA
				if (DMM_RANGE==DMM_RANGE_1A)		strcat_s (buffer,"10E-6");	//	 1A	x	0.00001=10uA
				if (DMM_RANGE==DMM_RANGE_3A)		strcat_s (buffer,"30E-6");	//	 3A	x	0.00001=30uA

				if (DMM_RANGE==DMM_RANGE_100)		strcat_s (buffer,"1E-3");	//	100 x	0.00001=1m Ohm
				if (DMM_RANGE==DMM_RANGE_1K)		strcat_s (buffer,"10E-3");	//	 1K	x	0.00001=10m Ohm
				if (DMM_RANGE==DMM_RANGE_100K)		strcat_s (buffer,"1");		// 100K	x	0.00001=1 Ohm
				if (DMM_RANGE==DMM_RANGE_1M)		strcat_s (buffer,"10");		//   1M	x	0.00001=10 Ohm
				if (DMM_RANGE==DMM_RANGE_10M)		strcat_s (buffer,"100");	//	10M	x	0.00001=100 Ohm
				if (DMM_RANGE==DMM_RANGE_100M)		strcat_s (buffer,"1E3");	// 100M	x	0.00001=1K Ohm
				break; 

			case DMM_RES_1PLC:  //  0.000003xFull-Scale		1NPLC
				if ((DMM_MEAS==DMM_DCV)||(DMM_MEAS==DMM_RES2W)||(DMM_MEAS==DMM_RES4W)) ;//config_passed = config_passed;
				else {config_passed = false;etsMessageBox("External meter measurement type/resolution mismatch.",MB_OK|MB_ICONSTOP);return (config_passed);}
				if (DMM_RANGE==DMM_RANGE_AUTO)		strcat_s (buffer,"DEF");	//Check your math

				if (DMM_RANGE==DMM_RANGE_100MV)		strcat_s (buffer,"300E-9");	//100mV	x	0.000003=300nV
				if (DMM_RANGE==DMM_RANGE_1V)		strcat_s (buffer,"3E-6");	//100mV	x	0.000003=3uV
				if (DMM_RANGE==DMM_RANGE_10V)		strcat_s (buffer,"30E-6");	//	10V x	0.000003=30uV
				if (DMM_RANGE==DMM_RANGE_100V)		strcat_s (buffer,"300E-6");	// 100V	x	0.000003=300uV
				if (DMM_RANGE==DMM_RANGE_1KV)		strcat_s (buffer,"3E-3");	//1000V x	0.000003=3mV

				if (DMM_RANGE==DMM_RANGE_10MA)		strcat_s (buffer,"30E-9");	// 10mA	x	0.000003=30nA
				if (DMM_RANGE==DMM_RANGE_1A)		strcat_s (buffer,"3E-6");	//	 1A	x	0.000003=3uA
				if (DMM_RANGE==DMM_RANGE_3A)		strcat_s (buffer,"9E-6");	//	 3A	x	0.000003=9uA

				if (DMM_RANGE==DMM_RANGE_100)		strcat_s (buffer,"300E-6");	//	100 x	0.000003=300u Ohm
				if (DMM_RANGE==DMM_RANGE_1K)		strcat_s (buffer,"3E-3");	//	 1K	x	0.000003=3m Ohm
				if (DMM_RANGE==DMM_RANGE_100K)		strcat_s (buffer,"300E-3");	// 100K	x	0.000003=300m Ohm
				if (DMM_RANGE==DMM_RANGE_1M)		strcat_s (buffer,"3");		//   1M	x	0.000003=3 Ohm
				if (DMM_RANGE==DMM_RANGE_10M)		strcat_s (buffer,"30");		//	10M	x	0.000003=30 Ohm
				if (DMM_RANGE==DMM_RANGE_100M)		strcat_s (buffer,"300");	// 100M	x	0.000003=300 Ohm
				break;

			case DMM_RES_10PLC:  //  0.000001xFull-Scale	10NPLC
				if ((DMM_MEAS==DMM_DCV)||(DMM_MEAS==DMM_RES2W)||(DMM_MEAS==DMM_RES4W)) ;//config_passed = config_passed;
				else {config_passed = false;etsMessageBox("External meter measurement type/resolution mismatch.",MB_OK|MB_ICONSTOP);return (config_passed);}
				if (DMM_RANGE==DMM_RANGE_AUTO)		strcat_s (buffer,"DEF");	//Check your math

				if (DMM_RANGE==DMM_RANGE_100MV)		strcat_s (buffer,"100E-9");	//100mV	x	0.000001=100nV
				if (DMM_RANGE==DMM_RANGE_1V)		strcat_s (buffer,"1E-6");		//100mV	x	0.000001=1uV
				if (DMM_RANGE==DMM_RANGE_10V)		strcat_s (buffer,"10E-6");	//	10V x	0.000001=10uV
				if (DMM_RANGE==DMM_RANGE_100V)		strcat_s (buffer,"100E-6");	// 100V	x	0.000001=100uV
				if (DMM_RANGE==DMM_RANGE_1KV)		strcat_s (buffer,"1E-3");	//1000V x	0.000001=1mV

				if (DMM_RANGE==DMM_RANGE_10MA)		strcat_s (buffer,"10E-9");	// 10mA	x	0.000001=10nA
				if (DMM_RANGE==DMM_RANGE_1A)		strcat_s (buffer,"1E-6");		//	 1A	x	0.000001=1uA
				if (DMM_RANGE==DMM_RANGE_3A)		strcat_s (buffer,"3E-6");		//	 3A	x	0.000001=3uA

				if (DMM_RANGE==DMM_RANGE_100)		strcat_s (buffer,"100E-6");	//	100 x	0.000001=100u Ohm
				if (DMM_RANGE==DMM_RANGE_1K)		strcat_s (buffer,"1E-3");	//	 1K	x	0.000001=1m Ohm
				if (DMM_RANGE==DMM_RANGE_100K)		strcat_s (buffer,"100E-3");	// 100K	x	0.000001=100m Ohm
				if (DMM_RANGE==DMM_RANGE_1M)		strcat_s (buffer,"1");		//   1M	x	0.000001=1 Ohm
				if (DMM_RANGE==DMM_RANGE_10M)		strcat_s (buffer,"10");		//	10M	x	0.000001=10 Ohm
				if (DMM_RANGE==DMM_RANGE_100M)		strcat_s (buffer,"100");	// 100M	x	0.000001=100 Ohm
				break;

			case DMM_RES_100PLC:  //  0.0000003xFull-Scale	100NPLC
				if ((DMM_MEAS==DMM_DCV)||(DMM_MEAS==DMM_RES2W)||(DMM_MEAS==DMM_RES4W)) ;//config_passed = config_passed;
				else {config_passed = false;etsMessageBox("External meter measurement type/resolution mismatch.",MB_OK|MB_ICONSTOP);return (config_passed);}
				if (DMM_RANGE==DMM_RANGE_AUTO)		strcat_s (buffer,"DEF");	//Check your math

				if (DMM_RANGE==DMM_RANGE_100MV)		strcat_s (buffer,"30E-9");	//100mV	x	0.0000003=30nV
				if (DMM_RANGE==DMM_RANGE_1V)		strcat_s (buffer,"300E-9");	//100mV	x	0.0000003=300uV
				if (DMM_RANGE==DMM_RANGE_10V)		strcat_s (buffer,"3E-6");	//	10V x	0.0000003=3uV
				if (DMM_RANGE==DMM_RANGE_100V)		strcat_s (buffer,"30E-6");	// 100V	x	0.0000003=30uV
				if (DMM_RANGE==DMM_RANGE_1KV)		strcat_s (buffer,"300E-6");	//1000V x	0.0000003=300uV

				if (DMM_RANGE==DMM_RANGE_10MA)		strcat_s (buffer,"3E-9");	// 10mA	x	0.0000003=3nA
				if (DMM_RANGE==DMM_RANGE_1A)		strcat_s (buffer,"300E-9");	//	 1A	x	0.0000003=300nA
				if (DMM_RANGE==DMM_RANGE_3A)		strcat_s (buffer,"900E-9");	//	 3A	x	0.0000003=900nA

				if (DMM_RANGE==DMM_RANGE_100)		strcat_s (buffer,"30E-6");	//	100 x	0.0000003=30u Ohm
				if (DMM_RANGE==DMM_RANGE_1K)		strcat_s (buffer,"300E-6");	//	 1K	x	0.0000003=300u Ohm
				if (DMM_RANGE==DMM_RANGE_100K)		strcat_s (buffer,"30E-3");	// 100K	x	0.0000003=30m Ohm
				if (DMM_RANGE==DMM_RANGE_1M)		strcat_s (buffer,"300E-3");	//   1M	x	0.0000003=300m Ohm
				if (DMM_RANGE==DMM_RANGE_10M)		strcat_s (buffer,"3");		//	10M	x	0.0000003=3 Ohm
				if (DMM_RANGE==DMM_RANGE_100M)		strcat_s (buffer,"30");		// 100M	x	0.0000003=30 Ohm
				break;

			case DMM_RES_AC_ALL: //For AC measurements, resolution is actually fixed at max resolution.  Resolution parameter only affects front-panel display.
				if((DMM_MEAS==DMM_ACV)||(DMM_MEAS==DMM_ACI)) strcat_s (buffer,"DEF");
				else {config_passed = false; etsMessageBox("External meter resolution for all AC measurements is 'DMM_RES_AC_ALL'.",MB_OK|MB_ICONSTOP); return (config_passed);}
				break;

			case DMM_RES_FREQ_ALL:  //For frequency measurements, resolution is controlled by Aperture setting, not range/resolution setting.
				if (DMM_RANGE==DMM_RANGE_FREQ_ALL) strcat_s (buffer,"DEF");
				else {config_passed = false; etsMessageBox("External meter resolution for all Freq measurements is 'DMM_RES_FREQ_ALL'.",MB_OK|MB_ICONSTOP); return (config_passed);}
				break;

			default:
				config_passed = false;
				etsMessageBox("External meter invalid resolution selected.",MB_OK|MB_ICONSTOP);
				return (config_passed);
			}

			//If config is good, send to meter.
			ptr=&buffer[0];
			status = gpibsend(gi_DMM_ADDRESS,ptr); 
			if (status == GPIB_SEND_FAILED) 
				return false;

			//Config DMM_APERTURE, if applicable - only for ACV, ACI or Frequency measurements.
			switch (DMM_APERTURE){
			case DMM_APE_NA:
				break;
			case DMM_APE_10MS:
				if ((DMM_MEAS==DMM_ACV)||(DMM_MEAS==DMM_ACI)||(DMM_MEAS==DMM_FREQ)) {status = gpibsend(gi_DMM_ADDRESS,"FREQ:APER 0.01"); if (status == GPIB_SEND_FAILED) return false;}
				else {config_passed = false;etsMessageBox("External meter Aperture setting for AC & Freq measurements only.",MB_OK|MB_ICONSTOP);return (config_passed);}
				break;
			case DMM_APE_100MS:
				if ((DMM_MEAS==DMM_ACV)||(DMM_MEAS==DMM_ACI)||(DMM_MEAS==DMM_FREQ)) {status = gpibsend(gi_DMM_ADDRESS,"FREQ:APER 0.1"); if (status == GPIB_SEND_FAILED) return false;}
				else {config_passed = false;etsMessageBox("External meter Aperture setting for AC & Freq measurements only.",MB_OK|MB_ICONSTOP);return (config_passed);}
				break;
			case DMM_APE_1S:
				if ((DMM_MEAS==DMM_ACV)||(DMM_MEAS==DMM_ACI)||(DMM_MEAS==DMM_FREQ)) {status = gpibsend(gi_DMM_ADDRESS,"FREQ:APER 1"); if (status == GPIB_SEND_FAILED) return false;}
				else {config_passed = false;etsMessageBox("External meter Aperture setting for AC & Freq measurements only.",MB_OK|MB_ICONSTOP);return (config_passed);}
				break;
			default:
				config_passed = false;
				etsMessageBox("External meter invalid frequency aperture selected.",MB_OK|MB_ICONSTOP);
				return (config_passed);
			}	

			//Config DMM_ACFILTER, if applicable - only for ACV, ACI or Frequency measurements.
			switch (DMM_ACFILTER){
			case DMM_FILT_NA:
				break;
			case DMM_FILT_SLOW:
				if ((DMM_MEAS==DMM_ACV)||(DMM_MEAS==DMM_ACI)||(DMM_MEAS==DMM_FREQ)) ;//config_passed=config_passed;
				else {config_passed = false;etsMessageBox("External meter AC filter setting for AC & Freq measurements only.",MB_OK|MB_ICONSTOP);return (config_passed);}
				status = gpibsend(gi_DMM_ADDRESS,"DET:BAND 3"); if (status == GPIB_SEND_FAILED) return false;
				break;
			case DMM_FILT_MED:
				if ((DMM_MEAS==DMM_ACV)||(DMM_MEAS==DMM_ACI)||(DMM_MEAS==DMM_FREQ)) ;//config_passed=config_passed;
				else {config_passed = false;etsMessageBox("External meter AC filter setting for AC & Freq measurements only.",MB_OK|MB_ICONSTOP);return (config_passed);}		
				status = gpibsend(gi_DMM_ADDRESS,"DET:BAND 20"); if (status == GPIB_SEND_FAILED) return false;
				break;
			case DMM_FILT_FAST:
				if ((DMM_MEAS==DMM_ACV)||(DMM_MEAS==DMM_ACI)||(DMM_MEAS==DMM_FREQ)) ;//config_passed=config_passed;
				else {config_passed = false;etsMessageBox("External meter AC filter setting for AC & Freq measurements only.",MB_OK|MB_ICONSTOP);return (config_passed);}
				status = gpibsend(gi_DMM_ADDRESS,"DET:BAND 200"); if (status == GPIB_SEND_FAILED) return false;
				break;
			default:
				config_passed = false;
				etsMessageBox("External meter invalid AC filter selected.",MB_OK|MB_ICONSTOP);
				return (config_passed);
			}


			//Config DMM_INPUTIMPEDANCE, if applicable - only for DCV measurements.  10G input only for DCV measurements on 100mV, 1V or 10V range.
			switch (DMM_INPUTIMPEDANCE){
			case DMM_INPUT_NA:
				break;
			case DMM_INPUT_10M:
				if(DMM_MEAS==DMM_DCV) {status = gpibsend(gi_DMM_ADDRESS,"INP:IMP:AUTO OFF"); if (status == GPIB_SEND_FAILED) return false;}
				else {config_passed = false;etsMessageBox("External meter measurement type/input impedance mismatch.",MB_OK|MB_ICONSTOP);return (config_passed);}
				break;
			case DMM_INPUT_10G:
				if ((DMM_MEAS==DMM_DCV)&&((DMM_RANGE==DMM_RANGE_100MV)||(DMM_RANGE==DMM_RANGE_1V)||(DMM_RANGE==DMM_RANGE_10V))) {status = gpibsend(gi_DMM_ADDRESS,"INP:IMP:AUTO ON"); if (status == GPIB_SEND_FAILED) return false;}
				else {config_passed = false;etsMessageBox("External meter 10G input impedance for DCV 100mV, 1V and 10V range only.",MB_OK|MB_ICONSTOP);return (config_passed);}	
				break;
			default:
				config_passed = false;
				etsMessageBox("External meter invalid input impedance selected.",MB_OK|MB_ICONSTOP);
				return (config_passed);
			}

			//Config DMM_TRIGGER, if applicable
			switch (DMM_TRIGGER){
			case DMM_TRIG_NA:
				break;
			case DMM_TRIG_INT:
				status = gpibsend(gi_DMM_ADDRESS,"TRIG:SOUR IMM"); if (status == GPIB_SEND_FAILED) return false;
				break;
			case DMM_TRIG_EXT:
				status = gpibsend(gi_DMM_ADDRESS,"TRIG:SOUR EXT"); if (status == GPIB_SEND_FAILED) return false;
				break;
			default:
				config_passed = false;
				etsMessageBox("External meter invalid trigger source selected.",MB_OK|MB_ICONSTOP);
				return (config_passed);
			}

			//Set global variable & return passing status
			if (DMM::bHasError(true))	//Check the meter configuration for an error. Display the error string in a pop-up box.
			{
				gb_DMM_CONFIG_DONE = false;
				return (false);
			}
			else
			{
				gb_DMM_CONFIG_DONE = true;
				return (config_passed);

			}
		}

		/************************************************************************************************************************************************************For*Doxygen**//**
		Return a single measurement from the meter using the current configuration settings.

		@returns	Returns the measurement.  Will return gcondMeterError if there is an error.
		**************************************************************************************************************************************************************/
		double Meas(void) {
			int status;			
			double result = gcondMeterError;
			char buffer[256]="";
			char *ptr=&buffer[0];
			DMM_TERMINALTYPE DMM_terminals;

			//Check to see that Config passed at least once.  Check that terminals are set to rear.
			if (gb_DMM_CONFIG_DONE == false) {etsMessageBox("External meter not configured before measurement.",MB_OK|MB_ICONSTOP);return gcondMeterError;}
			DMM_terminals = DMM::TerminalCheck();
			if (DMM_terminals==DMM_CONN_FRONT) {etsMessageBox("External meter must be set to REAR terminals.",MB_OK|MB_ICONSTOP);return gcondMeterError;}

			status = gpibsend(gi_DMM_ADDRESS,"READ?"); if (status == GPIB_SEND_FAILED) return gcondMeterError; //request results stored in DMM buffer
			status = gpibreceive(gi_DMM_ADDRESS,buffer,256); if (status == GPIB_RECEIVE_FAILED) return gcondMeterError; //receive DMM results
			ptr=&buffer[0];
			result = atof (ptr);

			return (result);
		}
		//Take multiple measurements, return average *************************************************************************************
		double Meas_Avg(int numsamp) {
			int status;
			double result = gcondMeterError;  //need to add 2nd function to grab array of measurements if configured for more than 1.
			char buffer[256]="";
			char *ptr=&buffer[0];
			double sum=0;
			DMM_TERMINALTYPE DMM_terminals;

			//Check to see that Config passed at least once.  Check that terminals are set to rear.
			if (gb_DMM_CONFIG_DONE == false) {etsMessageBox("External meter not configured before measurement.",MB_OK|MB_ICONSTOP);return gcondMeterError;}
			DMM_terminals = DMM::TerminalCheck();
			if (DMM_terminals==DMM_CONN_FRONT) {etsMessageBox("External meter must be set to REAR terminals.",MB_OK|MB_ICONSTOP);return gcondMeterError;}
			if (numsamp < 1) {etsMessageBox("Meas_Avg must have at least one sample.",MB_OK|MB_ICONSTOP);return gcondMeterError;}

			for(int i=0;i<numsamp;i++) {
				status = gpibsend(gi_DMM_ADDRESS, "INIT"); if (status == GPIB_SEND_FAILED) return gcondMeterError; //initiate reading, results are stored in DMM onboard buffer
				lwait( 1000 ); //wait 1mS
				status = gpibsend(gi_DMM_ADDRESS,"READ?"); if (status == GPIB_SEND_FAILED) return gcondMeterError; //request results stored in DMM buffer
				status = gpibreceive(gi_DMM_ADDRESS,buffer,256); if (status == GPIB_RECEIVE_FAILED) return gcondMeterError; //receive DMM results
				ptr=&buffer[0];
				sum += atof (ptr);
			}
			result = sum/double(numsamp);  //avoid mixing integers and doubles
			return (result);
		}
		//Initialize DMM *****************************************************************************************************
		bool DMM::Init(void) {	
			int status;
			DMM_TERMINALTYPE DMM_Terminals;
			if (!GetGPIBAddress())		//Save the GPIB address as a global.
				return (false); 		//popup message already in GetGPIBAddress
			status = gpibsend(gi_DMM_ADDRESS,"*RST"); if (status == GPIB_SEND_FAILED) return false;
			status = gpibsend(gi_DMM_ADDRESS,"*CLS"); if (status == GPIB_SEND_FAILED) return false;	
			DMM_Terminals=DMM::TerminalCheck();
			if (DMM_Terminals==DMM_CONN_FRONT) return (false);  //popup message already in DMM::TerminalCheck
			return (true);
		}
		//Force Autozero *****************************************************************************************************
		bool DMM::Autozero(bool bEnabled) {
			int status;
			status = gpibsend(gi_DMM_ADDRESS,"ZERO:AUTO ONCE"); //'ONCE' setting forces an immediate autozero, but turns automatic autozero off.
			if (status == GPIB_SEND_FAILED) 
				return false;  
			if (bEnabled) 
			{
				status = gpibsend(gi_DMM_ADDRESS,"ZERO:AUTO ON"); //turn on AutoZero
				if (status == GPIB_SEND_FAILED) 
					return false;
			}
			return (true);
		}


		/************************************************************************************************************************************************************For*Doxygen**//**
		Returns the error string if the meter had an error. 
		
		@param	[bDisplayMsgBox] Use true to display the error string in a pop up box for the operator.  This will halt program execution.
		
		@return		The error string is returned if there was an error.  See Remarks.  If the system is offline, or there was no error, an empty string is returned.

		@remarks
				See meter manual.  Errors may occur due to invalid configuration commands, over-range errors, meter hardware errors, etc.
				The error queue is cleared by the CLS command in DMM:Init()
		**************************************************************************************************************************************************************/
		std::string DMM::sGetError(bool bDisplayMsgBox) {
			int status;
			char buffer[256]="",buffer2[256]="";
			char *ptr=&buffer[0];
			if (Maxim::System::bOnline()) 
			{
				status = gpibsend(gi_DMM_ADDRESS,"SYST:ERR?"); 
				if (status == GPIB_SEND_FAILED) 
				{
					if (bDisplayMsgBox)
					{
						etsMessageBox("GPIB Send Communication Error",MB_OK|MB_ICONSTOP);
					}
					return "GPIB Send Communication Error";
				}
				status = gpibreceive(gi_DMM_ADDRESS,buffer,256);	//No need to check the status of the gpibreceive command.  
				//													//It always fails when offline and only passes if it returns "+".
				if (buffer[0]=='+') return "";  //no error.
				sprintf_s(buffer2, "External meter Error # %s  Consult User Manual.", ptr);
				ptr=&buffer2[0];
				if (bDisplayMsgBox)
				{
					etsMessageBox(ptr,MB_OK|MB_ICONSTOP);
				}
				return buffer2;
			}
			else
			{
				return "";	//return no error if offline
			}
		}

		/************************************************************************************************************************************************************For*Doxygen**//**
		Returns true if the meter had an error. 
		
		@param	[bDisplayMsgBox] Use true to display the error string in a pop up box for the operator.  This will halt program execution.
		
		@return		True if there was an error.  False if not.  See Remarks.  
		
		@remarks
				See meter manual.  Errors may occur due to invalid configuration commands, over-range errors, meter hardware errors, etc.
				The error queue is cleared by the CLS command in DMM:Init()		
		**************************************************************************************************************************************************************/
		bool DMM::bHasError(bool bDisplayMsgBox) {
			std::string sError;
			sError = DMM::sGetError(bDisplayMsgBox);
			if (sError.length() > 0) 
				return true;
			else
				return false;
		}


		/************************************************************************************************************************************************************For*Doxygen**//**
		Determine if the input terminals are set to the front or back of the meter.
		
		@return		DMM_CONN_FRONT or DMM_CONN_REAR.
		**************************************************************************************************************************************************************/
		DMM_TERMINALTYPE DMM::TerminalCheck(void) {
			int status;
			char buffer[256];
			status = gpibsend(gi_DMM_ADDRESS,"ROUT:TERM?"); if (status == GPIB_SEND_FAILED) return DMM_CONN_REAR;   //returns "FRON" or "REAR"
			status = gpibreceive(gi_DMM_ADDRESS,buffer,256); if (status == GPIB_RECEIVE_FAILED) return DMM_CONN_REAR;   
			if (buffer[0]=='F') {etsMessageBox("External Meter must be set to REAR terminals.",MB_OK|MB_ICONSTOP);return (DMM_CONN_FRONT);}
			else return (DMM_CONN_REAR);
		}

		/************************************************************************************************************************************************************For*Doxygen**//**
		Set internal or external triggering

		@param	[DMM_TRIGGER] DMM_TRIG_NA, DMM_TRIG_INT, or DMM_TRIG_EXT.

		@remarks
				See Manual.  Internal trigger will continuously make measurements.  
				External will only capture the measurement when the trigger signal is sent to the meter's sync line.
		**************************************************************************************************************************************************************/
		bool DMM::TriggerSet(DMM_TRIGGERTYPE DMM_TRIGGER) {
			int status;
			bool result = true;
			switch (DMM_TRIGGER){
				case DMM_TRIG_NA:
						break;
				case DMM_TRIG_INT:
					status = gpibsend(gi_DMM_ADDRESS,"TRIG:SOUR IMM"); if (status == GPIB_SEND_FAILED) return false;
					break;
				case DMM_TRIG_EXT:
					status = gpibsend(gi_DMM_ADDRESS,"TRIG:SOUR EXT"); if (status == GPIB_SEND_FAILED) return false;
					break;
				default:
					etsMessageBox("External meter invalid trigger source selected.",MB_OK|MB_ICONSTOP);
					result = false;
			}
			return (result);
		}

		/************************************************************************************************************************************************************For*Doxygen**//**
		Turn front panel display on/off.  Also clear any text printed to the display with the DMM:printf function.

		@param	[DMM_DISPLAY] DMM_DISP_ON, DMM_DISP_OFF, or DMM_DISP_CLEAR.

		@remarks	For faster measurements, turn off the display.
		**************************************************************************************************************************************************************/
		void DMM::Display(DMM_DISPLAYTYPE DMM_DISPLAY) {
			switch (DMM_DISPLAY){
				case DMM_DISP_ON:
					gpibsend(gi_DMM_ADDRESS,"DISP ON");
					break;
				case DMM_DISP_OFF:
					gpibsend(gi_DMM_ADDRESS,"DISP OFF");
					break;
				case DMM_DISP_CLEAR:
					gpibsend(gi_DMM_ADDRESS,"DISP:TEXT:CLE");
					break;
				default:
					break;
			}
			return;
		}
	
		/************************************************************************************************************************************************************For*Doxygen**//**
		Print to the meter's front panel display
		
		@param	[str] String to print.  The display can show up to 12 characters.

		@remarks:
				Use DMM::Display(DMM_DISP_CLEAR); to clear the string and resume displaying measurements.
		**************************************************************************************************************************************************************/
		void DMM::printf(const char *str) {
			char buffer[256]="";
			char *ptr=&buffer[0];
			ptr =& buffer[0];
			strcpy_s(buffer,"DISP:TEXT ");
			strcat_s(buffer, "'");  //add single quote
			strcat_s(buffer, str);
			strcat_s(buffer, "'");  //add single quote
			gpibsend(gi_DMM_ADDRESS,ptr);  
			return;
		}

		/************************************************************************************************************************************************************For*Doxygen**//**
		Maxim Function to return the GPIB address based on sector number of the running DLL.
		
		@returns	True if the GPIB address was set.  False if the sector number could not be identified.
		
		@remarks
				See function GetETSSector.  Sector 1A and 1B have different GPIB addresses to prevent crossed GPIB communication cables.  
				If the cable for sector 1A is accidentally connected to the meter connected to sector 1B, the meter will see the wrong GPIB address and not respond.
				This works because each sector runs on its own isolated executable.  So each sector can have a different GPIB address.
				The Meter GPIB addresses must be initially correctly configured when the tester is setup. 
		**************************************************************************************************************************************************************/
		bool DMM::GetGPIBAddress() {
			Maxim::System::ETSSector eETSSector;
			eETSSector = Maxim::System::GetETSSector();
			if (eETSSector == Maxim::System::ETSSector1A)	//Sector 1A
			{
				gi_DMM_ADDRESS =  gconiDMM_ADDRESS_SECTOR1A;	//Set the global
				return true;
			}
			else if (eETSSector == Maxim::System::ETSSector1B)	//Sector 1B
			{
				gi_DMM_ADDRESS =  gconiDMM_ADDRESS_SECTOR1B;	//Set the global
				return true;
			}
			else	//Unknown sector
			{
				etsMessageBox("External meter invalid tester sector number.  Cannot determine meter GPIB address.",MB_OK|MB_ICONSTOP);
				gi_DMM_ADDRESS =  -1;	//Error
				return false;
			}			
		}
		/************************************************************************************************************************************************************For*Doxygen**//**
		Initialize and configure the external meter with standard settings.  This function is called in Lib_UserInit.                                         

		@returns	true if meter Init and configuration was successful.  false if there was a communication failure.

		@remarks
				Sets default configuration to measure DC voltage on 10V Range with 10Gig input impedance.  Turns on Autozero for better accuracy.
				Do not modify this function.  If you need different meter settings, call Maxim::Meter::DMM::Config() in the Maxim_UserInit function 
				to overwrite the settings.  This makes it simpler to keep the MaximLib files updated.
				
		**************************************************************************************************************************************************************/
		//Do not modify this function. 
		bool DMM::Init_And_Config_Maxim_Standard()
		{
			//Initialize the external meter
			if (!DMM::Init())
			{					
				etsMessageBox("External meter failed initialization.  Check the GPIB cable.",MB_OK|MB_ICONSTOP, 940);		
				return FALSE;	//Could not initialize the meter, halt loading
			}

			//Do not modify this function.  See above.
			//Set default configuration to measure DC voltage on 10V Range with 10Gig input impedance. 
			//if (!DMM::Config(DMM_MEASTYPE::DMM_DCV, DMM_RANGETYPE::DMM_RANGE_10V, DMM_RESOLUTIONTYPE::DMM_RES_AUTO, DMM_APERTURETYPE::DMM_APE_NA, 
			//						DMM_ACFILTERTYPE::DMM_FILT_NA, DMM_INPUTIMPEDANCETYPE::DMM_INPUT_10G, DMM_TRIGGERTYPE::DMM_TRIG_INT))
			if (!DMM::Config(DMM_DCV, DMM_RANGE_10V, DMM_RES_1PLC, DMM_APE_NA, DMM_FILT_NA, DMM_INPUT_10G, DMM_TRIG_INT))
			{					
				etsMessageBox("External meter failed configuration.  Check the config settings.",MB_OK|MB_ICONSTOP, 940);		
				return FALSE;	//Could not configure the meter, halt loading
			}				
				
			//Turn on meter auto zero for better accuracy.
			if (!DMM::Autozero(true))	
			{					
				etsMessageBox("External meter could not be set to Autozero.  Communication failure.",MB_OK|MB_ICONSTOP, 940);	
				return FALSE;
			}

#ifdef MAXIM_VERBOSE
			//Print the sector number on the meter display.
			DMM::Display(DMM_DISP_ON);			
			std::string sSector = Maxim::System::GetETSSectorString();
			sSector = "SECTOR " + sSector;
			DMM::printf(sSector.c_str());
			lwait(3 s_f);	//Display for 3 seconds
			DMM::Display(DMM_DISP_CLEAR);	//clear the display so it will show measurements.

			//Print to the Shell output window.	
			sSector = "Configured " + sSector + " Meter\n";
			etsprintf(sSector.c_str());		
#endif 

			//Turn the meter display off for faster measurements. 
			DMM::Display(DMM_DISP_OFF);

			//Check if the meter has any configuration errors.  Display any error to operator in pop-up box.
			if (DMM::bHasError(true)) 
				return false;
			else
				return true;
		}


		//End DMM functions
	}
}