//DO NOT EDIT THIS FILE
/*** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-
*                                                                            
*	Source title:		Maximlib_APU.CPP                                                                            		  
*	URL:				$URL: https://svn.maxim-ic.com/svn/ets/test_programs/AP89/AP89_FT/Trunk/MaximLib/MaximLib_APU.cpp $
*   Last Modified by:	$LastChangedBy: govit.pimthong $                                       
*	Date:				$Date: 2017-03-09 12:55:55 +0700 (Thu, 09 Mar 2017) $                                                
*   Current Rev:		$Revision: 61735 $
*                                                                            
*	Description:  
*		Maxim library file for APU
*		Maxim library written and maintained by:								 
*			Patrick Hayes (Patrick.Hayes@MaximIntegrated.com)	                 
*			Mark Bruening (Mark.Bruening@MaximIntegrated.com)                                                                            
*
*   Revision History
*		
*                                                                            
**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****/
//DO NOT EDIT THIS FILE

/**********************************************************************************************************************************************For*Doxygen**//**
@file	Maximlib_APU.CPP
@brief	Maxim library file for APU
**************************************************************************************************************************************************************/

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
#define MAXIMLIB_LIB



//	PinListData Maximapu12mv( int iPinGroup, int numsamples, double sampledelay, vector<int> viSiteList)
	PinListData Maximapu12mv( int iPinGroup, int numsamples, double sampledelay)
	{
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();
#endif
/*  Experimenting with idea for disabling site, but it seems msSiteUserDisabled will be
      a better solution.
		int iPinGroupTemporary = iPinGroup;

		if(find(viSiteList.begin(), viSiteList.end(), MS_ALL)==viSiteList.end()){
			vector<int> viPinGroup = Maxim::System::GetResources(iPinGroup);
			iPinGroupTemporary = Maxim::System::FindAvailableGroupNumber();
		}
*/


		//Need to handle a single instrument different from a PMEInt or GMEInt which are groups of pins.
		if (iPinGroup < 256)
		{
			PinListData pldMeasured;
			pldMeasured[Maxim::PinMap::mapResourceChannelSite[NAME_APU12][iPinGroup]] = apu12mv(iPinGroup, numsamples, sampledelay);
			return pldMeasured;
		}
		else
		{
			apu12mv(iPinGroup, numsamples, sampledelay);
			return pld_groupgetresults(Maxim::PinMap::CountResources(iPinGroup));
		}
	}

	
	PinListData Maximapu12mi( int iPinGroup, int imeasgain, int numsamples, double sampledelay )
	{
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();
#endif

		//Need to handle a single instrument different from a PMEInt or GMEInt which are groups of pins.
		if (iPinGroup < 256)
		{
			PinListData pldMeasured;
			pldMeasured[Maxim::PinMap::mapResourceChannelSite[NAME_APU12][iPinGroup]] = apu12mi(iPinGroup, imeasgain, numsamples, sampledelay);

			return pldMeasured;
		}
		else
		{
			apu12mi(iPinGroup, imeasgain, numsamples, sampledelay);
			return pld_groupgetresults(Maxim::PinMap::CountResources(iPinGroup));
		}

	}


	PinListData Maximapu12getwhereat( int iPinGroup, int thresholdNum)
	{
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();
#endif
		apu12getwhereat(iPinGroup,thresholdNum);
		return pld_groupgetresults(Maxim::PinMap::CountResources(iPinGroup));	//PME_INT only has one pin
		
	}


	int Maximapu12init( int pin)
	{
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();
#endif
		return apu12init( pin ); 
	}
	
	int Maximapu12set( int pin, int mode, double value, int vrange, int irange, int connect)
	{	
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();
#endif
		return apu12set( pin, mode,  value,  vrange,  irange,  connect); 
	}
	
	int Maximapu12set( int pin, int mode, SiteDouble sdValue, int vrange, int irange, int connect)
	{	
		ACCUMULATOR_STR accValue[MAX_SITES];           //Use accumulator to set APUs in different state

		// If all sites are equal, call the standard version which has the potential to be faster
		if(sdValue.AreAllSitesEqual()) 		return Maximapu12set (  pin,  mode,  sdValue[0],  vrange,  irange, connect); 

#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();
#endif

		for (int iSite = 0; iSite<Maxim::GetNumSites(); iSite++)
		{
			accValue[iSite].value1=sdValue[iSite];   //load site values into accumulator
		}
		groupsetaccumulator(accValue, giNumSites);
				
		return apu12set( pin, mode,  USE_ACCUM,  vrange,  irange,  connect);   //USE_ACCUM tells apu to check magic accumulator mailbox
	}

	int Maximapu12setcapload( int pin, int mode, double value, int vrange, int irange, double risetime, int connect)
	{	
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();
#endif
		return apu12setcapload(  pin,  mode,  value,  vrange,  irange,  risetime,  connect ); 
	}
	
	int Maximapu12compare( int pin, double llimit, double ulimit, int numsamples, double sampledelay )
	{	
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();
#endif
		return apu12compare(  pin,  llimit,  ulimit,  numsamples,  sampledelay ); 
	}
	
	int Maximapu12connectbanks( int pin, int low, int busA, int busB )
	{	
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();
#endif
		return apu12connectbanks(  pin,  low,  busA,  busB ); 
	}

	int Maximapu12kelvinmode( int pin, int mode )
	{	
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();
#endif
		return apu12kelvinmode(  pin,  mode ); 
	}
	
namespace Maxim
{
	/************************************************************************************************************************************************************For*Doxygen**//**
	Tell the "No Site" pin that it is physically connected to this site.  Required for the Measurement and Datalog functions.                                              
	
	@param	[pmeAPUPin]  A single APU12 channel
	@param	[iSite] The site to connect to.  Measurements will be associated with this site.  Pass NO_SITE to disassociate the pin with a site.

	@returns	Zero on success.  Nonzero on failure (see msGroupSiteModify)
	
	@remarks	The APU12 pin should be setup on the Pin Map Editor as a No Site to use this.
	**************************************************************************************************************************************************************/
	int Connect_APU_Pin_To_Site(PME_INT pmeAPUPin, int iSite)
	{
		int iStatus = -1, i;
		int iPinNumber = pmeAPUPin[1];	//In a pin of type no site, the channel at index 1 is the pin number
		//TODO: verify input parameters
		//if (pmeAPUPin.Device != 
		if (((iSite < 0) || (iSite >= giNumSites)) && (iSite != NO_SITE))
		{
			etsprintf("Error!  Invalid site provided to Connect_APU_Pin_To_Site function.\n");
			return iStatus;		//msGroupSiteModify returns nonzero to indicate failure.  
		}

		//First, remove the pin from all sites.
		for (i = 0; i < giNumSites; i++)
		{
			iStatus = msGroupSiteModify(i, FALSE, "APU12_%d", iPinNumber);	
			//TODO?  report if msGroupSiteModify returns a failure here?
		}
		//Now add it to the site
		if ((iSite >= 0) && (iSite <giNumSites))
		{	
			iStatus = msGroupSiteModify(iSite, TRUE, "APU12_%d", iPinNumber);	//Add the pin to the site
		}
		return iStatus;
	}
} // End of Maxim namespace