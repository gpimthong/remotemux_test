//DO NOT EDIT THIS FILE
/*** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-
*                                                                            
*	Source title:		Maximlib_CBIT.CPP                                                                            		  
*	URL:				$URL: https://svn.maxim-ic.com/svn/ets/test_programs/AP89/AP89_FT/Trunk/MaximLib/MaximLib_CBIT.cpp $
*   Last Modified by:	$LastChangedBy: govit.pimthong $                                       
*	Date:				$Date: 2017-03-09 12:55:55 +0700 (Thu, 09 Mar 2017) $                                                
*   Current Rev:		$Revision: 61735 $
*                                                                            
*	Description:  
*		Maxim library file for CBIT
*		Maxim library written and maintained by:								 
*			Patrick Hayes (Patrick.Hayes@Maxim-IC.com)	                 
*			Mark Bruening (Mark.Bruening@Maxim-IC.com)
*			Brad Sitton (Brad.Sitton@Maxim-IC.com)
*
*   Revision History
*		
*                                                                            
**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****-**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****/
//DO NOT EDIT THIS FILE

/**********************************************************************************************************************************************For*Doxygen**//**
@file	MaximLib_CBit.cpp
@brief	Library file for CBit control  
**************************************************************************************************************************************************************/

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
#define MAXIMLIB_LIB


// disable warnings about long names
#ifdef WIN32
  #pragma warning( disable : 4786)
#endif

namespace Maxim {
	///@brief Namespace for CBit control functions
	namespace CBits {


/************************************************************************************************************************************************************For*Doxygen**//**
Associates a specific CBit to a specific type of relay.  This is required for timingMaximCBitGroupSet.  This function should be called AFTER the CBit has been defined.

@param	iCBitNumber        CBit number or Group number that an assignment is being made to.
@param  sRelayType        The Maxim inventory number of the type of relay connected to the CBit.

@remark Only required if you plan to use the WaitUntilRelaysSettle function.
		Lets each CBit know which type of relay it is connected to so that delay times can be calculated properly.
		Ideally this would be automatically generated from your schematic.
		Will automatically load the relay specifications if they exist in MaximLib_CBIT_Relay_Specs.h. 
			It is much preferred to have the library add any relays you need to the csv file.
			If you can't wait, you will need to make a call to DefineRelaySpecifications.

As an example, you could place the following lines in Maxim_UserInit() 
@code
	Maxim::CBits::AssignCBitToRelay(K200, "70-98140500-00");  // This assumes all relays in a group are of the same type.
															  // Otherwise you need to set the types on a CBit by CBit basis.
	Maxim::CBits::AssignCBitToRelay(K26, "70-98140500-00");   // Assumes K26 was defined in the pin map editor.
	Maxim::CBits::AssignCBitToRelay(K27, "70-98140500-00");   // Assumes K27 was defined in the pin map editor.
@endcode

**************************************************************************************************************************************************************/
void AssignCBitToRelay(int iCBitNumber, std::string sRelayType){
	Maxim::CBits::Extended::maximCBits.mapCBits[iCBitNumber].SetRelayType(sRelayType);
}


/************************************************************************************************************************************************************For*Doxygen**//**
Creates a relay driver object and adds it to the appropriate relay driver map.

@param	sDesignator			The name that will be use when referring to this specific relay driver.
@param	relayDriverType		Specifies the type of relay driver so that the appropriate communication routines will be called.
@param	viCBitList			Vector of CBits that are controlled by the relay driver.
@param	iDriverAddress		The chip address for your relay driver (if required).  For example each i2c relay driver should have a different
**************************************************************************************************************************************************************/

void DefineRelayDriver( std::string sDesignator, Maxim::CBits::RelayDriverType relayDriverType, std::vector<int> viCBitList, int iDriverAddress){

	// Need to delete the relay driver if it was previously defined so that the "new" assignments later in this function will not be a problem.
	//   In general one should never re-define a relay driver, but it can happen so we want to handle the situation gracefully.
	if(Maxim::CBits::Extended::mapRelayDriver.count(sDesignator)) {
		delete Maxim::CBits::Extended::mapRelayDriver[sDesignator];
		Maxim::CBits::Extended::mapRelayDriver.erase(sDesignator);
	}
	// Now assign pointer to global map
	switch (relayDriverType) {
		case Maxim::CBits::RelayDriverETS :
			Maxim::CBits::Extended::mapRelayDriver[sDesignator] = new Maxim::CBits::Extended::TesterRelayDriver(sDesignator, viCBitList, (char) iDriverAddress);
			break;
		case Maxim::CBits::RelayDriverPCA9671 :
			Maxim::CBits::Extended::mapRelayDriver[sDesignator] = new Maxim::CBits::Extended::PCA9671RelayDriver(sDesignator, viCBitList, iDriverAddress);
			break;
		case Maxim::CBits::RelayDriverGroup: 
			Maxim::CBits::Extended::mapRelayDriver[sDesignator] = new Maxim::CBits::Extended::MaximCBitGroupRelayDriver(sDesignator, viCBitList, iDriverAddress);
			break;
		default:
			if (sDesignator != "UNKNOWN"){
				std::stringstream ssMessageToDisplay;
				ssMessageToDisplay << "Maxim::CBits::DefineRelayDriver failed \n" << sDesignator << " is not a defined type of relay driver";
				etsMessageBox(ssMessageToDisplay.str().c_str(), MB_OK);
			}
	}


}



/************************************************************************************************************************************************************For*Doxygen**//**
Returns the status of a specific cbit for active sites.  Will return -1 if there is a mismatch.

@param	iCBit	cBit for which the status will be returned.

@return				Status of the cBit.  If the cbit passed is a group and members of the group are in different states, then -1 will be returned.  Otherwise the 0/1 state of the 
					cBit will be passed.
**************************************************************************************************************************************************************/
int MaximGetCBitState(int iCBit){

	if (msSiteStat(-1)) return -2; // msSiteState returns -1 if no sites are active.

	return 	Maxim::CBits::Extended::maximCBits.mapCBits[iCBit].GetState();

}

/************************************************************************************************************************************************************For*Doxygen**//**
This function will simply wait until all relays are settled, assuming you have set things up correctly to track relay actions and 
	 enforce datasheet specs of your relays. In theory this function could be expanded to track other settling times, such as servo 
	loops, etc.

@param	ulExtraWaitUS		An extra amount of time in microseconds that one needs to wait.  Nominally this would be 0, but this provides the
								  the capability to wait longer for settling time.
**************************************************************************************************************************************************************/
void WaitUntilRelaysSettle(unsigned long ulExtraWaitUS){
// Initially this function will simply wait until all relays are settled, assuming you have set things up correctly to track relay actions and enforce datasheet specs of your relays.
//   In theory this function could be expanded to track other settling times, such as servo loops, etc.
	Maxim::CBits::Extended::maximCBits.WaitForRelaysToSettle();
	if (ulExtraWaitUS) lwait(ulExtraWaitUS);
}

/************************************************************************************************************************************************************For*Doxygen**//**
Inspired by the ETS groupset command.  This command will accept I2C cbits.  Groups set up with this command will not be visible in the ETS debug tools.
	In the future this command may be modified to call the groupset command for all tester related resources so that you can see them in the debug utilities.  
	This wasn't done now because it is a bit tricky and it is assumed that tester resources will normally be set up in the pin map editor, not via this function.

@param	sDesignator	The text string "name" of this cbit.
@param	viCBitList	A vector of cbits that are part of the group.

@return	The CBit number for the group is returned.
**************************************************************************************************************************************************************/
int MaximCBitGroupSet( std::string sDesignator, vector<int> viCBitList){

	int iCBitNumber=40000;

	//Check to see if all CBits in viCBitList are valid
	for(vector<int>::iterator it=viCBitList.begin(); it!=viCBitList.end(); ){
		if(!Maxim::CBits::Extended::maximCBits.mapCBits.count(*it)){
			std::stringstream ssMessageToDisplay;
			ssMessageToDisplay << "Error in Maxim::CBits::MaximcBitGroupSet(\""<< sDesignator << "\",vector) \nInvalid CBit " << *it << " was passed in\nMake sure all CBits are defined before assigning them to a group";
			etsMessageBox(ssMessageToDisplay.str().c_str(), MB_OK);
			it = viCBitList.erase(it);
		}
		else it++;  //Need to increment outside of the for structure because if an element is deleted in the other part of the if, it will be incremented.
	}

	while(Maxim::CBits::Extended::maximCBits.mapCBits.count(iCBitNumber)) iCBitNumber++;

	Maxim::CBits::DefineRelayDriver( sDesignator, Maxim::CBits::RelayDriverGroup, viCBitList, iCBitNumber);

	return iCBitNumber;  

}

/************************************************************************************************************************************************************For*Doxygen**//**
Sets which sites will be associated with the CBit.  Setting up your sites properly will allow your CBits to quit switching if the associated site 
	becomes inactive.  By default all CBits have been set to be associated with all sites.

@param	iCBit		The CBit which is having its site assigned
@param	iSite		The site that will be associated with iCBit
**************************************************************************************************************************************************************/
void SetCBitSite(int iCBit, int iSite){
	Maxim::CBits::Extended::maximCBits.mapCBits.find(iCBit)->second.SetSite(iSite);
}

/************************************************************************************************************************************************************For*Doxygen**//**
Sets which sites will be associated with the CBit.  Setting up your sites properly will allow your CBits to quit switching if the associated site 
	becomes inactive.  By default all CBits have been set to be associated with all sites.  The CBit will remain active as long as at least one 
	of the sites in viSiteList remains active.

@param	iCBit		The CBit which is having its site assigned
@param	viSiteList	A vector or an array containing all sites that a specific CBit is associated with.
**************************************************************************************************************************************************************/
void SetCBitSite(int iCBit, vector<int> viSiteList){
	std::set<int> setiSiteList;
	for (vector<int>::iterator it=viSiteList.begin(); it!=viSiteList.end(); it++){
		setiSiteList.insert(*it);
	}
	Maxim::CBits::Extended::maximCBits.mapCBits.find(iCBit)->second.SetSite(setiSiteList);
}

/************************************************************************************************************************************************************For*Doxygen**//**
Set the string designator for a given CBit.  Typically this will be the name given to the CBit on your test hardware.

@param	iCBitNumber		CBit number that the designator is being assigned to
@param	sCBitDesignator	The string based designator that typically will match the name given to the CBit on your test hardware
**************************************************************************************************************************************************************/
void SetCBitDesignator(int iCBitNumber, std::string sCBitDesignator) {Maxim::CBits::Extended::maximCBits.mapCBits[iCBitNumber].SetDesignator(sCBitDesignator);}


		namespace Extended {

/************************************************************************************************************************************************************For*Doxygen**//**
Controls whether CBit = 0 means relay open or relay closed

@param	iCBit			CBit number that the the relay logic is being applied to
@param	eLogic			Specifies what logic should be used for iCBit

@code
	Maxim::CBits::SetCBitLogic(1004, CBitLogic0IsRelayOpen); // Setting logic for CBit 2004.
@endcode

**************************************************************************************************************************************************************/
void SetCBitLogic(int iCBit, eCBitLogic eLogic) {maximCBits.mapCBits.find(iCBit)->second.SetCBitLogic(eLogic);}

/************************************************************************************************************************************************************For*Doxygen**//**
Controls whether CBit = 0 means relay open or relay closed

@param	viCBitNumber	Vector of CBit numbers that the relay logic is being applied to
@param	eLogic			Specifies what logic should be used for iCBit
**************************************************************************************************************************************************************/
void SetCBitLogic(std::vector<int> viCBitNumber, eCBitLogic eLogic)
	{
		for(std::vector<int>::iterator it = viCBitNumber.begin(); it != viCBitNumber.end(); it++) maximCBits.mapCBits.find(*it)->second.SetCBitLogic(eLogic);
	}

/************************************************************************************************************************************************************For*Doxygen**//**
Will look up relay specifications in MaximLib_CBIT_Relay_Specs.csv file.  If specifications are not in the file, then they can be
	loaded using DefineRelaySpecifications

@param	sMaximInventoryNumber	Maxim inventory number

@return	0		Successful completion
		1		Relay not found, default values used, and error message generated
**************************************************************************************************************************************************************/
int InitializeRelaySpecifications(std::string sMaximInventoryNumber){

	int iErrorFlag=1;
	std::set<std::string> setRelaySpecifications;
	
	//Following file contains the known relay specifications.
	#include "MaximLib_CBIT_Relay_Specs.h"

	for(std::set<std::string>::iterator it=setRelaySpecifications.begin(); (it!=setRelaySpecifications.end())&&iErrorFlag; it++){
		std::vector<std::string> tokens = Maxim::CBits::Extended::CSVStringToVector((*it).c_str());
		if(tokens[1] == sMaximInventoryNumber){
			Maxim::CBits::Extended::mapRelayTypes[sMaximInventoryNumber]=Maxim::CBits::Extended::RelayProperties(sMaximInventoryNumber, atoi(tokens[2].c_str()), atoi(tokens[3].c_str()));
			iErrorFlag = 0;
		}

	}


//Remove the CSV file if it exists.  Due to an MST issue, there was a problem using csv file, so information was moved into a .h file.
	int iRC;
	char pathName[256];  //Full path to CSV file that will contain the relay specifications
	std::string sFileName;

	// Obtain the directory that ETS is currently running out of.  Handle errors that Pat Hayes has observed in the past. -- BRS
	iRC=GetETSVariable(PROJECT_PATH,pathName,sizeof(pathName));
	if (iRC <0) 
			iRC=0;
	if (iRC >(sizeof(pathName)-1))
			iRC=sizeof(pathName)-1;
	pathName[iRC]=0;

	// Add path to the Relay Specification File
	sFileName = pathName;
	sFileName += "MaximLib\\MaximLib_CBIT_Relay_Specs.csv";

	remove(sFileName.c_str());

	if (iErrorFlag){
		etsprintf("Error - %s relay not found in MaxLib_CBIT_RelaySpecs.h\n", sMaximInventoryNumber);
		etsprintf("Either have librarian add %s to file or define specs in your program \n", sMaximInventoryNumber);
	}

	return iErrorFlag;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Normally this function will not be used.  It provides the engineer a way to add a new set of relay specifications without adding the relay
	 to the library, if for example the librarian is unavailable and the engineer needs an instant change.  This should be a temporary fix, with the
	 library being updated at the earliest practical time.
@param	sMaximInventoryNumber	Maxim inventory number
@param	ulWaitUSOpen				How many microseconds it takes the relay to open
@param	ulWaitUSClose				How many microseconds it takes the relay to close
**************************************************************************************************************************************************************/

void DefineRelaySpecifications(std::string sMaximInventoryNumber, unsigned long ulWaitUSOpen, unsigned long ulWaitUSClose){
	Maxim::CBits::Extended::mapRelayTypes[sMaximInventoryNumber]=Maxim::CBits::Extended::RelayProperties(sMaximInventoryNumber, ulWaitUSOpen, ulWaitUSClose);
	etsprintf("Warning, you are defining your own relay specifications instead of using standards.  Please contact the librarian to add to the file.");
}

/************************************************************************************************************************************************************For*Doxygen**//**
Constructor for a relay with particular specifications.

@param	sPartNumber					Part number that the relay will be known by.  Normally the Maxim inventory number
@param	ulWaitUSOpen				How many microseconds it takes the relay to open
@param	ulWaitUSClose				How many microseconds it takes the relay to close
**************************************************************************************************************************************************************/

RelayProperties::RelayProperties(std::string sPartNumber, unsigned long ulWaitUSOpen, unsigned long ulWaitUSClose) : 
	sPartNumber(sPartNumber), ulWaitUSOpen(ulWaitUSOpen), ulWaitUSClose(ulWaitUSClose) {

}

/************************************************************************************************************************************************************For*Doxygen**//**
Retrieves the amount of time for a relay to open
**************************************************************************************************************************************************************/
unsigned long	RelayProperties::GetWaitUSOpen() {return ulWaitUSOpen;}


/************************************************************************************************************************************************************For*Doxygen**//**
Retrieves the amount of time for a relay to close
**************************************************************************************************************************************************************/
unsigned long	RelayProperties::GetWaitUSClose() {return ulWaitUSClose;}

/************************************************************************************************************************************************************For*Doxygen**//**
Creates a base class for items that the various relay drivers share in common.
**************************************************************************************************************************************************************/

RelayDriver::RelayDriver() { 
	msDesignator = "UNKNOWN"; 
	mbPendingAction = true;
	muiRegister = 0; // Assume all relays are open initially.
	muiPendingRegister = 0;
	mDriverType=RelayDriverUnknown;
	muiRegisterMask=0;

}

/************************************************************************************************************************************************************For*Doxygen**//**
 Using Virtual functions, so this is needed as a place holder in the base function, even though it will never be called
**************************************************************************************************************************************************************/
int	RelayDriver::ApplyPending()	{return 0;}		

/************************************************************************************************************************************************************For*Doxygen**//**
Using Virtual functions, so this is needed as a place holder in the base function, even though it will never be called
**************************************************************************************************************************************************************/
unsigned int	RelayDriver::GetAddress()	{return 0;}

/************************************************************************************************************************************************************For*Doxygen**//**
Returns true if a relay driver has new data waiting in program memory that needs to be transmitted to the physical relay driver 
**************************************************************************************************************************************************************/
bool RelayDriver::GetPendingAction(){ return mbPendingAction; }

/************************************************************************************************************************************************************For*Doxygen**//**
Sets all cbits associated with the driver to the specified sRelayType.

@attention	This call should only be made for group relay drivers, otherwise it may turn into an infinite loop.

@param	sRelayType	Type of relay being passed in
**************************************************************************************************************************************************************/
void RelayDriver::SetRelayType(std::string sRelayType){
	
	for(std::map<int, int>::iterator it=mmapiCBitList.begin(); it!=mmapiCBitList.end(); it++){
		Maxim::CBits::Extended::maximCBits.mapCBits.find((*it).first)->second.SetRelayType(sRelayType);
	}

}

/************************************************************************************************************************************************************For*Doxygen**//**
Checks to see which relays will be closed on the next call to ApplyPending and calculates the total amount of settle time required.

@remark Doing the settling time checks in this function reduces the total number of calls to ltime, therefore reducing total overhead.

@return	Settling time in microseconds.
**************************************************************************************************************************************************************/
unsigned long RelayDriver::GetPendingRelaySettleTime(){
	unsigned int uiBitsThatChange;
	unsigned long ulMaximumSettleTime=0;

	uiBitsThatChange = muiRegister ^ muiPendingRegister;

	std::map<int, int>::iterator itCBitList;
	for (itCBitList = mmapiCBitList.begin(); itCBitList!= mmapiCBitList.end(); itCBitList++){
		
		// First check to see if this particular bit is changing state
		if(uiBitsThatChange & (1<<(*itCBitList).second) ){

			// Get a pointer to the appropriate CBit
			int iCBitNumber = (*itCBitList).first;

			Maxim::CBits::Extended::CBitProperties *ptrCBit;

			ptrCBit = &((*Maxim::CBits::Extended::maximCBits.mapCBits.find( iCBitNumber)).second);


			// Determine if the CBit is being opened or closed and then update settle time required
			if((ptrCBit->GetCBitLogic()==CBitLogic0IsRelayOpen) ^ ((muiRegister>>(*itCBitList).second) & 1)) ulMaximumSettleTime = max(ulMaximumSettleTime, ptrCBit->GetWaitUSClose()); 
			else ulMaximumSettleTime = max(ulMaximumSettleTime, ptrCBit->GetWaitUSOpen());

		}
	}

	return ulMaximumSettleTime;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Will call PendingApplied for every CBit that is in mmapiCBitList, which in turn will update the CBit state variable to reflect that the 
	state which had been stored in program memory has now been sent to the physical relay driver chip for the specified CBit.
**************************************************************************************************************************************************************/
void RelayDriver::PendingApplied(){

	muiRegister=muiPendingRegister;
	this->SetPendingAction(false);

	for(std::map<int, int>::iterator it=mmapiCBitList.begin(); it!= mmapiCBitList.end(); it++){
		int iCBitState = ((muiRegister >> it->second) & 1);
		Maxim::CBits::Extended::CBitProperties *ptrCBit;
		ptrCBit = &(Maxim::CBits::Extended::maximCBits.mapCBits.find(it->first)->second);
		ptrCBit->DoNotUseSetState(iCBitState);
		Maxim::CBits::Extended::maximCBits.mapCBitStates[ptrCBit->GetCBitDesignator()] = iCBitState; // Update this map for easy debug / watching of CBit States

	}
}

/************************************************************************************************************************************************************For*Doxygen**//**
Read the states of a specific relay driver and output the results into a string stream.  This allows the user to direct the
	output to a file, screen, etc. as needed.  Most likely will only be used for debug purposes.

@param	sPrefix		A message that will be printed before the register values.  Typically one would put the name of the chip that data is being 
					read from.
@param	iMSB		Highest bit contained in cBitRegister
@param	iLSB			Lowest bit contained in cBitRegister
@param	iCBitRegister

@ return	0		Successful completion
			1		Relay not found, default values used, and error message generated
																		   
**************************************************************************************************************************************************************/
std::stringstream	RelayDriver::OutputRegister(std::string sPrefix, int iMSB, int iLSB, int iCBitRegister) {
	std::stringstream ssBuffer;

	ssBuffer << sPrefix << " C-Bit " << std::setw(3) << iMSB << "->" ;

	// Currently set up to run for ETS tester relays only
	int position = iMSB-iLSB;  // Gives the location in cBitRegister where the msb is stored.  Assume the lsb is in position 0.
	for (int ibit=iMSB; ibit>=iLSB; ibit--){
		ssBuffer << (1 & (iCBitRegister >> position));
		if(!((position)%8)) ssBuffer << " "; // Add a space every 8 bits
	}
	
	ssBuffer << " <- C-Bit " << std::setw(3) << iLSB << std::endl;

	return ssBuffer;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Updates program memory to reflect that a specific CBit of a specific relay driver needs to change state during the next apply pending function call

@param	bState			The state that mPendingAction should be set to.  (Not clear why this parameter is needed here).
@param	uiCBitNumber	The CBit number which is changing state
@param	iState			The state that the CBit will be changing to, either 0 or 1.
**************************************************************************************************************************************************************/
void RelayDriver::SetPendingAction(bool bPendingState, unsigned int uiCBitNumber, int iState) {
	mbPendingAction = bPendingState;

	if (mmapiCBitList.count(uiCBitNumber)){   // Only perform if CBit exists as part of the group already
		switch (iState) {
			case 1 : muiPendingRegister |= 1 << mmapiCBitList[uiCBitNumber]; break;
			case 0 : muiPendingRegister &= ~(1 << mmapiCBitList[uiCBitNumber]); break;
			default: ; 
		}
	}
}

/************************************************************************************************************************************************************For*Doxygen**//**
Will send all cbit states to a string stream
	The output will also be directed to the Output tab of the ETS environment.

@param	sMessage		Message will provide clues as to where in the program you made the call.

@return	String stream that the user can direct to either a file or output
**************************************************************************************************************************************************************/
std::stringstream OutputAllCBitStates(std::string sMessage){
	std::map<std::string, Maxim::CBits::Extended::RelayDriver*>::iterator it;
	std::stringstream ssBuffer;

	if (sMessage.size()) ssBuffer << sMessage << std::endl << std::endl;

	for(it= Maxim::CBits::Extended::mapRelayDriver.begin(); it != Maxim::CBits::Extended::mapRelayDriver.end(); it++){
		ssBuffer << it->second->VerifyCBitsInMemory();
	}

	etsprintf( ssBuffer.str().c_str() );

	return ssBuffer;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Checks to see if actual cbit states as reported by the tester and/or drivers are the same as what is recorded in allCbits map.
	  In this case a default function was needed for base class, even though I never expect this instance to be called.  Seems like there 
	  should be a cleaner way to do this.

@return	String stream that the user can direct to either a file or output
**************************************************************************************************************************************************************/
std::stringstream RelayDriver::VerifyCBitsInMemory(){
	std::stringstream ssBuffer;
	return ssBuffer;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Creates a relay driver object that can be used to control ETS cbits via the MaximLib_CBIT library files.

@param	sDesignator		String based name for the relay driver.  It is expected to be "ETS".
@param	viCBitList		Vector of CBits that are controlled by the driver

@return	Status from cbit_open or cbit_close command.
**************************************************************************************************************************************************************/
TesterRelayDriver::TesterRelayDriver(std::string sDesignator, std::vector<int> viCBitList, char cCBitBank) {
	msDesignator = sDesignator;
	mDriverType = RelayDriverETS;
	mbPendingAction = false;
	mcCBitBank = cCBitBank;
	mapRelayDriver[msDesignator] = this; // Send this address to a map which keeps track of all available relay drivers, regardless of type.
	
	// Load the tester cbits
	int iMapIndex=0;
	for(std::vector<int>::iterator it=viCBitList.begin(); it!=viCBitList.end(); it++){
		msetiCBitList.insert(*it); // Old Way.  This can probably be eliminated in the future since I am moving to a standard map for tracking registers
		mmapiCBitList[*it] = iMapIndex++;
		Maxim::CBits::Extended::maximCBits.mapCBits[*it] = CBitProperties(*it, msDesignator, this); 

	}
}

/************************************************************************************************************************************************************For*Doxygen**//**
Cycles through all CBits and applies all states that have been set in memory, but have not yet been communicated to the 
	hardware (relay driver).  Taking this approach allows the tester to be efficient and only have a single communication
	sequence with each relay driver, saving transactions when multiple CBits are changed at one time.

@return	Status from cbit_open or cbit_close command.
**************************************************************************************************************************************************************/
int TesterRelayDriver::ApplyPending(){
	int iStatus = 0;

	switch ( mcCBitBank) {
		case 'a' : iStatus = cbita_set(~muiPendingRegister); break;
		case 'b' : iStatus = cbitb_set(~muiPendingRegister); break;
		case 'c' : iStatus = cbitc_set(~muiPendingRegister); break;
		case 'd' : iStatus = cbitd_set(~muiPendingRegister); break;
		default: { iStatus = -9;
			std::stringstream ssMessageToDisplay;
			ssMessageToDisplay << "Error in TesterRelayDriver::ApplyPending \nInvalid CBit bank " << mcCBitBank << " was passed in";
			etsMessageBox(ssMessageToDisplay.str().c_str(), MB_OK);
		}
	}

	PendingApplied();

	return iStatus;
} // TesterRelayDriver::ApplyPending()

/************************************************************************************************************************************************************For*Doxygen**//**
Read the states of a specific relay driver and output the results into a string stream.  This allows the user to direct the
	output to a file, screen, etc. as needed.  Most likely will only be used for debug purposes.

@return	Stream giving the status of all CBit Register States according to CBit Library memory.  When possible the states are read back from hardware.
**************************************************************************************************************************************************************/
std::stringstream TesterRelayDriver::VerifyCBitsInMemory() {

	UINT64				cbitregisterfromhardware, uiCBitRegisterFromMemory=0, cbitmaskfrommemory=0;
	std::stringstream	ssBuffer;

	cbitregisterfromhardware = cbitread(1); // Read tester hardware cbits 1-64

	for(std::set<int>::iterator it=msetiCBitList.begin(); it!=msetiCBitList.end(); it++) {
		uiCBitRegisterFromMemory |= maximCBits.mapCBits[*it].GetState() << (*it-1); 
		cbitmaskfrommemory |= (1i64 << (*it-1));
	}

	ssBuffer << RelayDriver::OutputRegister("Tester Actual C-Bit States:", 32, 1, (cbitregisterfromhardware&0xFFFFFFFF)) << std::endl;
	ssBuffer << RelayDriver::OutputRegister("Maxim Memory  C-Bit States:", 32, 1, (cbitregisterfromhardware&0xFFFFFFFF));
	ssBuffer << RelayDriver::OutputRegister("C-Bits tracked in memory:", 32, 1, (cbitregisterfromhardware&0xFFFFFFFF));
	if(uiCBitRegisterFromMemory != (cbitregisterfromhardware & cbitmaskfrommemory)) {
		ssBuffer << std::endl << "!!! ERROR !!! Memory does not match hardware read back" << std::endl;
		for(std::set<int>::iterator it=msetiCBitList.begin(); it!=msetiCBitList.end(); it++) {
			maximCBits.mapCBits[*it].DoNotUseSetState((cbitregisterfromhardware >> (*it-1)) & 1i64);
		}
	}

	ssBuffer << RelayDriver::OutputRegister("Tester C-Bits:", 64, 33, ((cbitregisterfromhardware>>32)&0xFFFF));

	etsprintf( ssBuffer.str().c_str() );

	return ssBuffer;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Create a new instance of PCA9671RelayDriver.

@param	sDesignator		Name that is used for this particular instance of the relay driver.  Recommend using the designator from the schematic.
@param	viResources		List of CBits that are controlled by the relay driver
@param	uiChipAddress		Address of this particular relay driver.
**************************************************************************************************************************************************************/
PCA9671RelayDriver::PCA9671RelayDriver(std::string sDesignator, std::vector<int> viResources, unsigned int uiChipAddress): 
	 muiChipAddress(uiChipAddress){

	msDesignator = sDesignator;
	mDriverType = RelayDriverPCA9671;
	mbPendingAction = false;

	if(viResources.size() > 16){
		std::stringstream message;
		message << "Error defining relay driver: " << sDesignator << ".  You can only assign 16 CBits to this type of driver.  Program will not work correctly";
		etsMessageBox(message.str().c_str(), MB_OK);
		etsprintf(message.str().c_str());
	}

	int i = 0;
	for(std::vector<int>::iterator it=viResources.begin(); it != viResources.end(); it++) {
		if(i<16) {
//			miCBitList[i]=*it;	// Create a list of which 16 cbits will correspond to the 16 relay drivers that this chip has.
												// Cbit 0 will be equivalent to a null cBit, and indicates either nothing is connected or the user
												// does not know.		
			mmapiCBitList[*it] = i++; // NEW WAY of tracking CBits.  Will eventually delete the line above BRS 12/20/2012
		}
		Maxim::CBits::Extended::maximCBits.mapCBits[*it] = CBitProperties(*it, msDesignator, this); // Load driver information into CBit map
	}
}

/************************************************************************************************************************************************************For*Doxygen**//**
This command applies any pending states to the corresponding relay driver chip.  Changing a CBit state requires 2 steps.  First the new 
	settings are loaded into memory.  Second those settings must be transmitted to the relay driver chip.  

@return	Returns status from the i2cramwrite command.
**************************************************************************************************************************************************************/
	int PCA9671RelayDriver::ApplyPending() {
	unsigned int uiStatus;
	unsigned char data[2] = {0, 0};
	std::map<int, Maxim::CBits::Extended::CBitProperties>::iterator itCBit;


	// Data needs to be inverted for I2C chips
	data[0] = ~(255&muiPendingRegister);
	data[1] = ~(255&(muiPendingRegister>>8));

	uiStatus = i2cramwrite(muiChipAddress, int(data[0]), &data[1], 1); // This chip does not take a memory address, so the first byte of data has to be passed in where the address normally would go. BRS 6/29/12

	if (!uiStatus) {
		PendingApplied();
	}

	return uiStatus;

}

/************************************************************************************************************************************************************For*Doxygen**//**
Allow users to retrieve chip address, while protecting the values from being improperly changed by the user of the library.
**************************************************************************************************************************************************************/
unsigned int	PCA9671RelayDriver::GetAddress() { return(muiChipAddress); }

/************************************************************************************************************************************************************For*Doxygen**//**
For now this just prints out the state of the relay bits according to test program memory.  Long term it would be good to verify against the actual
	relay driver chip, but don't know how to do read back at this time.

@return	The states of the the cbits controlled by the relay driver.  Will send to ETS output screen and also return a stringstream that the user
		can direct anywhere they would like.
**************************************************************************************************************************************************************/
std::stringstream PCA9671RelayDriver::VerifyCBitsInMemory(){
	UINT64				uiCBitRegisterFromMemory=0;
	std::stringstream	ssBuffer;

	// Don't know how to read back from the PCA9671 chip, so can't read back the driver status
	ssBuffer << std::setw(16) << msDesignator ;
	ssBuffer << RelayDriver::OutputRegister(" C-Bit States:", 16, 1, (uiCBitRegisterFromMemory&0xFFFF));

	etsprintf( ssBuffer.str().c_str() );

	return ssBuffer;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Prepare to close the group of associated relays by setting the proper state in memory.  Changes will take effect on the next apply pending command.
**************************************************************************************************************************************************************/
void MaximCBitGroupRelayDriver::PrepareToCloseRelayList(){
	std::set<int>::iterator it;
	for (it=msetiCBitList.begin(); it!=msetiCBitList.end(); it++){
		maximCBits.mapCBits[*it].PrepareToCloseRelay();
	}
}

/************************************************************************************************************************************************************For*Doxygen**//**
Prepare to open the group of associated relays by setting the proper state in memory.  Changes will take effect on the next apply pending command.
**************************************************************************************************************************************************************/
void MaximCBitGroupRelayDriver::PrepareToOpenRelayList(){
	std::set<int>::iterator it;
	for (it=msetiCBitList.begin(); it!=msetiCBitList.end(); it++){
		maximCBits.mapCBits[*it].PrepareToOpenRelay();
	}
}

/************************************************************************************************************************************************************For*Doxygen**//**
Set or clear the appropriate flags that tell whether states in memory are waiting to be communicated to the hardware (relay driver or tester)

@param	bState	True indicates that states in memory need to be communicated to hardware.  False means no actions are waiting, and is typically called immediately after 
					transmitting data to the devices.
**************************************************************************************************************************************************************/
void MaximCBitGroupRelayDriver::SetPendingAction(bool bState){
	RelayDriver::SetPendingAction( bState);		// Call the base class function

	std::set<int>::iterator it;
	CBitProperties *groupCBit = &maximCBits.mapCBits[miGroupCBitNumber];

	for (it = msetiCBitList.begin(); it != msetiCBitList.begin(); it++){
		CBitProperties *thisCBit =	&maximCBits.mapCBits[*it];
		// Check to see if cBit set to 0 causes the same action (open or close) as the group.  This handles cases where relays or driver is active high vs. active low.
		if (thisCBit->GetCBitLogic() == groupCBit->GetCBitLogic())	
				thisCBit->PrepareToSetCBit( groupCBit->GetPendingState());
		else	thisCBit->PrepareToSetCBit(!groupCBit->GetPendingState());
	}

}

/************************************************************************************************************************************************************For*Doxygen**//**
For now this just prints out the state of the relay bits according to test program memory.  Long term it would be good to verify against
	relay driver chips, but don't know how to do read back at this time.

@return	The states of the the cbits controlled by the relay driver.  Will send to ETS output screen and also return a stringstream that the user
		can direct anywhere they would like.
**************************************************************************************************************************************************************/
std::stringstream MaximCBitGroupRelayDriver::VerifyCBitsInMemory(){
	std::set<int>::iterator it;
	std::stringstream	ssBuffer;
	int i=0;

	// Don't know how to read back from the PCA9671 chip, so can't read back the driver status

	ssBuffer << "C-Bit Group: " << miGroupCBitNumber << "    Designator: "  << msDesignator << std::endl ;

	for (it = msetiCBitList.begin(); it != msetiCBitList.end(); it++){
		ssBuffer << "Cbit " << std::setw(5) << *it << " = " << maximCBits.mapCBits[*it].GetState() << "      ";
		if (++i == 4){
			i = 0;
			ssBuffer << std::endl;
		}
	}


	etsprintf( ssBuffer.str().c_str() );

	return ssBuffer;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Returns the state of the relay driver.

@return	The state of the group of CBits.  -1 signifies that not all CBits from the group were in the same state.  -999
		can direct anywhere they would like.
**************************************************************************************************************************************************************/
int MaximCBitGroupRelayDriver::GetState(){
	int iState=-999;
	std::set<int>::iterator it;

	for( it = msetiCBitList.begin(); it != msetiCBitList.end(); it++) {
		if(Maxim::CBits::Extended::maximCBits.mapCBits[*it].IsCBitActive()){
			//Set the state equal to the first active site/cbit combination
			if (iState == -999)	iState = Maxim::CBits::Extended::maximCBits.mapCBits[*it].GetState();
			else	if (iState != Maxim::CBits::Extended::maximCBits.mapCBits[*it].GetState()) iState = -1; // -1 signifies that different members of the group had different states
		}
	}

	if (iState == -999) iState = -1; // -999 means no sites were active so we don't have a state to return.

	Maxim::CBits::Extended::maximCBits.mapCBits[miGroupCBitNumber].DoNotUseSetState(iState);  // Make sure the CBit State in memory matches what we have found here.   
																						//	This will be useful when doing a watch.
	return iState;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Constructor for a CBit.  Stores all the properties that are associated with a single CBit.  This version only allows a single site to be assigned or all sites.
	Used by relay driver constructors to pass relay driver pointer to the cbit.

@param	iCBitNumber		Integer that will be associated with a CBit
@param	sRelayDriver	Relay driver designator so we can link to the exact relay driver chip.  
@param	relayDriverPointer	Pointer to the relay driver associated with the CBit
**************************************************************************************************************************************************************/
CBitProperties::CBitProperties (int iCBitNumber, std::string sRelayDriver, Maxim::CBits::Extended::RelayDriver *relayDriverPointer):
					muiCBitNumber(iCBitNumber), msRelayDriver(sRelayDriver){

	std::set<int> setiSiteList;
	// If default value of -1 is passed, then make cbit active for all sites.
//	for (int i=0; i<Maxim::GetNumSites(); i++) setiSiteList.insert(i);

	setiSiteList.insert(-1); // Initializing to all sites is causing problems, so moving to -1 for initializations.
	CBitPropertiesCommon (iCBitNumber,  sRelayDriver, "DEFAULT", setiSiteList, "DEFAULT", CBitLogic0IsRelayOpen, -1);

	this->mRelayDriver = relayDriverPointer;

}

/************************************************************************************************************************************************************For*Doxygen**//**
Constructor for a CBit.  Stores all the properties that are associated with a single CBit.  This version only allows a single site to be assigned or all sites.

@param	iCBitNumber		Integer that will be associated with a CBit
@param	sRelayDriver	Relay driver designator so we can link to the exact relay driver chip.  
@param	sRelayType		Indicates the type of relay associated with the cbit, so open/close times can be looked up.  Name should match Maxim inventory number for the component.
@param	iSite			The site associated with the CBit.  Note that -1 will translate to all sites.
@param	sDesignator		String designator of the cBit.  By default this will be "CBIT" & muiCBitNumber.  Ideally it will match the designators from your schematic.
@param	eCBitLogic		Tracks whether cbit low causes the relay to open or to close.
@param	iState			Optional parameter, not always known.  Contains the current state of the cBit that is observed at the test fixture.  
**************************************************************************************************************************************************************/
CBitProperties::CBitProperties (int iCbitNumber,  std::string sRelayDriver, std::string sRelayType, 
					int iSite, std::string sDesignator, eCBitLogic logic, int iState):
					muiCBitNumber(iCbitNumber), msRelayDriver(sRelayDriver), msRelayType(sRelayType) {
						std::set<int> setiSiteList;
						// If default value of -1 is passed, then make cbit active for all sites.
						if (iSite > -1 ) setiSiteList.insert(iSite); 
						else for (int i=0; i<Maxim::GetNumSites(); i++) setiSiteList.insert(i);


						CBitPropertiesCommon (iCbitNumber,  sRelayDriver, sRelayType, setiSiteList, sDesignator, logic, iState);
					}

/************************************************************************************************************************************************************For*Doxygen**//**
Common set of code that is called by all versions of the CBitProperties constructor.

@param	iCBitNumber		Integer that will be associated with a CBit
@param	sRelayDriver		Relay driver designator so we can link to the exact relay driver chip.  
@param	sRelayType		Indicates the type of relay associated with the cbit, so open/close times can be looked up.  Name should match Maxim inventory number for the component.
@param	setiSiteList		The list of sites associated with the CBit.
@param	sDesignator		String designator of the cBit.  By default this will be "CBIT" & muiCBitNumber.  Ideally it will match the designators from your schematic.
@param	eCBitLogic		Tracks whether cbit low causes the relay to open or to close.
@param	iState			Optional parameter, not always known.  Contains the current state of the cBit that is observed at the test fixture.  
**************************************************************************************************************************************************************/
void CBitProperties::CBitPropertiesCommon (int iCBitNumber,  std::string sRelayDriver, std::string sRelayType, 
					std::set<int> setiSiteList, std::string sDesignator, eCBitLogic logic, int iState) {
		std::stringstream ss;

		//Set the passed parameters
		msDesignator	= sDesignator;
		mSite			= setiSiteList;
		mCBitLogic		= logic;
		miState			= iState;
		miPendingState  = -1;
		mRelayDriver    = NULL;

		ss << "CBIT" << setw(5) << iCBitNumber;

		if (msDesignator == "DEFAULT") {
			msDesignator = ss.str();
		}

		maximCBits.mapCBitDesignators[msDesignator] = this;
		maximCBits.mapCBitDesignators[ss.str()] = this;	   //Always load CBIT## as a default designator.  Helps with problems where tester expects CBIT## to be the cBit designator

		//Load pointer to relay driver if one exists.  This should be faster than always looking up the relay driver in the map.
		std::map <std::string, Maxim::CBits::Extended::RelayDriver*>::iterator it;
		it = mapRelayDriver.find(sRelayDriver);
		if (it != Maxim::CBits::Extended::mapRelayDriver.end()){       //Check to see if the relay driver has been loaded into the map.
			mRelayDriver = it->second;
		}

}

/************************************************************************************************************************************************************For*Doxygen**//**
Allow users to retrieve CBit Number, while protecting the values from being improperly changed by the user of the library.
**************************************************************************************************************************************************************/
unsigned int	CBitProperties::GetCBitNumber()		{ return muiCBitNumber;}
/************************************************************************************************************************************************************For*Doxygen**//**
Allow users to retrieve CBit Designator, while protecting the values from being improperly changed by the user of the library.
**************************************************************************************************************************************************************/
std::string		CBitProperties::GetCBitDesignator()	{ return msDesignator;}
/************************************************************************************************************************************************************For*Doxygen**//**
Allow users to retrieve Relay Driver, while protecting the values from being improperly changed by the user of the library.
**************************************************************************************************************************************************************/
std::string		CBitProperties::GetRelayDriver()	{ return msRelayDriver;}
/************************************************************************************************************************************************************For*Doxygen**//**
Allow users to retrieve Relay Type, while protecting the values from being improperly changed by the user of the library.
**************************************************************************************************************************************************************/
std::string		CBitProperties::GetRelayType()		{ return msRelayType;}
/************************************************************************************************************************************************************For*Doxygen**//**
Allow users to retrieve CBit Logic (active high or low), while protecting the values from being improperly changed by the user of the library.
**************************************************************************************************************************************************************/
eCBitLogic		CBitProperties::GetCBitLogic()		{ return mCBitLogic;}
/************************************************************************************************************************************************************For*Doxygen**//**
Allow users to determine if there are any pending actions, while protecting the values from being improperly changed by the user of the library.
**************************************************************************************************************************************************************/
int				CBitProperties::GetPendingState()	{ return miPendingState;}
/************************************************************************************************************************************************************For*Doxygen**//**
Allow users to retrieve the wait time associated with the CBit to open the associated relay, while protecting the values from being improperly changed by the user of the library.
**************************************************************************************************************************************************************/
unsigned long	CBitProperties::GetWaitUSOpen()		{ return mapRelayTypes[msRelayType].GetWaitUSOpen();}
/************************************************************************************************************************************************************For*Doxygen**//**
Allow users to retrieve the wait time associated with the CBit to close the associated relay, while protecting the values from being improperly changed by the user of the library.
**************************************************************************************************************************************************************/
unsigned long	CBitProperties::GetWaitUSClose()	{ return mapRelayTypes[msRelayType].GetWaitUSClose();}

/************************************************************************************************************************************************************For*Doxygen**//**
Allow users to get state of CBit.  Special handling is required for groups of CBits, since it is possible that one of the members was changed independently
	from the rest of the group

@return	State of the CBit, which is normally 0 or 1.  In the case of a group CBit, you should look at the error values for groups.  Currently -1 indicates that 
		not all relays were in the same state.  -999 indicates that no sites were active within a given relay driver group.
**************************************************************************************************************************************************************/
int				CBitProperties::GetState()			{ 
	// If the cBit represents a group, then need to recursively check all members of the group and make sure that they are in the same state.  If not, then set miState to -1.
	if(Maxim::CBits::Extended::mapRelayDriver[msRelayDriver]->GetRelayDriverType() == Maxim::CBits::RelayDriverGroup){
		Maxim::CBits::Extended::mapRelayDriver[msRelayDriver]->GetState();  // Function will set miState for the appropriate cBit.
	}

	return miState;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Check to see if the cBit is active

@return	True if the CBit is associated with multiple sites.  False if the CBit is associated with a single site that is no longer active.			
**************************************************************************************************************************************************************/
int		CBitProperties::IsCBitActive(){
	int iIsActive = 0;
	std::set<int>::iterator it;

	// 
	if(mSite.size() == Maxim::GetNumSites()) iIsActive = TRUE;	
	else if(mSite.count(-1)) iIsActive = TRUE;
	else for (it = mSite.begin(); it != mSite.end(); it++) iIsActive |= msSiteStat(*it);

	return iIsActive;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Check to see if any site associated with the cBit is active

@return	True if at least one associated site is active, false if no associated sites are active.			
**************************************************************************************************************************************************************/
void			CBitProperties::SetRelayType(std::string sRelayType){
				msRelayType = sRelayType;

				if( !mapRelayTypes.count(sRelayType))
				{
					Maxim::CBits::Extended::InitializeRelaySpecifications(sRelayType);
				}

				if(mRelayDriver->GetRelayDriverType() == RelayDriverGroup) mRelayDriver->SetRelayType(sRelayType);
}

/************************************************************************************************************************************************************For*Doxygen**//**
Lets the class know that the "pending state" has been applied and is now the current state.  Keep in mind that changing the state of a CBit is a two step
	process.  First one lets the tester know what state they would like to change one or more of the CBits to, these are the "pending states".  Then
	they must apply all the appending actions.  This two step approach allows optimization of the number of commands sent to the various relay drivers,
	specifically if a single driver controls multiple CBits, only one command is sent instead of several.
**************************************************************************************************************************************************************/
void			CBitProperties::PendingApplied() {
	//miState = miPendingState;  // Old method, should probably delete.
}


/************************************************************************************************************************************************************For*Doxygen**//**
Set CBit to the pending close state.  No action will be taken until maximCBits.ApplyPending() is called. Note that this function
	can handle both active high and active low relays as long as relay properties were set up properly.
	Keep in mind that changing the state of a CBit is a two step process.  First one lets the tester know what state they would like 
	to change one or more of the CBits to, these are the "pending states".  Then they must apply all the appending actions.  This two
	step approach allows optimization of the number of commands sent to the various relay drivers, specifically if a single driver 
	controls multiple CBits, only one command is sent instead of several.
**************************************************************************************************************************************************************/
 void CBitProperties::PrepareToCloseRelay()		{ 
	switch (mCBitLogic){
		case CBitLogic0IsRelayOpen:
			PrepareToSetCBit(1);
			break;
		case CBitLogic0IsRelayClosed:
			PrepareToSetCBit(0);
			break;
		default:
			std::stringstream ssMessageToDisplay;
			ssMessageToDisplay << "Maxim::CBits::Extended::CBitProperties::PrepareToCloseRelay failed because it was passed the invalid value: " << mCBitLogic;
			etsMessageBox(ssMessageToDisplay.str().c_str(), MB_OK);

	}
	// If CBit corresponds to a group, we need to ripple down to all associated relays
//	if(mapRelayDriver.count(msDesignator)) mapRelayDriver[msDesignator]->PrepareToCloseRelayList();
	if(this->GetRelayDriverPointer()->GetRelayDriverType()==RelayDriverGroup)   GetRelayDriverPointer()->PrepareToCloseRelayList();
}

/************************************************************************************************************************************************************For*Doxygen**//**
Set CBit to the pending open state.  No action will be taken until maximCBits.ApplyPending() is called.  Note that this function
	can handle both active high and active low relays as long as relay properties were set up properly. 
	Keep in mind that changing the state of a CBit is a two step process.  First one lets the tester know what state they would like 
	to change one or more of the CBits to, these are the "pending states".  Then they must apply all the appending actions.  This two
	step approach allows optimization of the number of commands sent to the various relay drivers, specifically if a single driver 
	controls multiple CBits, only one command is sent instead of several.
**************************************************************************************************************************************************************/
void CBitProperties::PrepareToOpenRelay()		{ 
	switch (mCBitLogic){
		case CBitLogic0IsRelayOpen:
			PrepareToSetCBit(0);
			break;
		case CBitLogic0IsRelayClosed:
			PrepareToSetCBit(1);
			break;
		default:
			std::stringstream ssMessageToDisplay;
			ssMessageToDisplay << "Maxim::CBits::Extended::CBitProperties::PrepareToOpenRelay \nfailed because it was passed the invalid value: " << mCBitLogic;
			etsMessageBox(ssMessageToDisplay.str().c_str(), MB_OK);
	}
	// If CBit corresponds to a group, we need to ripple down to all associated relays
//	if(mapRelayDriver.count(msDesignator)) mapRelayDriver[msDesignator]->PrepareToOpenRelayList();
	if(this->GetRelayDriverPointer()->GetRelayDriverType()==RelayDriverGroup)   GetRelayDriverPointer()->PrepareToOpenRelayList();

}

/************************************************************************************************************************************************************For*Doxygen**//**
Set CBit to the pending state that is specified.  No action will be taken until maximCBits.ApplyPending() is called.   
	Keep in mind that changing the state of a CBit is a two step process.  First one lets the tester know what state they would like 
	to change one or more of the CBits to, these are the "pending states".  Then they must apply all the appending actions.  This two
	step approach allows optimization of the number of commands sent to the various relay drivers, specifically if a single driver 
	controls multiple CBits, only one command is sent instead of several.
**************************************************************************************************************************************************************/
void CBitProperties::PrepareToSetCBit(int iBitValue){
	// Check to see if any sites associated with the CBit are still active
	std::set<int>::iterator it;

	if(!IsCBitActive()) return; // If CBit is no longer active, then there is no action to take.
	miPendingState = iBitValue;

	if (mRelayDriver==NULL) return;

	if (miState != miPendingState) {
		mRelayDriver->SetPendingAction(true, muiCBitNumber, iBitValue); // Only set pending action if state needs to change
		//Relay driver groups will have sub relay drivers that take care of applying all changes, so no need to add it to the pending list
		if(mRelayDriver->GetRelayDriverType()!=RelayDriverGroup) maximCBits.setRelayDriversWithPendingActions.insert(mRelayDriver);
	}

}

/************************************************************************************************************************************************************For*Doxygen**//**
This function should NOT generally be used.  It is included for situations where program memory needs to be updated to
	match tester hardware.  It does not change the state of the cBit.
**************************************************************************************************************************************************************/
void CBitProperties::DoNotUseSetState(int iBitValue){
	miState = iBitValue;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Common set of code that is called by all versions of the MaximCBitGroupRelayDriver constructor.  Note that the MaximCBitGroupRelayDriver can 
	be thought of as a virtual relay driver.  There is no physical chip or driver associated with it.  Instead it is a collection of CBits whose
	states all need to change at the same time.

@param	sDesignator		The designator or name that is used for the group.
@param	iCBitNumber		CBit Number that is associated with the group.
**************************************************************************************************************************************************************/
void MaximCBitGroupRelayDriver::MaximCBitGroupRelayDriverCommon(std::string sDesignator, int iCBitNumber) {
	// Take care of easy tasks 

	if (iCBitNumber == -1)	for(iCBitNumber=40000; (iCBitNumber<50,000)&&(!maximCBits.mapCBits.count(iCBitNumber)); iCBitNumber++); // Automatically assign CBit numbers for groups.  
																											//   Start at 40,000 to avoid conflicts with other types of CBits
	else{
		if(maximCBits.mapCBits.count(iCBitNumber)){
			std::stringstream ssMessageToDisplay;
			ssMessageToDisplay << "Warning:  Maxim::CBits::Extended::MaximCBitGroupRelayDriver is reassigning CBit: " << iCBitNumber << std::endl;
			etsprintf(ssMessageToDisplay.str().c_str(), MB_OK);
		}
	}

	msDesignator = sDesignator;
	miGroupCBitNumber = iCBitNumber;
	mDriverType = RelayDriverGroup;
	// Create the corresponding cBit
//	maximCBits.mapCBits[iCBitNumber] = CBitProperties(iCBitNumber, msDesignator, "GROUP", -1, msDesignator); //site is given as -1 (unknown) since in the general case we don't 
																									//   know which sites the CBit will be associated with yet.
	maximCBits.mapCBits[iCBitNumber] = CBitProperties(iCBitNumber, msDesignator, this);  // Switched methods to use pointers instead of looking up strings in a map

	// Decided not to call the ETS native groupset at this point.  It is difficult to determine if the group members are ETS or not.
	// Not clear that there is any performance advantage.  Possible advantage if this information gets added to the debug information.
	// Since this function is not defined by ETS, it should be OK.
	// If I called groupset, it could cause conflicts with the PME_INT and GME_INT information that is imported via this function
	// --BRS 8/28/2012
}

/************************************************************************************************************************************************************For*Doxygen**//**
This version s necessary when adding a pointer to a map since we can't pass in values and vectors, lists, etc. can't have default values 

@param	sDesignator		The designator or name that is used for the group.
@param	iCBitNumber		CBit Number that is associated with the group.
**************************************************************************************************************************************************************/
MaximCBitGroupRelayDriver::MaximCBitGroupRelayDriver(std::string sDesignator, int iCBitNumber) {
	MaximCBitGroupRelayDriverCommon(sDesignator);

}


/************************************************************************************************************************************************************For*Doxygen**//**
Use this version when the list of CBits associated with the group are available and can be passed in.

@param	sDesignator		The designator or name that is used for the group.
@param	viCBitList		The list of CBits that are a member of the group.
@param	iCBitNumber		CBit Number that is associated with the group.
@param	
**************************************************************************************************************************************************************/

MaximCBitGroupRelayDriver::MaximCBitGroupRelayDriver(std::string sDesignator, std::vector<int> viCBitList, int iCBitNumber) {

	MaximCBitGroupRelayDriverCommon(sDesignator, iCBitNumber); // Take care of standard constructor items.

	//Sets work very convenient here.  If same CBit is used for every site, it will only record once.  If different CBit is used for different sites, then it will capture each of these.
	for(std::vector<int>::iterator it=viCBitList.begin(); it != viCBitList.end(); it++){ 
		msetiCBitList.insert(*it);
	}

	// Implementing new methods using a map.  This is more flexible/standard over all relay drivers.  
	// Load results from misetiCBitList, which by definition has only unique CBit numbers
	int i=0;
	for(std::set<int>::iterator it=msetiCBitList.begin(); it != msetiCBitList.end(); it++)	mmapiCBitList[*it] = i++;

}


/************************************************************************************************************************************************************For*Doxygen**//**
Do not want to use this function as we don't like the idea of using strings.  Kept here just in case we change our mind in the future.
	Allows list be passed in as a string.

@param	sDesignator			The designator or name that is used for the group.
@param	sAllGroupResources	The string based list of CBits that are a member of the group.
@param	iCBitNumber			CBit Number that is associated with the group.
**************************************************************************************************************************************************************/

//MaximCBitGroupRelayDriver::MaximCBitGroupRelayDriver(std::string sDesignator, std::string sAllGroupResources, int iCBitNumber) {
//
//	MaximCBitGroupRelayDriverCommon(sDesignator, iCBitNumber); // Take care of standard constructor items.
//
//	// Move on to the more complicated process of parsing and setting up required lists for the string based list of all group resources.
//
//	unsigned int uiStatus;
//	char * cGroupName, * cResources;
//
//	// Make the string easier to deal with
//	StringRangeToList(sAllGroupResources);
//
//	// Tokenize the resource string
//	std::string sBuffer; // Create a string buffer
//	std::stringstream ss(sAllGroupResources); // Insert the string into a stream
//
//	vector<std::string> vsResourceTokens; // Create vector to hold tokens
//
//	while (ss >> sBuffer) vsResourceTokens.push_back(sBuffer);
//
//	// Identify the cbits since they affect the maximCBits class
//	vector<std::string>::iterator itVector, itVectorNew;
//	std::set < vector<std::string>::iterator > tokensToDelete;
//
//	for (itVector=vsResourceTokens.begin(); itVector != vsResourceTokens.end(); itVector++){
//
//		// Only need to address CBIT parameters
//		// Look for the designator being used as well as the default designator "CBIT"
//		if ( maximCBits.mapCBitDesignators.count(*itVector) ) {
//			
//			CBitProperties* thisCBit = maximCBits.mapCBitDesignators[*itVector];
//			msetiCBitList.insert(thisCBit->GetCBitNumber()); // Add to the set of cbits in this group
//
//			if( mapRelayDriver[thisCBit->GetRelayDriver()]->GetRelayDriverType() == RelayDriverETS){
//
//				// Make sure the tester resource string has CBIT## as a designator, since the tester does not support full flexibility on the designator name
//				ss.clear();
//				ss << "CBIT" << thisCBit->GetCBitNumber();
//				itVectorNew = vsResourceTokens.insert(itVector, ss.str());
//				vsResourceTokens.erase(itVector);
//				itVector = itVectorNew;
//			}
//			else {
//				// Make a list of non-tester cbits to delete from the tester resource string
//				tokensToDelete.insert(itVector);
//			}
//		}
//	}
//
//	// Delete all non ETS-88 resources
//	for(std::set < vector<std::string>::iterator >::iterator it=tokensToDelete.begin(); it!=tokensToDelete.end(); it++) vsResourceTokens.erase(*it);
//
//	// Construct the string that will be sent to the ETS groupset utility
//	mTesterGroupCBits = "";
//	for (itVector=vsResourceTokens.begin(); itVector != vsResourceTokens.end(); itVector++){
//		mTesterGroupCBits.append(*itVector);
//		mTesterGroupCBits.append(" ");
//	}
//
//	cGroupName = (char*) sDesignator.c_str();
//	cResources = (char*) mTesterGroupCBits.c_str();
//
//	uiStatus = groupset(iCBitNumber, cGroupName, cResources); 
//
//}

/************************************************************************************************************************************************************For*Doxygen**//**
Setup standard cbits and relay drivers.  It's OK even if relay drivers and/or cbits aren't used in program and/or don't have hardware on 
	contactor board. Test engineer can change the defaults by making calls later in their program. Any modifications to state should be made 
	via calls in the test engineers Maxim_UserInit function.  If modifications are made in the function below they will be lost if their program 
	is updated with the latest library.
**************************************************************************************************************************************************************/

MaximCBits::MaximCBits() {

	// Do not edit this function!!!!
	// Do not edit this function!!!!
	// Do not edit this function!!!!

	// Assume that we are not running in vintage mode
	mbVintageMode = false;

	// This location provides a convenient time to set up all of the known relay drivers.  The calls below will also set up the default cbit map.
	std::vector<int> viCBitList;
	
	viCBitList.push_back(-1);
	
	DefineRelayDriver("UNKNOWN", Maxim::CBits::RelayDriverUnknown, viCBitList);

	int iCBit = 0;
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("ETS Bank A", Maxim::CBits::RelayDriverETS, viCBitList, 'a');
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("ETS Bank B", Maxim::CBits::RelayDriverETS, viCBitList, 'b');
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("ETS Bank C", Maxim::CBits::RelayDriverETS, viCBitList, 'c');
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("ETS Bank D", Maxim::CBits::RelayDriverETS, viCBitList, 'd');

	//Add cbits for I2C sequentially for each potential address.

	//The following I2C drivers are on the load board
	iCBit = 1000;
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x20", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x20);
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x22", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x22);
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x24", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x24);
	viCBitList.clear();

	//The remaining I2C drivers are on the contactor board.
	iCBit = 2000; //Originally contactor board CBits would start right after load board relays, i.e. 1048, but it has been decided that they will start at 2000 moving forward. BRS 6/3/13
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x26", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x26);
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x28", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x28);
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x2A", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x2A);
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x2C", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x2C);
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x2E", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x2E);


	//The following group definitions should allow maintenance of backward compatibility to a point in time where contactor board relays started at 1048.  BRS 6/3/13
	for(int i = 0; i < 5*16; i++)
	{
		std::stringstream ssRelayName;
		ssRelayName << "K" << 1048 + i;
		viCBitList.clear();
		viCBitList.push_back(2000 + i);
		DefineRelayDriver(ssRelayName.str(),Maxim::CBits::RelayDriverGroup, viCBitList, 1048 + i);
	}

	// Adding support for the 0x3X series of relay drivers
	iCBit = 3000;
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x30", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x30);
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x32", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x32);
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x34", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x34);
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x36", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x36);
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x38", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x38);
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x3A", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x3A);
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x3C", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x3C);
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x3E", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x3E);
	viCBitList.clear();

	// Adding support for the 0x5X series of relay drivers
	iCBit = 5000;
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x50", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x50);
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x52", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x52);
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x54", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x54);
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x56", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x56);
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x58", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x58);
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x5A", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x5A);
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x5C", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x5C);
	viCBitList.clear();
	for(int i=0; i<16; i++) viCBitList.push_back(iCBit++);
	DefineRelayDriver("PCA9671_0x5E", Maxim::CBits::RelayDriverPCA9671, viCBitList, 0x5E);
	viCBitList.clear();

	//Do not edit

	//Do not edit

	//Do not edit

	// Really, do not edit !!!
}

/************************************************************************************************************************************************************For*Doxygen**//**
Allow users to define their own cbits and set all of the associated values.  This will include groups of relays or chips put on their test fixture

@param	iCBitNumber		CBit Number that is being defined.
@param	sDesignator		designator of the cbit on the test fixture, for example K11.
@param	sRelayDriver	Name of the relay driver chip.  Recommend using the same name as is on the test hardware.

@return 0 if all ran normally.  Returns 1 if a CBit was reassigned.   
**************************************************************************************************************************************************************/
int MaximCBits::DefineCBit(unsigned int iCBitNumber, std::string sDesignator, std::string sRelayDriver) {
	// Had a bunch of extra parameters, but not sure why.  Perhaps changed strategy and never deleted, std::string sRelayType, int iSite,  eCBitLogic logic, int iState) { 

	unsigned int uiStatus = 0;

	if (mapCBits.count(iCBitNumber)) uiStatus = 1; // !!!! Tried to re-assign a cBit.

	if (iCBitNumber >= 0) mapCBits[iCBitNumber] = CBitProperties(iCBitNumber, sRelayDriver);

	return uiStatus;

}


/************************************************************************************************************************************************************For*Doxygen**//**
Close the relays associated with the list of CBits.  This version has the list provided as a set<int>

@param	relayList	List of CBits for which the associated relays will be closed.
**************************************************************************************************************************************************************/
unsigned int MaximCBits::Close (std::set<int> relayList) {
	unsigned int uiStatus=0;
	std::set<int>::iterator it;

	for (it=relayList.begin(); it != relayList.end(); it++ )
	{
		if(maximCBits.mapCBits.count(*it))	maximCBits.mapCBits[*it].PrepareToCloseRelay();
		else {
			std::stringstream ssMessageToDisplay;
			ssMessageToDisplay << "Error:  Maxim::CBits::Extended::MaximCBits.Close failed because it was passed the invalid CBit: " << *it << std::endl;
			etsprintf(ssMessageToDisplay.str().c_str(), MB_OK);
		}

	}


	uiStatus |= maximCBits.ApplyPending();

	return uiStatus;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Open the relays associated with the list of CBits.  This version has the list provided as a set<int>

@param	relayList	List of CBits for which the associated relays will be opened.
**************************************************************************************************************************************************************/
unsigned int MaximCBits::Open (std::set<int> relayList) {
	int uiStatus=0;
	std::set<int>::iterator it;

	for (it=relayList.begin(); it != relayList.end(); it++ )
	{
		if(maximCBits.mapCBits.count(*it))	maximCBits.mapCBits[*it].PrepareToOpenRelay();
		else {
			std::stringstream ssMessageToDisplay;
			ssMessageToDisplay << "Error:  Maxim::CBits::Extended::MaximCBits.Open failed because it was passed the invalid CBit: " << *it << std::endl;
			etsprintf(ssMessageToDisplay.str().c_str(), MB_OK);
		}
	}
	uiStatus |= maximCBits.ApplyPending();

	return uiStatus;

}

/************************************************************************************************************************************************************For*Doxygen**//**
Apply all pending actions to all CBits.  This involves opening or closing relays that were specified in an earlier step.  Only sends command to
	driver if CBit is actually changing state, for example it will not waste time sending a close command if the relay is already closed.
	Keep in mind that changing the state of a CBit is a two step process.  First one lets the tester know what state they would like 
	to change one or more of the CBits to, these are the "pending states".  Then they must apply all the appending actions.  This two
	step approach allows optimization of the number of commands sent to the various relay drivers, specifically if a single driver 
	controls multiple CBits, only one command is sent instead of several.
**************************************************************************************************************************************************************/
int MaximCBits::ApplyPending(){

	int				iStatus=0;
	unsigned long	ulMaximumSettleTime=0;

	//New Method
	std::set<Maxim::CBits::Extended::RelayDriver*>::iterator it;
	for(it=maximCBits.setRelayDriversWithPendingActions.begin(); it !=maximCBits.setRelayDriversWithPendingActions.end(); it++){
		ulMaximumSettleTime = max(ulMaximumSettleTime, (*it)->GetPendingRelaySettleTime());
		iStatus |= (*it)->ApplyPending();
	}

	// Only call if settling time is needed.
	if (ulMaximumSettleTime) Maxim::CBits::Extended::maximCBits.UpdateRelaySettleTimeStamp(ulMaximumSettleTime);


	maximCBits.setRelayDriversWithPendingActions.clear();

	return iStatus;

}

/************************************************************************************************************************************************************For*Doxygen**//**
Checks ltime and adds the desired amount of settling time to find out when the current relay will settle.  Then compare with the existing relay
	settle time stamp and updated the class variable mulWhenRelaysWillSettle to be the maximum of the two values. 

@param	usToSettle	Number of microseconds that are required to settle.  This value will be added to the current time stamp.	
**************************************************************************************************************************************************************/
void MaximCBits::UpdateRelaySettleTimeStamp(unsigned long ulUSToSettle){

	unsigned long ulWhenThisRelayWillSettle;

	ulWhenThisRelayWillSettle = ltime(7) + ulUSToSettle;

	mulWhenRelaysWillSettle = max(mulWhenRelaysWillSettle, ulWhenThisRelayWillSettle);
		
}

/************************************************************************************************************************************************************For*Doxygen**//**
Closes all relays.
**************************************************************************************************************************************************************/
void MaximCBits::CloseAllRelays(){
	std::map<int, CBitProperties>::iterator it;

	for(it=mapCBits.begin(); it != mapCBits.end(); it++){
		(*it).second.PrepareToCloseRelay();
	}
	ApplyPending();
}

/************************************************************************************************************************************************************For*Doxygen**//**
Opens all relays.
**************************************************************************************************************************************************************/
void MaximCBits::OpenAllRelays(){
	std::map<int, CBitProperties>::iterator it;

	for(it=mapCBits.begin(); it != mapCBits.end(); it++){
		(*it).second.PrepareToOpenRelay();
	}
	ApplyPending();
}

/************************************************************************************************************************************************************For*Doxygen**//**
Sets all CBits to a specified state, either 1 or 0.  

@param	cBitState	The state that CBits will be set to.	
**************************************************************************************************************************************************************/
void MaximCBits::SetAllCBits(int cBitState){
	std::map<int, CBitProperties>::iterator it;

	for(it=mapCBits.begin(); it != mapCBits.end(); it++){
		(*it).second.PrepareToSetCBit(cBitState);
	}
	ApplyPending();
}

/************************************************************************************************************************************************************For*Doxygen**//**
Wait for the time stored in mulWhenRelaysWillSettle to pass.  This will be the point at which all relays should have finished opening/closing, 
	if the relay specifications and CBit associations were set up properly.  A maximum wait time of 1 second is allowed.  this should help prevent
	the function from getting stuck in an infinite loop, should something unexpected happen. 
	Update mulTotalRelayWaitTime to keep track of how much total time was used waiting in this function for relays to settle.
**************************************************************************************************************************************************************/
void MaximCBits::WaitForRelaysToSettle(){
	int iWaitStep = 50, iWaitMax = 1000000;
	unsigned long ulStartWaiting;

	ulStartWaiting = ltime(7);
	for (int iWaitUS = 0; (iWaitUS < iWaitMax) && (ltime(7) < mulWhenRelaysWillSettle); iWaitUS+=iWaitStep)	lwait(iWaitStep);

	mulTotalRelayWaitTime += ltime(7) - ulStartWaiting;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Used at beginning of each insertion.  Set mulWhenRelaysWillSettle to the current time reading.  This way if WaitForRelaysToSettle is called, 
	there will be no wait time.  In addition, it resets mulTotalRelayWaitTime to 0.
**************************************************************************************************************************************************************/
void MaximCBits::ResetRelayWaitTime(){
	mulWhenRelaysWillSettle = ltime(7);
	mulTotalRelayWaitTime = 0;
}
// End of class based functions.

/************************************************************************************************************************************************************For*Doxygen**//**
Interpret and clean up information that was read in from the pin map file for a specific CBit.  Specifically handles the cases where the pin map applies to 
	all sites.  A -1 is used by pin map file to mean all sights, but in this library we need to indicate every site that the CBit is associated with.
**************************************************************************************************************************************************************/
void CBitProperties::CBitSiteCleanUp(){
	// Converts all sites with -1 stored into a list of all available sites.  -1 was used when first reading the pin map file, because at that time we did not know
	//   how many sites existed.
	/*
		if((mSite.count(-1))||(mSite.size() > Maxim::GetNumSites()) ){
			mSite.clear();
			for (int iSite=0; iSite<Maxim::GetNumSites();iSite++)	mSite.insert(iSite);
		}
	/* Strategy of clearing out -1s did not work well*/  
}

/************************************************************************************************************************************************************For*Doxygen**//**
Cycles through all CBits, and cleans up information that was read in from the pin map file.  Specifically handle the cases where the pin map 
	applies to all sites.  A -1 is used by pin map file, but in this library we need to indicate every site that the CBit is associated with.
**************************************************************************************************************************************************************/

void CBitSiteMapCleanUp(){
	std::map<int, CBitProperties >::iterator it;
	for(it = maximCBits.mapCBits.begin(); it!= maximCBits.mapCBits.end(); it++) it->second.CBitSiteCleanUp();
}

/// @cond DontDocument
/************************************************************************************************************************************************************For*Doxygen**//**
Wrapper functions that will be substituted for standard ETS function cbitclose.  The insertion of this wrapper should be transparent to the
	the engineer.  They should never call this function directly.

@param	iX0 through iX15		Provide up to 16 CBit integers, as seperate parameters that will be closed.
**************************************************************************************************************************************************************/
int Maximcbitclose( int iX0, int iX1, int iX2, int iX3, int iX4, int iX5, int iX6, int iX7, int iX8, int iX9, int iX10, int iX11, int iX12, int iX13, int iX14, int iX15)
{	
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();	
#endif


	int		iTempArray[] = {iX0, iX1, iX2, iX3, iX4, iX5, iX6, iX7, iX8, iX9, iX10, iX11, iX12, iX13, iX14, iX15, -1};

	std::set <int> cBitSet; 
	for(int iIndex=0; iTempArray[iIndex]>=0; iIndex++) cBitSet.insert(iTempArray[iIndex]);


	if (Maxim::CBits::Extended::maximCBits.IsVintageMode()){
		bool bVintageIsOK = true;

		for(std::set<int>::iterator it=cBitSet.begin(); it!=cBitSet.end(); it++){
			if ((*it > 64) && (!Maxim::PinMap::mapPGMEInt.count(*it))) bVintageIsOK = false;
		}

		if(bVintageIsOK) {
			for(std::set<int>::iterator it=cBitSet.begin(); it!=cBitSet.end(); it++){
				Maxim::CBits::Extended::maximCBits.mapCBits.find(*it)->second.DoNotUseSetState(0);
			}
			
			return cbitclose( iX0,  iX1,  iX2,  iX3,  iX4,  iX5,  iX6,  iX7,  iX8,  iX9,  iX10,  iX11,  iX12,  iX13,  iX14,  iX15);

		}
	}


	return	maximCBits.Close(cBitSet);
}	

/************************************************************************************************************************************************************For*Doxygen**//**
Use of this function is discouraged.  Using strings prevents error checking and can be more difficult to debug.  This function allows the user 
	to pass in a string based list of CBits that are to be closed.  

@param	sCBitList	A string based CBit list.
**************************************************************************************************************************************************************/

int Maximcbitclose( std::string sCBitList){
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();	
#endif
	
	std::set <int> cBitset;
	cBitset = StringToCBitSet(sCBitList);

	return	maximCBits.Close(cBitset);
}

/************************************************************************************************************************************************************For*Doxygen**//**
I do not expect this function to be used.  It was intended to provide flexibility in closing groups of relays.  This function allows the user 
	to pass in a set<int> based list of CBits that are to be closed.  

@param	cBitSet		A set based CBit list.
**************************************************************************************************************************************************************/
int Maximcbitclose( std::set<int> cBitSet){
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();	
#endif
	
	return	maximCBits.Close(cBitSet);
}

/************************************************************************************************************************************************************For*Doxygen**//**
It was intended to provide flexibility in closing groups of relays.  This function allows the user 
	to pass in a vector<int> based list of CBits that are to be closed.  

@param	cBitList0 - cBitList7		A set based CBit list.
**************************************************************************************************************************************************************/
int Maximcbitclose( std::vector<int> cBitList0, std::vector<int> cBitList1, std::vector<int> cBitList2, std::vector<int> cBitList3, 
			std::vector<int> cBitList4, std::vector<int> cBitList5, std::vector<int> cBitList6, std::vector<int> cBitList7 )
{
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();	
#endif
	set<int> setiCBit;

	for(std::vector<int>::iterator it=cBitList0.begin(); it != cBitList0.end(); it++) setiCBit.insert(*it);
	for(std::vector<int>::iterator it=cBitList1.begin(); it != cBitList1.end(); it++) setiCBit.insert(*it);
	for(std::vector<int>::iterator it=cBitList2.begin(); it != cBitList2.end(); it++) setiCBit.insert(*it);
	for(std::vector<int>::iterator it=cBitList3.begin(); it != cBitList3.end(); it++) setiCBit.insert(*it);
	for(std::vector<int>::iterator it=cBitList4.begin(); it != cBitList4.end(); it++) setiCBit.insert(*it);
	for(std::vector<int>::iterator it=cBitList5.begin(); it != cBitList5.end(); it++) setiCBit.insert(*it);
	for(std::vector<int>::iterator it=cBitList6.begin(); it != cBitList6.end(); it++) setiCBit.insert(*it);
	for(std::vector<int>::iterator it=cBitList7.begin(); it != cBitList7.end(); it++) setiCBit.insert(*it);

	return	maximCBits.Close(setiCBit);
}
/************************************************************************************************************************************************************For*Doxygen**//**
Wrapper functions that will be substituted for standard ETS function cbitopen.  The insertion of this wrapper should be transparent to the
	the engineer.  They should never call this function directly.

@param	iX0 through iX15		Provide up to 16 CBit integers, as seperate parameters that will be opened.
**************************************************************************************************************************************************************/
int Maximcbitopen( int iX0, int iX1, int iX2, int iX3, int iX4, int iX5, int iX6, int iX7, int iX8, int iX9, int iX10, int iX11, int iX12, int iX13, int iX14, int iX15 )
{	
#ifdef MAXIM_DEGLITCH	
		Maxim::Deglitch::glitch_handling();	
#endif

	int		iTempArray[] = {iX0, iX1, iX2, iX3, iX4, iX5, iX6, iX7, iX8, iX9, iX10, iX11, iX12, iX13, iX14, iX15, -1};

	std::set <int> cBitSet; 
	for(int iIndex=0; iTempArray[iIndex]>=0; iIndex++) cBitSet.insert(iTempArray[iIndex]);


// Allow to run faster if in Vintage Mode.  Will lose some features, like relay logic and won't be called if anything other than tester CBits are passed in.
	if (Maxim::CBits::Extended::maximCBits.IsVintageMode()){
		bool bVintageIsOK = true;

		for(std::set<int>::iterator it=cBitSet.begin(); it!=cBitSet.end(); it++){
			if ((*it > 64) && (!Maxim::PinMap::mapPGMEInt.count(*it))) bVintageIsOK = false;
		}

		if(bVintageIsOK){
			for(std::set<int>::iterator it=cBitSet.begin(); it!=cBitSet.end(); it++){
				Maxim::CBits::Extended::maximCBits.mapCBits.find(*it)->second.DoNotUseSetState(0);
			}

			return cbitopen( iX0,  iX1,  iX2,  iX3,  iX4,  iX5,  iX6,  iX7,  iX8,  iX9,  iX10,  iX11,  iX12,  iX13,  iX14,  iX15);
		}
	}


	return	maximCBits.Open(cBitSet);
}

/************************************************************************************************************************************************************For*Doxygen**//**
Use of this function is discouraged.  Using strings prevents error checking and can be more difficult to debug.  This function allows the user 
	to pass in a string based list of CBits that are to be opened.  

@param	sCBitList	A string based CBit list.
**************************************************************************************************************************************************************/
int Maximcbitopen( std::string sCBitList){
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();	
#endif
	
	std::set <int> cBitSet;
	cBitSet = StringToCBitSet(sCBitList);

	return	maximCBits.Open(cBitSet);
}

/************************************************************************************************************************************************************For*Doxygen**//**
I do not expect this function to be used.  It was intended to provide flexibility in opening groups of relays.  This function allows the user 
	to pass in a set<int> based list of CBits that are to be opened.  

@param	cBitSet		A set based CBit list.
**************************************************************************************************************************************************************/
int Maximcbitopen( std::set<int> cBitSet){
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();	
#endif
	
	return	maximCBits.Open(cBitSet);
}

/************************************************************************************************************************************************************For*Doxygen**//**
This function allows the user to pass in a vector<int> based list of CBits that are to be opened.  

@param	cBitList0 - cBitList7		A vector based CBit list.
**************************************************************************************************************************************************************/
int Maximcbitopen( std::vector<int> cBitList0, std::vector<int> cBitList1, std::vector<int> cBitList2, std::vector<int> cBitList3, 
			std::vector<int> cBitList4, std::vector<int> cBitList5, std::vector<int> cBitList6, std::vector<int> cBitList7 )
{
#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();	
#endif

	set<int> setiCBit;

	for(std::vector<int>::iterator it=cBitList0.begin(); it != cBitList0.end(); it++) setiCBit.insert(*it);
	for(std::vector<int>::iterator it=cBitList1.begin(); it != cBitList1.end(); it++) setiCBit.insert(*it);
	for(std::vector<int>::iterator it=cBitList2.begin(); it != cBitList2.end(); it++) setiCBit.insert(*it);
	for(std::vector<int>::iterator it=cBitList3.begin(); it != cBitList3.end(); it++) setiCBit.insert(*it);
	for(std::vector<int>::iterator it=cBitList4.begin(); it != cBitList4.end(); it++) setiCBit.insert(*it);
	for(std::vector<int>::iterator it=cBitList5.begin(); it != cBitList5.end(); it++) setiCBit.insert(*it);
	for(std::vector<int>::iterator it=cBitList6.begin(); it != cBitList6.end(); it++) setiCBit.insert(*it);
	for(std::vector<int>::iterator it=cBitList7.begin(); it != cBitList7.end(); it++) setiCBit.insert(*it);

	return	maximCBits.Open(setiCBit);
}
/// @endcond DontDocument


/************************************************************************************************************************************************************For*Doxygen**//**
Maxim wrapper function that will be substituted in place of the cbita_set, cbitb_set, cbitc_set and cbitd_set functions.  Writes a word to ETS driver.

@param	iCBitWord		The 16 bit word that will be written to the appropriate ETS driver.
@param	iRegisterOffset	0 for register a, 1 for register b, 2 for register c and 3 for register d.

@return		Returns the value from the associated ETS command.   
**************************************************************************************************************************************************************/
int Maximcbitx_set( int iCBitWord, int iRegisterOffset){
	int iError = 0;

	#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();	
	#endif

	switch (iRegisterOffset) {
		case 0 : 
			iError = cbita_set(iCBitWord);
			break;
		case 1 :
			iError = cbitb_set(iCBitWord);
			break;
		case 2 :
			iError = cbitc_set(iCBitWord);
			break;
		case 3 :
			iError = cbitd_set(iCBitWord);
			break;
		default :
			std::stringstream ssMessageToDisplay;
			ssMessageToDisplay << "Maxim::CBits::Extended::Maximcbitx_set failed because it was passed the invalid register offset: " << iRegisterOffset;
			etsMessageBox(ssMessageToDisplay.str().c_str(), MB_OK);
	}

	return iError;
};

/************************************************************************************************************************************************************For*Doxygen**//**
Maxim wrapper function that will be substituted in place of the cbita_close, cbitb_close, cbitc_close and cbitd_close functions.  Writes a word to ETS
	driver.

@param	iCBitWord		The 16 bit word indicating which relays will be closed.  Setting a bit of to 1 sets that relay control line to logic LOW
@param	iRegisterOffset	0 for register a, 1 for register b, 2 for register c and 3 for register d.

@return	Returns the value from the associated ETS command.   
**************************************************************************************************************************************************************/
int Maximcbitx_close( int iCBitWord, int iRegisterOffset){
	int iError = 0;

	#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();	
	#endif

	switch (iRegisterOffset) {
		case 0 : 
			iError = cbita_close(iCBitWord);
			break;
		case 1 :
			iError = cbitb_close(iCBitWord);
			break;
		case 2 :
			iError = cbitc_close(iCBitWord);
			break;
		case 3 :
			iError = cbitd_close(iCBitWord);
			break;
		default :
			std::stringstream ssMessageToDisplay;
			ssMessageToDisplay << "Maxim::CBits::Extended::Maximcbitx_close failed because it was passed the invalid register offset: " << iRegisterOffset;
			etsMessageBox(ssMessageToDisplay.str().c_str(), MB_OK);
	}

	return iError;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Maxim wrapper function that will be substituted in place of the cbita_open, cbitb_open, cbitc_open and cbitd_open functions.  Writes a word to ETS
	driver.

@param	iCBitWord		The 16 bit word indicating which relays will be closed.  Setting a bit of to 1 sets that relay control line to logic HIGH
@param	iRegisterOffset	0 for register a, 1 for register b, 2 for register c and 3 for register d.

@return	Returns the value from the associated ETS command.   
**************************************************************************************************************************************************************/
int Maximcbitx_open( int iCBitWord, int iRegisterOffset){
	int iError = 0;

	#ifdef MAXIM_DEGLITCH
		Maxim::Deglitch::glitch_handling();	
	#endif

	switch (iRegisterOffset) {
		case 0 : 
			iError = cbita_open(iCBitWord);
			break;
		case 1 :
			iError = cbitb_open(iCBitWord);
			break;
		case 2 :
			iError = cbitc_open(iCBitWord);
			break;
		case 3 :
			iError = cbitd_open(iCBitWord);
			break;
		default :
			std::stringstream ssMessageToDisplay;
			ssMessageToDisplay << "Maxim::CBits::Extended::Maximcbitx_open failed because it was passed the invalid register offset: " <<	iRegisterOffset;
			etsMessageBox(ssMessageToDisplay.str().c_str(), MB_OK);
	}

	return iError;
}


		} //namespace Extended
	} //namespace CBits

}//namespace Maxim

// Global variable definitions

namespace Maxim
{
	namespace CBits
	{
		namespace Extended
		{

std::map <std::string, Maxim::CBits::Extended::RelayProperties> mapRelayTypes;

std::map <std::string, Maxim::CBits::Extended::RelayDriver*> mapRelayDriver;

Maxim::CBits::Extended::MaximCBits maximCBits; 

/************************************************************************************************************************************************************For*Doxygen**//**
Looks for ranges of instruments in a string and replaces with a discrete list.  For example CBIT2-5 will become 
	CBIT2 CBIT3 CBIT4 CBIT5.  Written to be used with strings that are passed into groupset and string based cBit commands.*

@param	&input	A string that lists a group of resources.
**************************************************************************************************************************************************************/
 
void StringRangeToList(std::string &input){
	size_t posdash=0, posstart, posmid, posend, startdelete; // Store various string positions.
	std::string sPrefix;
	int	iFirstChannel, iLastChannel;

	// Replace all "," with space.  Easier to deal with a single delimiter.
	replace(input.begin(), input.end(), ',', ' ');

	// Find each "-" in the string.  These correspond to a range of instruments.
	for(posdash = input.find('-', posdash); posdash < input.npos; posdash = input.find('-', posdash)){
		for(posend = posdash-1; input.at(posend)==' '; posend--);		// Search backwards to first non-space
		for(posmid = posend-1; isdigit(input.at(posmid)) ; posmid--);	// Search backwards to first non-number
		for(posstart = posmid-1; isalpha(input.at(posstart-1)) ; posstart--);	// Search backwards to beginning of characters
		startdelete = posstart;
		sPrefix = input.substr(posstart, posmid-posstart + 1);
		iFirstChannel = atoi( input.substr(posmid+1, posend-posmid).c_str());

		// Now that we have the prefix and channel of the beginning of the instrument range, we can proceed to finding the end of the range
		for(posstart = posdash+1; !isalpha(input.at(posstart)) ; posstart++);	// Search to beginning of characters
		for(posmid = posstart; !isdigit(input.at(posmid+1)) ; posmid++);	// Search to first number
		for(posend = posmid+1; isdigit(input.at(posend+1)); posend++);		// Search to first non-number
		iLastChannel = atoi( input.substr(posmid+1, posend-posmid).c_str());

		//Make sure the instruments on each side of the "-" match
		if(sPrefix != input.substr(posstart, posend - posstart + 1)){
			etsprintf("Error: Range of %s did not match in the following string: %s\n", sPrefix, input);
			return ;
		}

		input.erase(startdelete, posend - startdelete + 1);
		for(int i=iFirstChannel; i <= iLastChannel; i++){
			std::stringstream ssIO;
			ssIO << sPrefix << i << " ";
			input.insert(startdelete, ssIO.str().c_str());
		}
	}

}

/************************************************************************************************************************************************************For*Doxygen**//**
Parses a space delimited list of items and returns them as a set of items

@param	sStringList	A string that lists multiple items

@return	Set of items based on sStringList input
**************************************************************************************************************************************************************/
std::set <int> StringToCBitSet(std::string sStringList){
	// Make the string easier to deal with
	StringRangeToList(sStringList);

	// Tokenize the resource string
	std::string sBuffer; // Create a string buffer
	std::stringstream ss(sStringList); // Insert the string into a stream
	std::set<int> setiCBits;

	while (ss >> sBuffer){
		if(Maxim::CBits::Extended::maximCBits.mapCBitDesignators.count(sBuffer)){
			setiCBits.insert(Maxim::CBits::Extended::maximCBits.mapCBitDesignators[sBuffer]->GetCBitNumber());
		}
		else {
			std::stringstream ssMessageToDisplay;
			ssMessageToDisplay << "Warning from Maxim::CBits::Extended::StringToCBitSet \nYou are trying to access a CBit designator that does not exist. \n"
				<< "Designator causing the warning is: " << sBuffer;
			etsprintf(ssMessageToDisplay.str().c_str());
		}
	}

	return setiCBits;
}

/************************************************************************************************************************************************************For*Doxygen**//**
Parses a CSV string and stores results in a vector

@param	sCSVString	A CSV string

@return	Vector based on sCSVString
**************************************************************************************************************************************************************/
std::vector<std::string> CSVStringToVector(std::string sCSVString)
	// Reads a line from a CSV file and splits into tokens
{
	std::vector<std::string>   result;

	std::stringstream          lineStream(sCSVString);
	std::string                sCell;

	while(std::getline(lineStream,sCell,','))
	{
		// Remove spaces at beginning of string
		bool bDone = false;
		while( (sCell.size() > 0) && (!bDone))
		{
			if (sCell[0] == ' ')	sCell.erase(0, 1); 
			else bDone = true;
		}
		result.push_back(sCell);
	}
	return result;
}

		} //Extended
	} //namespace CBits
} //namespace Maxim

/************************************************************************************************************************************************************For*Doxygen**//**
Close the indicated CBit

@param	iX0		CBit to close

@remarks, note that up to 16 CBits can be passed into this function at the same time.
**************************************************************************************************************************************************************/

// These various cbitclose and open commands are needed for Immediate Window debugging.  There seems to be a limitation where
//    optional parameters are not allowed in the immediate window, therefore you must supply all parameters.
//    My work around is to have multiple versions of the functions, each with a different number of parameters.  BRS 1/31/13
void cbitclose( int iX0){
	 Maxim::CBits::Extended::Maximcbitclose( iX0);}
void cbitclose( int iX0, int iX1){
	 Maxim::CBits::Extended::Maximcbitclose( iX0, iX1);}
void cbitclose(int iX0, int iX1, int iX2){
	 Maxim::CBits::Extended::Maximcbitclose( iX0, iX1,  iX2);}
void cbitclose(int iX0, int iX1, int iX2, int iX3){
	 Maxim::CBits::Extended::Maximcbitclose( iX0, iX1,  iX2, iX3);}
void cbitclose(int iX0, int iX1, int iX2, int iX3, int iX4){
	 Maxim::CBits::Extended::Maximcbitclose( iX0, iX1,  iX2, iX3, iX4);}
void cbitclose(int iX0, int iX1, int iX2, int iX3, int iX4, int iX5){
	 Maxim::CBits::Extended::Maximcbitclose( iX0, iX1,  iX2, iX3, iX4, iX5);}
void cbitclose(int iX0, int iX1, int iX2, int iX3, int iX4, int iX5, int iX6){
	 Maxim::CBits::Extended::Maximcbitclose( iX0, iX1,  iX2, iX3, iX4, iX5, iX6);}
void cbitclose(int iX0, int iX1, int iX2, int iX3, int iX4, int iX5, int iX6, int iX7){
	 Maxim::CBits::Extended::Maximcbitclose( iX0, iX1,  iX2, iX3, iX4, iX5, iX6, iX7);}
void cbitclose(int iX0, int iX1, int iX2, int iX3, int iX4, int iX5, int iX6, int iX7, int iX8){
	 Maxim::CBits::Extended::Maximcbitclose( iX0, iX1,  iX2, iX3, iX4, iX5, iX6, iX7, iX8);}
void cbitclose(int iX0, int iX1, int iX2, int iX3, int iX4, int iX5, int iX6, int iX7, int iX8, int iX9){
	 Maxim::CBits::Extended::Maximcbitclose( iX0, iX1,  iX2, iX3, iX4, iX5, iX6, iX7, iX8, iX9);}
void cbitclose(int iX0, int iX1, int iX2, int iX3, int iX4, int iX5, int iX6, int iX7, int iX8, int iX9, int iX10){
	 Maxim::CBits::Extended::Maximcbitclose( iX0, iX1,  iX2, iX3, iX4, iX5, iX6, iX7, iX8, iX9, iX10);}
void cbitclose(int iX0, int iX1, int iX2, int iX3, int iX4, int iX5, int iX6, int iX7, int iX8, int iX9, int iX10, int iX11){
	 Maxim::CBits::Extended::Maximcbitclose( iX0, iX1,  iX2, iX3, iX4, iX5, iX6, iX7, iX8, iX9, iX10, iX11);}
void cbitclose(int iX0, int iX1, int iX2, int iX3, int iX4, int iX5, int iX6, int iX7, int iX8, int iX9, int iX10, int iX11, int iX12){
	 Maxim::CBits::Extended::Maximcbitclose( iX0, iX1,  iX2, iX3, iX4, iX5, iX6, iX7, iX8, iX9, iX10, iX11, iX12);}
void cbitclose(int iX0, int iX1, int iX2, int iX3, int iX4, int iX5, int iX6, int iX7, int iX8, int iX9, int iX10, int iX11, int iX12, int iX13){
	 Maxim::CBits::Extended::Maximcbitclose( iX0, iX1,  iX2, iX3, iX4, iX5, iX6, iX7, iX8, iX9, iX10, iX11, iX12, iX13);}
void cbitclose(int iX0, int iX1, int iX2, int iX3, int iX4, int iX5, int iX6, int iX7, int iX8, int iX9, int iX10, int iX11, int iX12, int iX13, int iX14 ){
	 Maxim::CBits::Extended::Maximcbitclose( iX0, iX1,  iX2, iX3, iX4, iX5, iX6, iX7, iX8, iX9, iX10, iX11, iX12, iX13, iX14);}

void cbitclose( std::vector<int> cBitList0){
	Maxim::CBits::Extended::Maximcbitclose( cBitList0);}
void cbitclose( std::vector<int> cBitList0, std::vector<int> cBitList1){
	Maxim::CBits::Extended::Maximcbitclose( cBitList0, cBitList1);}
void cbitclose( std::vector<int> cBitList0, std::vector<int> cBitList1, std::vector<int> cBitList2){
	Maxim::CBits::Extended::Maximcbitclose( cBitList0, cBitList1, cBitList2);}
void cbitclose( std::vector<int> cBitList0, std::vector<int> cBitList1, std::vector<int> cBitList2, std::vector<int> cBitList3){
	Maxim::CBits::Extended::Maximcbitclose( cBitList0, cBitList1, cBitList2, cBitList3);}
void cbitclose( std::vector<int> cBitList0, std::vector<int> cBitList1, std::vector<int> cBitList2, std::vector<int> cBitList3, std::vector<int> cBitList4){
	Maxim::CBits::Extended::Maximcbitclose( cBitList0, cBitList1, cBitList2, cBitList3, cBitList4);}
void cbitclose( std::vector<int> cBitList0, std::vector<int> cBitList1, std::vector<int> cBitList2, std::vector<int> cBitList3, std::vector<int> cBitList4, std::vector<int> cBitList5){
	Maxim::CBits::Extended::Maximcbitclose( cBitList0, cBitList1, cBitList2, cBitList3, cBitList4, cBitList5);}
void cbitclose( std::vector<int> cBitList0, std::vector<int> cBitList1, std::vector<int> cBitList2, std::vector<int> cBitList3, std::vector<int> cBitList4, std::vector<int> cBitList5, std::vector<int> cBitList6 ){
	Maxim::CBits::Extended::Maximcbitclose( cBitList0, cBitList1, cBitList2, cBitList3, cBitList4, cBitList5, cBitList6 );}

/************************************************************************************************************************************************************For*Doxygen**//**
Open the indicated CBit

@param	iX0		CBit to open

@remarks, note that up to 16 CBits can be passed into this function at the same time.
**************************************************************************************************************************************************************/
void cbitopen( int iX0){
	 Maxim::CBits::Extended::Maximcbitopen( iX0);}
void cbitopen( int iX0, int iX1){
	 Maxim::CBits::Extended::Maximcbitopen( iX0, iX1);}
void cbitopen(int iX0, int iX1, int iX2){
	 Maxim::CBits::Extended::Maximcbitopen( iX0, iX1,  iX2);}
void cbitopen(int iX0, int iX1, int iX2, int iX3){
	 Maxim::CBits::Extended::Maximcbitopen( iX0, iX1,  iX2, iX3);}
void cbitopen(int iX0, int iX1, int iX2, int iX3, int iX4){
	 Maxim::CBits::Extended::Maximcbitopen( iX0, iX1,  iX2, iX3, iX4);}
void cbitopen(int iX0, int iX1, int iX2, int iX3, int iX4, int iX5){
	 Maxim::CBits::Extended::Maximcbitopen( iX0, iX1,  iX2, iX3, iX4, iX5);}
void cbitopen(int iX0, int iX1, int iX2, int iX3, int iX4, int iX5, int iX6){
	 Maxim::CBits::Extended::Maximcbitopen( iX0, iX1,  iX2, iX3, iX4, iX5, iX6);}
void cbitopen(int iX0, int iX1, int iX2, int iX3, int iX4, int iX5, int iX6, int iX7){
	 Maxim::CBits::Extended::Maximcbitopen( iX0, iX1,  iX2, iX3, iX4, iX5, iX6, iX7);}
void cbitopen(int iX0, int iX1, int iX2, int iX3, int iX4, int iX5, int iX6, int iX7, int iX8){
	 Maxim::CBits::Extended::Maximcbitopen( iX0, iX1,  iX2, iX3, iX4, iX5, iX6, iX7, iX8);}
void cbitopen(int iX0, int iX1, int iX2, int iX3, int iX4, int iX5, int iX6, int iX7, int iX8, int iX9){
	 Maxim::CBits::Extended::Maximcbitopen( iX0, iX1,  iX2, iX3, iX4, iX5, iX6, iX7, iX8, iX9);}
void cbitopen(int iX0, int iX1, int iX2, int iX3, int iX4, int iX5, int iX6, int iX7, int iX8, int iX9, int iX10){
	 Maxim::CBits::Extended::Maximcbitopen( iX0, iX1,  iX2, iX3, iX4, iX5, iX6, iX7, iX8, iX9, iX10);}
void cbitopen(int iX0, int iX1, int iX2, int iX3, int iX4, int iX5, int iX6, int iX7, int iX8, int iX9, int iX10, int iX11){
	 Maxim::CBits::Extended::Maximcbitopen( iX0, iX1,  iX2, iX3, iX4, iX5, iX6, iX7, iX8, iX9, iX10, iX11);}
void cbitopen(int iX0, int iX1, int iX2, int iX3, int iX4, int iX5, int iX6, int iX7, int iX8, int iX9, int iX10, int iX11, int iX12){
	 Maxim::CBits::Extended::Maximcbitopen( iX0, iX1,  iX2, iX3, iX4, iX5, iX6, iX7, iX8, iX9, iX10, iX11, iX12);}
void cbitopen(int iX0, int iX1, int iX2, int iX3, int iX4, int iX5, int iX6, int iX7, int iX8, int iX9, int iX10, int iX11, int iX12, int iX13){
	 Maxim::CBits::Extended::Maximcbitopen( iX0, iX1,  iX2, iX3, iX4, iX5, iX6, iX7, iX8, iX9, iX10, iX11, iX12, iX13);}
void cbitopen(int iX0, int iX1, int iX2, int iX3, int iX4, int iX5, int iX6, int iX7, int iX8, int iX9, int iX10, int iX11, int iX12, int iX13, int iX14 ){
	 Maxim::CBits::Extended::Maximcbitopen( iX0, iX1,  iX2, iX3, iX4, iX5, iX6, iX7, iX8, iX9, iX10, iX11, iX12, iX13, iX14);}


void cbitopen( std::vector<int> cBitList0){
	Maxim::CBits::Extended::Maximcbitopen( cBitList0);}
void cbitopen( std::vector<int> cBitList0, std::vector<int> cBitList1){
	Maxim::CBits::Extended::Maximcbitopen( cBitList0, cBitList1);}
void cbitopen( std::vector<int> cBitList0, std::vector<int> cBitList1, std::vector<int> cBitList2){
	Maxim::CBits::Extended::Maximcbitopen( cBitList0, cBitList1, cBitList2);}
void cbitopen( std::vector<int> cBitList0, std::vector<int> cBitList1, std::vector<int> cBitList2, std::vector<int> cBitList3){
	Maxim::CBits::Extended::Maximcbitopen( cBitList0, cBitList1, cBitList2, cBitList3);}
void cbitopen( std::vector<int> cBitList0, std::vector<int> cBitList1, std::vector<int> cBitList2, std::vector<int> cBitList3, std::vector<int> cBitList4){
	Maxim::CBits::Extended::Maximcbitopen( cBitList0, cBitList1, cBitList2, cBitList3, cBitList4);}
void cbitopen( std::vector<int> cBitList0, std::vector<int> cBitList1, std::vector<int> cBitList2, std::vector<int> cBitList3, std::vector<int> cBitList4, std::vector<int> cBitList5){
	Maxim::CBits::Extended::Maximcbitopen( cBitList0, cBitList1, cBitList2, cBitList3, cBitList4, cBitList5);}
void cbitopen( std::vector<int> cBitList0, std::vector<int> cBitList1, std::vector<int> cBitList2, std::vector<int> cBitList3, std::vector<int> cBitList4, std::vector<int> cBitList5, std::vector<int> cBitList6 ){
	Maxim::CBits::Extended::Maximcbitopen( cBitList0, cBitList1, cBitList2, cBitList3, cBitList4, cBitList5, cBitList6 );}